This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: internal/**/*, renderer/**/*
- Files matching these patterns are excluded: internal/embed/**/*, renderer/node_modules, node_modules
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
internal/
  cmd/
    start_test.go
    start.go
  errors/
    errors.go
  handlers/
    account.go
    associations.go
    auth.go
    character.go
    config.go
    dashboard_test.go
    dashboard.go
    evedata.go
    skillplan.go
    utils.go
  http/
    esi_http_client_test.go
    esi_http_client.go
    middleware_test.go
    middleware.go
    session.go
  model/
    account.go
    config.go
    eve.go
  persist/
    account/
      account_store_test.go
      account_store.go
      login_state_store.go
    config/
      app_state_store_test.go
      app_state_store.go
      config_store_test.go
      config_store.go
    eve/
      cache_store_test.go
      cache_store.go
      deleted_store_test.go
      deleted_store.go
      eve_profiles_store.go
      eve_profiles_test.go
      skill_store_test.go
      skill_store.go
      system_store.go
    crypto_test.go
    crypto.go
    filesystem.go
    fileutils_test.go
    fileutils.go
  server/
    env.go
    logger.go
    router.go
    services.go
  services/
    account/
      account_service_test.go
      account_service.go
      association_service_test.go
      association_service.go
      auth_client.go
      login_service.go
    config/
      appstate_service.go
      config_service_test.go
      config_service.go
      dashboard_service_test.go
      dashboard_service.go
      logrus_adapter.go
    eve/
      cache_service.go
      character_service_test.go
      character_service.go
      esi_service_test.crap
      esi_service.go
      eve_profile_service_test.go
      eve_profile_service.go
      skill_service_test.go
      skill_service.go
    interfaces/
      account.go
      config.go
      eve.go
  testutil/
    mock_interfaces.go
    stack_logger.go
renderer/
  public/
    vite.svg
  src/
    api/
      apiRequest.jsx
      apiRequest.test.jsx
      apiService.jsx
      apiService.test.jsx
    assets/
      react.svg
    components/
      common/
        AccountPromptModal.jsx
        CharacterDetailModal.jsx
        CustomConfirmDialog.jsx
        ErrorBoundary.jsx
        Footer.jsx
        Header.jsx
        SubPageHeader.jsx
      dashboard/
        AccountCard.jsx
        AccountCard.test.jsx
        CharacterItem.jsx
        CharacterItem.test.jsx
        EditableAccountName.jsx
        GroupCard.jsx
        GroupCard.test.jsx
      landing/
        LoginButton.jsx
      mapping/
        MapAccountCard.jsx
        MapAccountCard.test.jsx
        MapCharacterCard.jsx
        MapCharacterCard.test.jsx
      skillplan/
        AddSkillPlanModal.jsx
        CharacterTable.jsx
        CharacterTable.test.jsx
        SkillPlanTable.jsx
        SkillPlanTable.test.jsx
      sync/
        SubDirectoryCard.jsx
        SubDirectoryCard.test.jsx
        SyncActionsBar.jsx
    hooks/
      useAddCharacterCallback.jsx
      useAppHandlers.jsx
      useConfirmDialog.jsx
      useLoginCallback.jsx
      useOAuthPoll.jsx
    pages/
      CharacterOverview.jsx
      CharacterOverview.test.jsx
      Landing.jsx
      Mapping.jsx
      Mapping.test.jsx
      SkillPlans.jsx
      SkillPlans.text.jsx
      Sync.jsx
      Sync.test.jsx
    utils/
      addDataTransforms.test.jsx
      appDataTransforms.jsx
      dataNormalizer.jsx
      dataNormalizer.test.jsx
      formatter.jsx
      formatter.test.jsx
      instructions.jsx
      logger.jsx
    App.css
    App.jsx
    Config.jsx
    index.css
    main.jsx
    Routes.jsx
    setupTests.js
    Theme.jsx
  .gitignore
  eslint.config.js
  index.html
  package.json
  postcss.config.cjs
  README.md
  tailwind.config.cjs
  vite.config.js
  vitest.config.js

================================================================
Files
================================================================

================
File: internal/cmd/start_test.go
================
// start_test.go
package cmd_test

import (
	"testing"
	"time"

	"github.com/guarzo/canifly/internal/cmd"
	"github.com/stretchr/testify/assert"
)

// TestStart checks if Start runs without errors when environment variables are set properly.
// Note: This won't fully test server startup because that would block indefinitely.
// If necessary, consider refactoring Start to allow dependency injection or mock out parts of the code.
func TestStart(t *testing.T) {
	// Set required environment variables that LoadConfig and services might expect
	t.Setenv("EVE_CLIENT_ID", "test_id")
	t.Setenv("EVE_CLIENT_SECRET", "test_secret")
	t.Setenv("EVE_CALLBACK_URL", "http://localhost/callback")

	// If your LoadConfig relies on other env vars or config files, set them here too.
	// For example:
	t.Setenv("SECRET_KEY", "c2VjcmV0a2V5MTIz") // base64 of 'secretkey123'
	t.Setenv("PORT", "8888")

	// Now call Start. Because Start will attempt to run a server, this will block.
	// In a real unit test, we might want to mock runServer or at least ensure it doesn't block indefinitely.
	// One approach: run Start in a goroutine and just ensure it doesn't panic immediately.
	// Another approach: temporarily modify Start to return after setup for testing.

	done := make(chan error, 1)
	go func() {
		err := cmd.Start()
		done <- err
	}()

	// Wait a short time and then assume success if no error returned
	// In reality, Start() will block on ListenAndServe, so this test might time out.
	// A better approach: factor runServer out further or mock the HTTP server.

	// We'll just test that it at least doesn't fail immediately on loading config/services.
	// If you need to actually verify the server started, you'd do more here, like try connecting to it.

	select {
	case err := <-done:
		// If we get here, that means Start returned immediately, which it shouldn't unless there's an error.
		assert.NoError(t, err)
	case <-time.After(500 * time.Millisecond):
		// If half a second passed and no error, we assume it started okay.
		// Realistically, you might send a signal here or mock runServer.
	}
}

================
File: internal/cmd/start.go
================
package cmd

import (
	"context"
	"errors"
	"fmt"
	"net"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/guarzo/canifly/internal/server"
	"github.com/guarzo/canifly/internal/services/interfaces"
)

var version = "0.0.40"

// Start initializes and runs the application with enhanced logging for startup failure scenarios.
func Start() error {
	logger := server.SetupLogger()
	logger.Infof("Starting application, version %s", version)

	cfg, err := server.LoadConfig(logger)
	if err != nil {
		return fmt.Errorf("failed to load config: %w", err)
	}

	services, err := server.GetServices(logger, cfg)
	if err != nil {
		return fmt.Errorf("failed to get services: %w", err)
	}

	r := server.SetupHandlers(cfg.SecretKey, logger, services)
	srv, listener, err := createServerWithListener(r, cfg.Port, logger)
	if err != nil {
		return fmt.Errorf("failed to create server: %w", err)
	}

	logger.Infof("Server successfully bound on port %s", cfg.Port)
	return runServer(srv, listener, logger)
}

// createServerWithListener attempts to bind to the provided port before creating the HTTP server.
// This helps catch binding errors early.
func createServerWithListener(r http.Handler, port string, logger interfaces.Logger) (*http.Server, net.Listener, error) {
	addr := ":" + port
	listener, err := net.Listen("tcp", addr)
	if err != nil {
		logger.WithError(err).Errorf("Failed to bind to address %s", addr)
		return nil, nil, err
	}
	srv := &http.Server{
		Handler: r,
	}
	return srv, listener, nil
}

// runServer starts the HTTP server and adds enhanced logging to capture startup and shutdown details.
// In DEV_MODE, the startup timeout is increased to give the backend more time to initialize.
func runServer(srv *http.Server, listener net.Listener, logger interfaces.Logger) error {
	startTime := time.Now()
	shutdownCh := make(chan error, 1)

	// Determine startup timeout based on DEV_MODE.
	timeoutDuration := 300 * time.Second
	if os.Getenv("DEV_MODE") == "true" {
		timeoutDuration = 600 * time.Second
		logger.Warn("DEV_MODE is enabled; increasing server startup timeout to 60 seconds")
	}

	// Start the server in a separate goroutine.
	go func() {
		logger.Infof("Server starting to serve requests...")
		err := srv.Serve(listener)
		if err != nil && !errors.Is(err, http.ErrServerClosed) {
			logger.WithError(err).Error("Server encountered an error while serving")
			shutdownCh <- err
		} else {
			shutdownCh <- nil
		}
	}()

	// Listen for shutdown signals.
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, os.Interrupt, syscall.SIGTERM)

	// Wait for a shutdown signal, an error from the server, or a startup timeout.
	select {
	case <-quit:
		logger.Info("Shutdown signal received")
	case err := <-shutdownCh:
		if err != nil {
			logger.WithError(err).Error("Server error during startup or runtime")
			return fmt.Errorf("server error: %w", err)
		}
	case <-time.After(timeoutDuration):
		logger.Error("Server did not start within the expected timeout; startup timeout reached")
		return fmt.Errorf("server startup timeout after %s", timeoutDuration)
	}

	logger.Info("Initiating graceful shutdown")
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	if err := srv.Shutdown(ctx); err != nil {
		logger.WithError(err).Error("Error during server shutdown")
		return fmt.Errorf("server forced to shutdown: %w", err)
	}
	elapsed := time.Since(startTime)
	logger.Infof("Server shutdown completed gracefully after %s", elapsed)
	return nil
}

================
File: internal/errors/errors.go
================
//esi/errors.go

package errors

import (
	"fmt"
	"net/http"
)

// CustomError represents an HTTP error with a status code and message
type CustomError struct {
	StatusCode int
	Message    string
}

func (e *CustomError) Error() string {
	return fmt.Sprintf("%d: %s", e.StatusCode, e.Message)
}

func NewCustomError(statusCode int, message string) *CustomError {
	return &CustomError{StatusCode: statusCode, Message: message}
}

// HttpStatusErrors Map of HTTP status codes to custom errors
var HttpStatusErrors = map[int]*CustomError{
	http.StatusForbidden:           ErrForbidden,
	http.StatusServiceUnavailable:  ErrServiceUnavailable,
	http.StatusGatewayTimeout:      ErrGatewayTimeout,
	http.StatusInternalServerError: ErrInternalServerError,
	http.StatusBadRequest:          ErrBadRequest,
	http.StatusUnauthorized:        ErrUnauthorized,
	http.StatusNotFound:            ErrNotFound,
	http.StatusMethodNotAllowed:    ErrMethodNotAllowed,
	http.StatusBadGateway:          ErrBadGateway,
}

// Predefined errors for common HTTP status codes
var (
	ErrBadRequest          = NewCustomError(http.StatusBadRequest, "bad request")
	ErrUnauthorized        = NewCustomError(http.StatusUnauthorized, "unauthorized")
	ErrForbidden           = NewCustomError(http.StatusForbidden, "forbidden")
	ErrNotFound            = NewCustomError(http.StatusNotFound, "not found")
	ErrMethodNotAllowed    = NewCustomError(http.StatusMethodNotAllowed, "method not allowed")
	ErrInternalServerError = NewCustomError(http.StatusInternalServerError, "internal server error")
	ErrBadGateway          = NewCustomError(http.StatusBadGateway, "bad gateway")
	ErrServiceUnavailable  = NewCustomError(http.StatusServiceUnavailable, "service unavailable")
	ErrGatewayTimeout      = NewCustomError(http.StatusGatewayTimeout, "gateway timeout")

	ErrNoAccounts = NewCustomError(http.StatusNotFound, "no accounts found")
)

================
File: internal/handlers/account.go
================
// handlers/account_handler.go
package handlers

import (
	"fmt"
	"net/http"

	"github.com/guarzo/canifly/internal/services/interfaces"
)

type AccountHandler struct {
	sessionService interfaces.SessionService
	accountService interfaces.AccountService
	logger         interfaces.Logger
}

func NewAccountHandler(session interfaces.SessionService, logger interfaces.Logger, accountSrv interfaces.AccountService) *AccountHandler {
	return &AccountHandler{
		sessionService: session,
		logger:         logger,
		accountService: accountSrv,
	}
}

func (h *AccountHandler) UpdateAccountName() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var request struct {
			AccountID   int64  `json:"accountID"`
			AccountName string `json:"accountName"`
		}
		if err := decodeJSONBody(r, &request); err != nil {
			respondError(w, fmt.Sprintf("Invalid request body: %v", err), http.StatusBadRequest)
			return
		}
		if request.AccountName == "" {
			respondError(w, "Account name cannot be empty", http.StatusBadRequest)
			return
		}

		err := h.accountService.UpdateAccountName(request.AccountID, request.AccountName)
		if err != nil {
			respondError(w, err.Error(), http.StatusInternalServerError)
			return
		}

		respondJSON(w, map[string]bool{"success": true})
	}
}

func (h *AccountHandler) ToggleAccountStatus() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var request struct {
			AccountID int64 `json:"accountID"`
		}
		if err := decodeJSONBody(r, &request); err != nil {
			respondError(w, fmt.Sprintf("Invalid request body: %v", err), http.StatusBadRequest)
			return
		}
		if request.AccountID == 0 {
			respondError(w, "UserId is required", http.StatusBadRequest)
			return
		}

		err := h.accountService.ToggleAccountStatus(request.AccountID)
		if err != nil {
			if err.Error() == "account not found" {
				respondError(w, "Account not found", http.StatusNotFound)
			} else {
				respondError(w, fmt.Sprintf("Failed to toggle account status: %v", err), http.StatusInternalServerError)
			}
			return
		}

		respondJSON(w, map[string]bool{"success": true})
	}
}

func (h *AccountHandler) ToggleAccountVisibility() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var request struct {
			AccountID int64 `json:"accountID"`
		}
		if err := decodeJSONBody(r, &request); err != nil {
			respondError(w, fmt.Sprintf("Invalid request body: %v", err), http.StatusBadRequest)
			return
		}
		if request.AccountID == 0 {
			respondError(w, "UserId is required", http.StatusBadRequest)
			return
		}

		err := h.accountService.ToggleAccountVisibility(request.AccountID)
		if err != nil {
			if err.Error() == "account not found" {
				respondError(w, "Account not found", http.StatusNotFound)
			} else {
				respondError(w, fmt.Sprintf("Failed to toggle account visbility: %v", err), http.StatusInternalServerError)
			}
			return
		}

		respondJSON(w, map[string]bool{"success": true})
	}
}

func (h *AccountHandler) RemoveAccount() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var request struct {
			AccountName string `json:"accountName"`
		}
		if err := decodeJSONBody(r, &request); err != nil {
			respondError(w, "Invalid request body", http.StatusBadRequest)
			return
		}
		if request.AccountName == "" {
			respondError(w, "AccountName is required", http.StatusBadRequest)
			return
		}

		err := h.accountService.RemoveAccountByName(request.AccountName)
		if err != nil {
			if err.Error() == fmt.Sprintf("account %s not found", request.AccountName) {
				respondError(w, "Account not found", http.StatusNotFound)
			} else {
				respondError(w, fmt.Sprintf("Failed to remove account: %v", err), http.StatusInternalServerError)
			}
			return
		}

		respondJSON(w, map[string]bool{"success": true})
	}
}

================
File: internal/handlers/associations.go
================
package handlers

import (
	"fmt"
	"net/http"

	"github.com/guarzo/canifly/internal/services/interfaces"
)

type AssociationHandler struct {
	logger       interfaces.Logger
	assocService interfaces.AssociationService
}

func NewAssociationHandler(
	l interfaces.Logger,
	a interfaces.AssociationService,
) *AssociationHandler {
	return &AssociationHandler{
		logger:       l,
		assocService: a,
	}
}

func (h *AssociationHandler) AssociateCharacter(w http.ResponseWriter, r *http.Request) {
	var req struct {
		UserId   string `json:"userId"`
		CharId   string `json:"charId"`
		UserName string `json:"userName"`
		CharName string `json:"charName"`
	}

	if err := decodeJSONBody(r, &req); err != nil {
		respondError(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	h.logger.Infof("%v", req)

	if err := h.assocService.AssociateCharacter(req.UserId, req.CharId); err != nil {
		h.logger.Errorf("%v", err)
		respondJSON(w, map[string]interface{}{"success": false, "message": err.Error()})
		return
	}

	respondJSON(w, map[string]interface{}{
		"success": true,
		"message": fmt.Sprintf("%s associated with %s", req.CharName, req.UserName),
	})
}

func (h *AssociationHandler) UnassociateCharacter(w http.ResponseWriter, r *http.Request) {
	var req struct {
		UserId   string `json:"userId"`
		CharId   string `json:"charId"`
		UserName string `json:"userName"`
		CharName string `json:"charName"`
	}

	if err := decodeJSONBody(r, &req); err != nil {
		respondError(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	if err := h.assocService.UnassociateCharacter(req.UserId, req.CharId); err != nil {
		respondJSON(w, map[string]interface{}{"success": false, "message": err.Error()})
		return
	}

	respondJSON(w, map[string]interface{}{
		"success": true,
		"message": fmt.Sprintf("%s has been unassociated from %s", req.CharName, req.UserName),
	})

}

================
File: internal/handlers/auth.go
================
// handlers/auth_handler.go
package handlers

import (
	"encoding/json"
	"net/http"
	"os"

	flyHttp "github.com/guarzo/canifly/internal/http"
	"github.com/guarzo/canifly/internal/services/interfaces"
)

type AuthHandler struct {
	sessionService interfaces.SessionService
	esiService     interfaces.ESIService
	logger         interfaces.Logger
	accountService interfaces.AccountService
	stateService   interfaces.AppStateService
	loginService   interfaces.LoginService
	authClient     interfaces.AuthClient
}

func NewAuthHandler(
	s interfaces.SessionService,
	e interfaces.ESIService,
	l interfaces.Logger,
	accountSvc interfaces.AccountService,
	stateSvc interfaces.AppStateService,
	login interfaces.LoginService,
	auth interfaces.AuthClient,
) *AuthHandler {
	return &AuthHandler{
		sessionService: s,
		esiService:     e,
		logger:         l,
		accountService: accountSvc,
		stateService:   stateSvc,
		loginService:   login,
		authClient:     auth,
	}
}

func (h *AuthHandler) Login() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Cache-Control", "no-store, no-cache, must-revalidate, proxy-revalidate")
		w.Header().Set("Pragma", "no-cache")
		w.Header().Set("Expires", "0")
		w.Header().Set("Surrogate-Control", "no-store")
		w.Header().Set("Content-Type", "application/json")

		var request struct {
			Account string `json:"account"`
		}

		if err := json.NewDecoder(r.Body).Decode(&request); err != nil {
			h.logger.Errorf("Invalid request body: %v", err)
			respondError(w, "Invalid request body", http.StatusBadRequest)
			return
		}

		if request.Account == "" {
			respondError(w, "account must be provided", http.StatusBadRequest)
			return
		}

		state, err := h.loginService.GenerateAndStoreInitialState(request.Account)
		if err != nil {
			respondError(w, "Unable to generate state", http.StatusInternalServerError)
			return
		}

		url := h.authClient.GetAuthURL(state)
		respondJSON(w, map[string]string{"redirectURL": url, "state": state})
	}
}

func (h *AuthHandler) AddCharacterHandler() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")

		var request struct {
			Account string `json:"account"`
		}

		if err := json.NewDecoder(r.Body).Decode(&request); err != nil {
			h.logger.Errorf("Invalid request body: %v", err)
			respondError(w, "Invalid request body", http.StatusBadRequest)
			return
		}

		if request.Account == "" {
			respondError(w, "Invalid request body - account must be provided", http.StatusBadRequest)
			return
		}

		state, err := h.loginService.GenerateAndStoreInitialState(request.Account)
		if err != nil {
			respondError(w, "Unable to generate state", http.StatusInternalServerError)
			return
		}

		url := h.authClient.GetAuthURL(state)
		respondJSON(w, map[string]string{"redirectURL": url, "state": state})
	}
}

func (h *AuthHandler) CallBack() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		h.logger.Info("callback request received")
		devMode := os.Getenv("DEV_MODE") == "true"

		code := r.URL.Query().Get("code")
		state := r.URL.Query().Get("state")

		accountName, _, ok := h.loginService.ResolveAccountAndStatusByState(state)
		if !ok {
			h.logger.Error("unable to retrieve value from state")
			handleErrorWithRedirect(w, r, "/")
			return
		}

		h.logger.Infof("Received accountName (account name): %v", accountName)

		token, err := h.authClient.ExchangeCode(code)
		if err != nil {
			h.logger.Errorf("Failed to exchange token for code: %s, %v", code, err)
			handleErrorWithRedirect(w, r, "/")
			return
		}

		user, err := h.esiService.GetUserInfo(token)
		if err != nil {
			h.logger.Errorf("Failed to get user info: %v", err)
			handleErrorWithRedirect(w, r, "/")
			return
		}
		h.logger.Warnf("character is %s", user.CharacterName)

		if err := h.stateService.SetAppStateLogin(true); err != nil {
			h.logger.Errorf("Failed to set app state: %v", err)
			handleErrorWithRedirect(w, r, "/")
			return
		}

		// Use AccountService to handle account creation
		if err = h.accountService.FindOrCreateAccount(accountName, user, token); err != nil {
			h.logger.Errorf("%v", err)
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}

		if devMode {
			// In dev, redirect back to dev server so the internal flow works as before
			session, _ := h.sessionService.Get(r, flyHttp.SessionName)
			session.Values[flyHttp.LoggedIn] = true
			if err = session.Save(r, w); err != nil {
				h.logger.Errorf("Error saving session: %v", err)
			}
			http.Redirect(w, r, "http://localhost:5173", http.StatusFound)
		}

		err = h.loginService.UpdateStateStatusAfterCallBack(state)
		if err != nil {
			respondError(w, err.Error(), http.StatusInternalServerError)
		}
		http.Redirect(w, r, "http://localhost:8713/static/success.html", http.StatusFound)

	}
}

func (h *AuthHandler) FinalizeLogin() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		state := r.URL.Query().Get("state")
		_, status, ok := h.loginService.ResolveAccountAndStatusByState(state)
		if !ok {
			h.logger.Error("unable to retrieve value from state")
			respondError(w, "invalid state", http.StatusUnauthorized)
			return
		}
		if !status {
			h.logger.Error("call back not yet completed")
			respondError(w, "call back not yet completed", http.StatusUnauthorized)
			return
		}

		session, _ := h.sessionService.Get(r, flyHttp.SessionName)
		session.Values[flyHttp.LoggedIn] = true
		if err := session.Save(r, w); err != nil {
			respondError(w, "failed to set session", http.StatusInternalServerError)
			return
		}

		//h.loginService.ClearState(state)

		respondJSON(w, map[string]bool{"success": true})
	}
}

func (h *AuthHandler) Logout() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		session, err := h.sessionService.Get(r, flyHttp.SessionName)
		if err != nil {
			respondError(w, "Failed to get session", http.StatusInternalServerError)
			return
		}

		clearSession(h.sessionService, w, r, h.logger)
		if err := session.Save(r, w); err != nil {
			respondError(w, "Failed to save session", http.StatusInternalServerError)
			return
		}
		h.stateService.ClearAppState()

		respondJSON(w, map[string]bool{"success": true})
	}
}

func (h *AuthHandler) ResetAccounts() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		err := h.accountService.DeleteAllAccounts()
		if err != nil {
			h.logger.Errorf("Failed to delete identity %v", err)
		}
		http.Redirect(w, r, "/logout", http.StatusSeeOther)
	}
}

================
File: internal/handlers/character.go
================
package handlers

import (
	"net/http"

	"github.com/guarzo/canifly/internal/services/interfaces"
)

type CharacterHandler struct {
	logger           interfaces.Logger
	characterService interfaces.CharacterService
}

func NewCharacterHandler(
	l interfaces.Logger,
	c interfaces.CharacterService,
) *CharacterHandler {
	return &CharacterHandler{
		logger:           l,
		characterService: c,
	}
}

func (h *CharacterHandler) UpdateCharacter(w http.ResponseWriter, r *http.Request) {
	var request struct {
		CharacterID int64                  `json:"characterID"`
		Updates     map[string]interface{} `json:"updates"`
	}

	if err := decodeJSONBody(r, &request); err != nil {
		respondError(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	if request.CharacterID == 0 || len(request.Updates) == 0 {
		respondError(w, "CharacterID and updates are required", http.StatusBadRequest)
		return
	}

	if err := h.characterService.UpdateCharacterFields(request.CharacterID, request.Updates); err != nil {
		respondError(w, err.Error(), http.StatusInternalServerError)
		return
	}

	respondJSON(w, map[string]bool{"success": true})
}

// RemoveCharacter removes a character via characterService
func (h *CharacterHandler) RemoveCharacter(w http.ResponseWriter, r *http.Request) {
	var request struct {
		CharacterID int64 `json:"characterID"`
	}
	if err := decodeJSONBody(r, &request); err != nil {
		respondError(w, "Invalid request body", http.StatusBadRequest)
		return
	}
	if request.CharacterID == 0 {
		respondError(w, "CharacterID is required", http.StatusBadRequest)
		return
	}

	if err := h.characterService.RemoveCharacter(request.CharacterID); err != nil {
		respondError(w, err.Error(), http.StatusInternalServerError)
		return
	}

	respondJSON(w, map[string]bool{"success": true})
}

================
File: internal/handlers/config.go
================
package handlers

import (
	"fmt"
	"net/http"

	"github.com/guarzo/canifly/internal/model"
	"github.com/guarzo/canifly/internal/services/interfaces"
)

type ConfigHandler struct {
	logger        interfaces.Logger
	configService interfaces.ConfigService
}

func NewConfigHandler(
	l interfaces.Logger,
	s interfaces.ConfigService,
) *ConfigHandler {
	return &ConfigHandler{
		logger:        l,
		configService: s,
	}
}

// SaveUserSelections
func (h *ConfigHandler) SaveUserSelections(w http.ResponseWriter, r *http.Request) {
	var req model.DropDownSelections
	if err := decodeJSONBody(r, &req); err != nil {
		respondError(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	if err := h.configService.SaveUserSelections(req); err != nil {
		respondError(w, fmt.Sprintf("Failed to save user selections: %v", err), http.StatusInternalServerError)
		return
	}

	respondJSON(w, map[string]bool{"success": true})
}

func (h *ConfigHandler) ChooseSettingsDir(w http.ResponseWriter, r *http.Request) {
	var req struct {
		Directory string `json:"directory"`
	}
	h.logger.Infof("in choose settings handler")

	if err := decodeJSONBody(r, &req); err != nil {
		respondError(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	if req.Directory == "" {
		respondError(w, "Directory is required", http.StatusBadRequest)
		return
	}

	if err := h.configService.UpdateSettingsDir(req.Directory); err != nil {
		respondJSON(w, map[string]interface{}{"success": false, "error": err.Error()})
		return
	}

	respondJSON(w, map[string]interface{}{"success": true, "settingsDir": req.Directory})
}

func (h *ConfigHandler) ResetToDefaultDir(w http.ResponseWriter, r *http.Request) {

	h.logger.Infof("in reset to default dir handler")

	if err := h.configService.EnsureSettingsDir(); err != nil {
		respondJSON(w, map[string]interface{}{"success": false, "error": err.Error()})
		return
	}

	respondJSON(w, map[string]interface{}{"success": true})
}

================
File: internal/handlers/dashboard_test.go
================
package handlers_test

import (
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"sync"
	"testing"
	"time"

	"github.com/guarzo/canifly/internal/handlers"
	"github.com/guarzo/canifly/internal/model"
	"github.com/guarzo/canifly/internal/testutil"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

// MockDashboardService is a testify mock for DashboardService
type MockDashboardService struct {
	mock.Mock
	callCount int64
	wg        sync.WaitGroup
}

func (m *MockDashboardService) RefreshAccountsAndState() (model.AppState, error) {
	args := m.Called()
	return args.Get(0).(model.AppState), args.Error(1)
}

func (m *MockDashboardService) RefreshDataInBackground() error {
	defer m.wg.Done() // signal that this call was made
	args := m.Called()
	return args.Error(0)
}

func (m *MockDashboardService) GetCurrentAppState() model.AppState {
	args := m.Called()
	return args.Get(0).(model.AppState)
}

// Helper to set lastRefreshTime in the handler for tests.
func setLastRefreshTimeForTest(h *handlers.DashboardHandler, t time.Time) {
	// Using reflection or a test helper within the same package is cleaner.
	// If handlers package is different, you can either export the field or add a helper method in production code under a test build tag.
	h.SetLastRefreshTimeForTest(t)
}

func TestDashboardHandler_CachedDataWithBackgroundRefresh(t *testing.T) {
	logger := &testutil.MockLogger{}
	sessionSvc := &testutil.MockSessionService{}
	dashboardSvc := &MockDashboardService{}
	dashboardSvc.wg.Add(1) // Expect one background refresh call
	handler := handlers.NewDashboardHandler(sessionSvc, logger, dashboardSvc)

	cachedState := model.AppState{
		AccountData: model.AccountData{
			Accounts: []model.Account{{Name: "TestAcc"}},
		},
	}
	dashboardSvc.On("GetCurrentAppState").Return(cachedState)
	dashboardSvc.On("RefreshDataInBackground").Return(nil).Once()

	req, _ := http.NewRequest("GET", "/dashboard", nil)
	rr := httptest.NewRecorder()
	handler.GetDashboardData().ServeHTTP(rr, req)

	assert.Equal(t, http.StatusOK, rr.Code)
	var resp model.AppState
	assert.NoError(t, json.NewDecoder(rr.Body).Decode(&resp))
	assert.Equal(t, cachedState, resp)

	// Wait for the goroutine to run RefreshDataInBackground
	dashboardSvc.wg.Wait()

	dashboardSvc.AssertExpectations(t)
}

func TestDashboardHandler_CachedDataSkipBackgroundRefresh(t *testing.T) {
	logger := &testutil.MockLogger{}
	sessionSvc := &testutil.MockSessionService{}
	dashboardSvc := &MockDashboardService{}
	handler := handlers.NewDashboardHandler(sessionSvc, logger, dashboardSvc)

	// Set lastRefreshTime to now, so background refresh should be skipped
	setLastRefreshTimeForTest(handler, time.Now())

	cachedState := model.AppState{
		AccountData: model.AccountData{
			Accounts: []model.Account{{Name: "TestAcc2"}},
		},
	}
	dashboardSvc.On("GetCurrentAppState").Return(cachedState)

	req, _ := http.NewRequest("GET", "/dashboard", nil)
	rr := httptest.NewRecorder()
	handler.GetDashboardData().ServeHTTP(rr, req)

	assert.Equal(t, http.StatusOK, rr.Code)
	var resp model.AppState
	assert.NoError(t, json.NewDecoder(rr.Body).Decode(&resp))
	assert.Equal(t, cachedState, resp)

	dashboardSvc.AssertNotCalled(t, "RefreshDataInBackground")
}

func TestDashboardHandler_NoCacheRefresh(t *testing.T) {
	logger := &testutil.MockLogger{}
	sessionSvc := &testutil.MockSessionService{}
	dashboardSvc := &MockDashboardService{}
	handler := handlers.NewDashboardHandler(sessionSvc, logger, dashboardSvc)

	freshState := model.AppState{
		AccountData: model.AccountData{
			Accounts: []model.Account{{Name: "RefreshedAcc"}},
		},
	}
	dashboardSvc.On("GetCurrentAppState").Return(model.AppState{})
	dashboardSvc.On("RefreshAccountsAndState").Return(freshState, nil).Once()

	req, _ := http.NewRequest("GET", "/dashboard/nocache", nil)
	rr := httptest.NewRecorder()
	handler.GetDashboardDataNoCache().ServeHTTP(rr, req)

	assert.Equal(t, http.StatusOK, rr.Code)
	var resp model.AppState
	assert.NoError(t, json.NewDecoder(rr.Body).Decode(&resp))
	assert.Equal(t, freshState, resp)

	dashboardSvc.AssertExpectations(t)
}

func TestDashboardHandler_NoCacheRefreshError(t *testing.T) {
	logger := &testutil.MockLogger{}
	sessionSvc := &testutil.MockSessionService{}
	dashboardSvc := &MockDashboardService{}
	handler := handlers.NewDashboardHandler(sessionSvc, logger, dashboardSvc)

	dashboardSvc.On("GetCurrentAppState").Return(model.AppState{})
	dashboardSvc.On("RefreshAccountsAndState").Return(model.AppState{}, assert.AnError).Once()

	req, _ := http.NewRequest("GET", "/dashboard/nocache", nil)
	rr := httptest.NewRecorder()
	handler.GetDashboardDataNoCache().ServeHTTP(rr, req)

	assert.Equal(t, http.StatusInternalServerError, rr.Code)
	assert.Contains(t, rr.Body.String(), "Failed to validate accounts")

	dashboardSvc.AssertExpectations(t)
}

func TestDashboardHandler_BadJSONResponse(t *testing.T) {
	logger := &testutil.MockLogger{}
	sessionSvc := &testutil.MockSessionService{}
	dashboardSvc := &MockDashboardService{}
	handler := handlers.NewDashboardHandler(sessionSvc, logger, dashboardSvc)

	freshState := model.AppState{
		AccountData: model.AccountData{
			Accounts: []model.Account{{Name: "AccForBadJSON"}},
		},
	}
	dashboardSvc.On("GetCurrentAppState").Return(model.AppState{})
	dashboardSvc.On("RefreshAccountsAndState").Return(freshState, nil).Once()

	req, _ := http.NewRequest("GET", "/dashboard/nocache", nil)

	// Wrap the recorder in a writer that fails only on the first write
	rr := httptest.NewRecorder()
	fw := &failingResponseWriter{ResponseRecorder: rr, failOnce: true}

	handler.GetDashboardDataNoCache().ServeHTTP(fw, req)
	assert.Equal(t, http.StatusInternalServerError, rr.Code)
	// Now we can check the body for the error message, since the second write should succeed
	assert.Contains(t, rr.Body.String(), "Failed to encode data")

	dashboardSvc.AssertExpectations(t)
}

// failingResponseWriter fails only on the first write attempt, then succeeds.
type failingResponseWriter struct {
	*httptest.ResponseRecorder
	failOnce bool
}

func (f *failingResponseWriter) Write(p []byte) (int, error) {
	if f.failOnce {
		f.failOnce = false
		return 0, assert.AnError
	}
	return f.ResponseRecorder.Write(p)
}

================
File: internal/handlers/dashboard.go
================
package handlers

import (
	"net/http"
	"sync/atomic"
	"time"

	"github.com/guarzo/canifly/internal/services/interfaces"
)

type DashboardHandler struct {
	sessionService   interfaces.SessionService
	logger           interfaces.Logger
	dashboardService interfaces.DashboardService
	// lastRefreshTime holds a Unix nano timestamp of the last time a refresh occurred
	lastRefreshTime int64
}

func NewDashboardHandler(
	s interfaces.SessionService,
	logger interfaces.Logger,
	dashboardService interfaces.DashboardService,
) *DashboardHandler {
	return &DashboardHandler{
		sessionService:   s,
		logger:           logger,
		dashboardService: dashboardService,
		// lastRefreshTime is initially 0 indicating never refreshed
	}
}

func (h *DashboardHandler) handleAppStateRefresh(w http.ResponseWriter, noCache bool) {
	appState := h.dashboardService.GetCurrentAppState()

	// If we have cached data, and we are allowed to use it (noCache == false):
	if !noCache && len(appState.AccountData.Accounts) > 0 {
		respondEncodedData(w, appState)

		// Attempt a background refresh if it's been more than 5s since the last refresh
		now := time.Now().UnixNano()
		old := atomic.LoadInt64(&h.lastRefreshTime)
		if now-old > 5*int64(time.Second) {
			// Try to set the last refresh time optimistically. If CAS fails, someone else just did a refresh.
			if atomic.CompareAndSwapInt64(&h.lastRefreshTime, old, now) {
				go func() {
					if err := h.dashboardService.RefreshDataInBackground(); err != nil {
						h.logger.Errorf("background refresh failed: %v", err)
					} else {
						h.logger.Debug("Background refresh completed successfully.")
						// Update lastRefreshTime again after successful refresh.
						atomic.StoreInt64(&h.lastRefreshTime, time.Now().UnixNano())
					}
				}()
			} else {
				h.logger.Debug("Another refresh is already in progress, skipping.")
			}
		} else {
			h.logger.Debugf("Skipping background refresh; only %v since last refresh", time.Duration(now-old))
		}
		return
	}

	// If noCache is true or we have no cached accounts, do a full refresh now (ignoring the last refresh time)
	updatedData, err := h.dashboardService.RefreshAccountsAndState()
	if err != nil {
		h.logger.Errorf("Failed to validate accounts: %v", err)
		respondError(w, "Failed to validate accounts", http.StatusInternalServerError)
		return
	}

	// After a successful noCache (or initial) refresh, update the lastRefreshTime
	atomic.StoreInt64(&h.lastRefreshTime, time.Now().UnixNano())

	//w.Header().Set("Content-Type", "application/json")
	//if err := json.NewEncoder(w).Encode(updatedData); err != nil {
	//	http.Error(w, `{"error":"Failed to encode data"}`, http.StatusInternalServerError)
	//	return
	//}
	respondEncodedData(w, updatedData)
}

func (h *DashboardHandler) GetDashboardData() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		h.logger.Infof("GetAppData Called")
		h.handleAppStateRefresh(w, false)
	}
}

func (h *DashboardHandler) GetDashboardDataNoCache() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		h.logger.Infof("GetAppDataNoCache Called")
		h.handleAppStateRefresh(w, true)
	}
}

// Test helper method
func (h *DashboardHandler) SetLastRefreshTimeForTest(t time.Time) {
	atomic.StoreInt64(&h.lastRefreshTime, t.UnixNano())
}

================
File: internal/handlers/evedata.go
================
package handlers

import (
	"fmt"
	"net/http"

	"github.com/guarzo/canifly/internal/services/interfaces"
)

type EveDataHandler struct {
	logger interfaces.Logger
	eveSvc interfaces.EveProfilesService
}

func NewEveDataHandler(
	l interfaces.Logger,
	s interfaces.EveProfilesService,
) *EveDataHandler {
	return &EveDataHandler{
		logger: l,
		eveSvc: s,
	}
}

// SyncSubDirectory
func (h *EveDataHandler) SyncSubDirectory(w http.ResponseWriter, r *http.Request) {
	var req struct {
		SubDir string `json:"subDir"`
		UserId string `json:"userId"`
		CharId string `json:"charId"`
	}

	if err := decodeJSONBody(r, &req); err != nil {
		respondError(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	userFilesCopied, charFilesCopied, err := h.eveSvc.SyncDir(req.SubDir, req.CharId, req.UserId)
	if err != nil {
		respondJSON(w, map[string]interface{}{"success": false, "message": fmt.Sprintf("failed to sync %v", err)})
		return
	}

	message := fmt.Sprintf("Synchronization complete in \"%s\", %d user files and %d character files copied.",
		req.SubDir, userFilesCopied, charFilesCopied)
	respondJSON(w, map[string]interface{}{"success": true, "message": message})
}

// SyncAllSubdirectories
func (h *EveDataHandler) SyncAllSubdirectories(w http.ResponseWriter, r *http.Request) {
	var req struct {
		SubDir string `json:"subDir"`
		UserId string `json:"userId"`
		CharId string `json:"charId"`
	}

	if err := decodeJSONBody(r, &req); err != nil {
		h.logger.Errorf("Invalid request body for SyncAllSubdirectories: %v", err)
		respondError(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	h.logger.Infof("SyncAllSubdirectories request: Profile=%s, UserId=%s, CharId=%s", req.SubDir, req.UserId, req.CharId)
	userFilesCopied, charFilesCopied, err := h.eveSvc.SyncAllDir(req.SubDir, req.CharId, req.UserId)
	if err != nil {
		h.logger.Errorf("Failed to sync all subdirectories from base %s (UserId=%s, CharId=%s): %v", req.SubDir, req.UserId, req.CharId, err)
		respondJSON(w, map[string]interface{}{"success": false, "message": fmt.Sprintf("failed to sync all: %v", err)})
		return
	}

	message := fmt.Sprintf("Sync completed for all subdirectories: %d user files and %d character files copied, based on user/char files from \"%s\".",
		userFilesCopied, charFilesCopied, req.SubDir)
	h.logger.Infof("SyncAllSubdirectories completed successfully for base %s (UserId=%s, CharId=%s): %s", req.SubDir, req.UserId, req.CharId, message)
	respondJSON(w, map[string]interface{}{"success": true, "message": message})
}

func (h *EveDataHandler) BackupDirectory(w http.ResponseWriter, r *http.Request) {
	var req struct {
		TargetDir string `json:"targetDir"`
		BackupDir string `json:"backupDir"`
	}
	if err := decodeJSONBody(r, &req); err != nil {
		h.logger.Errorf("Invalid request body for BackupDirectory: %v", err)
		respondError(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	h.logger.Infof("Received backup request. TargetDir=%s, BackupDir=%s", req.TargetDir, req.BackupDir)

	if err := h.eveSvc.BackupDir(req.TargetDir, req.BackupDir); err != nil {
		h.logger.Errorf("Failed to backup settings from %s to %s: %v", req.TargetDir, req.BackupDir, err)
		respondError(w, fmt.Sprintf("Failed to backup settings: %v", err), http.StatusInternalServerError)
		return
	}

	message := fmt.Sprintf("Backed up settings to %s", req.BackupDir)
	h.logger.Infof("Backup request successful. %s", message)
	respondJSON(w, map[string]interface{}{"success": true, "message": message})
}

================
File: internal/handlers/skillplan.go
================
package handlers

import (
	"encoding/json"
	"fmt"
	"net/http"
	"os"

	"github.com/guarzo/canifly/internal/services/interfaces"
)

type SkillPlanHandler struct {
	logger       interfaces.Logger
	skillService interfaces.SkillService
}

func NewSkillPlanHandler(l interfaces.Logger, s interfaces.SkillService) *SkillPlanHandler {
	return &SkillPlanHandler{
		logger:       l,
		skillService: s,
	}
}

func (h *SkillPlanHandler) GetSkillPlanFile() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		planName := r.URL.Query().Get("planName")
		if planName == "" {
			respondError(w, "Missing planName parameter", http.StatusBadRequest)
			return
		}

		content, err := h.skillService.GetSkillPlanFile(planName)
		if err != nil {
			if os.IsNotExist(err) {
				respondError(w, fmt.Sprintf("skill plan %s not found", planName), http.StatusNotFound)
			} else {
				respondError(w, fmt.Sprintf("Failed to read skill plan file %s: %v", planName, err), http.StatusInternalServerError)

			}
			return
		}

		respondEncodedData(w, content)
	}
}

func (h *SkillPlanHandler) SaveSkillPlan() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var requestData struct {
			PlanName string `json:"name"`
			Contents string `json:"contents"`
		}
		if err := json.NewDecoder(r.Body).Decode(&requestData); err != nil {
			h.logger.Errorf("Failed to parse JSON body: %v", err)
			respondError(w, "Invalid request", http.StatusBadRequest)
			return
		}

		if requestData.PlanName == "" {
			h.logger.Error("planName parameter missing")
			respondError(w, "Missing planName", http.StatusBadRequest)
			return
		}

		if h.skillService.CheckIfDuplicatePlan(requestData.PlanName) {
			h.logger.Errorf("duplicate plan name %s", requestData.PlanName)
			respondError(w, fmt.Sprintf("%s is already used as a plan name", requestData.PlanName), http.StatusBadRequest)
			return
		}

		if err := h.skillService.ParseAndSaveSkillPlan(requestData.Contents, requestData.PlanName); err != nil {
			h.logger.Errorf("Failed to save eve plan: %v", err)
			respondError(w, "Failed to save eve plan", http.StatusInternalServerError)
			return
		}

		respondJSON(w, map[string]bool{"success": true})
	}
}

func (h *SkillPlanHandler) DeleteSkillPlan() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodDelete {
			respondError(w, "Method not allowed", http.StatusMethodNotAllowed)
			return
		}

		planName := r.URL.Query().Get("planName")
		if planName == "" {
			h.logger.Error("planName parameter missing")
			respondError(w, "Missing planName parameter", http.StatusBadRequest)
			return
		}

		if err := h.skillService.DeleteSkillPlan(planName); err != nil {
			h.logger.Errorf("Failed to delete eve plan: %v", err)
			respondError(w, "Failed to delete eve plan", http.StatusInternalServerError)
			return
		}

		respondJSON(w, map[string]bool{"success": true})
	}
}

================
File: internal/handlers/utils.go
================
// handlers/crypto.go
package handlers

import (
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/gorilla/sessions"

	flyHttp "github.com/guarzo/canifly/internal/http"
	"github.com/guarzo/canifly/internal/services/interfaces"
)

// respondJSON sends a success response with JSON-encoded data.
func respondJSON(w http.ResponseWriter, data interface{}) {
	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(data); err != nil {
		respondError(w, "Failed to encode data", http.StatusInternalServerError)
	}
}

func respondEncodedData(w http.ResponseWriter, data interface{}) {
	encodedData, err := json.Marshal(data)
	if err != nil {
		respondError(w, "Failed to encode data", http.StatusInternalServerError)
		return
	}

	respondJSON(w, json.RawMessage(encodedData))
}

// respondError sends an error response in JSON format.
func respondError(w http.ResponseWriter, msg string, code int) {
	http.Error(w, fmt.Sprintf(`{"error":"%s"}`, msg), code)
}

// decodeJSONBody decodes the JSON body into the provided dst.
func decodeJSONBody(r *http.Request, dst interface{}) error {
	return json.NewDecoder(r.Body).Decode(dst)
}

func clearSession(s interfaces.SessionService, w http.ResponseWriter, r *http.Request, logger interfaces.Logger) {
	session, err := s.Get(r, flyHttp.SessionName)
	if err != nil {
		logger.Errorf("Failed to get session to clear: %v", err)
	}

	session.Values = make(map[interface{}]interface{})

	err = sessions.Save(r, w)
	if err != nil {
		logger.Errorf("Failed to save session to clear: %v", err)
	}
}
func handleErrorWithRedirect(w http.ResponseWriter, r *http.Request, redirectURL string) {
	http.Redirect(w, r, redirectURL, http.StatusSeeOther)
}

================
File: internal/http/esi_http_client_test.go
================
package http_test

import (
	"encoding/json"
	"errors"
	"io"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"golang.org/x/oauth2"

	flyErrors "github.com/guarzo/canifly/internal/errors"
	flyHttp "github.com/guarzo/canifly/internal/http"
	"github.com/guarzo/canifly/internal/testutil"
)

func TestAPIClient_GetJSON_SuccessNoCache(t *testing.T) {
	// Setup a test server that returns a simple JSON response
	responseData := map[string]string{"hello": "world"}
	handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		data, _ := json.Marshal(responseData)
		w.Write(data)
	})

	ts := httptest.NewServer(handler)
	defer ts.Close()

	logger := &testutil.MockLogger{}
	authClient := &testutil.MockAuthClient{}
	cache := &testutil.MockCacheService{}

	client := flyHttp.NewEsiHttpClient(ts.URL, logger, authClient, cache)

	var result map[string]string
	err := client.GetJSON("/", nil, false, &result)
	require.NoError(t, err)
	assert.Equal(t, "world", result["hello"])
}

func TestAPIClient_GetJSON_UsesCache(t *testing.T) {
	logger := &testutil.MockLogger{}
	authClient := &testutil.MockAuthClient{}
	cache := &testutil.MockCacheService{}

	cachedResponse := map[string]string{"cached": "value"}
	cachedBytes, _ := json.Marshal(cachedResponse)

	// Mock the cache "Get" call to return the cached data
	cache.On("Get", "http://example.com/data").Return(cachedBytes, true)

	client := flyHttp.NewEsiHttpClient("http://example.com", logger, authClient, cache)
	var result map[string]string

	err := client.GetJSON("/data", nil, true, &result)
	require.NoError(t, err)
	assert.Equal(t, "value", result["cached"], "Should use cached data")

	cache.AssertExpectations(t)
	authClient.AssertExpectations(t)
}

func TestAPIClient_GetJSON_TokenRefreshOnUnauthorized(t *testing.T) {
	callCount := 0
	handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		callCount++
		if callCount == 1 {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		resp := map[string]string{"refreshed": "true"}
		data, _ := json.Marshal(resp)
		w.Write(data)
	})

	ts := httptest.NewServer(handler)
	defer ts.Close()

	logger := &testutil.MockLogger{}
	authClient := &testutil.MockAuthClient{}
	cache := &testutil.MockCacheService{}

	// Mock RefreshToken call, which is expected when a 401 is received
	authClient.On("RefreshToken", "refresh-token").
		Return(&oauth2.Token{AccessToken: "new-access-token"}, nil).
		Once()

	client := flyHttp.NewEsiHttpClient(ts.URL, logger, authClient, cache)

	token := &oauth2.Token{
		AccessToken:  "old-access-token",
		RefreshToken: "refresh-token",
	}

	var result map[string]string
	err := client.GetJSON("/", token, false, &result)
	require.NoError(t, err)
	assert.Equal(t, "true", result["refreshed"])

	cache.AssertExpectations(t)
	authClient.AssertExpectations(t)
}

func TestAPIClient_GetJSON_RetryOnServiceUnavailable(t *testing.T) {
	// Setup a server that returns 503 for the first two requests, then succeeds
	callCount := 0
	handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		callCount++
		if callCount <= 2 {
			w.WriteHeader(http.StatusServiceUnavailable)
			return
		}
		resp := map[string]string{"status": "ok"}
		data, _ := json.Marshal(resp)
		w.Write(data)
	})

	ts := httptest.NewServer(handler)
	defer ts.Close()

	logger := &testutil.MockLogger{}
	authClient := &testutil.MockAuthClient{}
	cache := &testutil.MockCacheService{}

	client := flyHttp.NewEsiHttpClient(ts.URL, logger, authClient, cache)

	var result map[string]string
	err := client.GetJSON("/", nil, false, &result)
	require.NoError(t, err)
	assert.Equal(t, 3, callCount, "should have retried twice and succeeded on the third call")
	assert.Equal(t, "ok", result["status"])
}

func TestAPIClient_GetJSON_FailsAfterMaxRetries(t *testing.T) {
	// Setup a server that always returns 503
	handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusServiceUnavailable)
	})

	ts := httptest.NewServer(handler)
	defer ts.Close()

	logger := &testutil.MockLogger{}
	authClient := &testutil.MockAuthClient{}
	cache := &testutil.MockCacheService{}

	client := flyHttp.NewEsiHttpClient(ts.URL, logger, authClient, cache)

	var result map[string]string
	err := client.GetJSON("/", nil, false, &result)
	require.Error(t, err)

	var cErr *flyErrors.CustomError
	assert.True(t, errors.As(err, &cErr))
	assert.Equal(t, http.StatusServiceUnavailable, cErr.StatusCode, "should return the final error from server")
}

func TestAPIClient_GetJSON_NoToken_NoAuthHeaders(t *testing.T) {
	// Test to ensure no authorization header is sent if no token is provided
	handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		authHeader := r.Header.Get("Authorization")
		if authHeader != "" {
			w.WriteHeader(http.StatusBadRequest) // We expected no auth header
			return
		}
		w.WriteHeader(http.StatusOK)
		io.WriteString(w, `{"success": true}`)
	})

	ts := httptest.NewServer(handler)
	defer ts.Close()

	logger := &testutil.MockLogger{}
	authClient := &testutil.MockAuthClient{}
	cache := &testutil.MockCacheService{}

	client := flyHttp.NewEsiHttpClient(ts.URL, logger, authClient, cache)

	var result map[string]bool
	err := client.GetJSON("/", nil, false, &result)
	require.NoError(t, err)
	assert.True(t, result["success"])
}

================
File: internal/http/esi_http_client.go
================
// internal/services/http/api_client.go
package http

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"math/rand"
	"net/http"
	"time"

	"golang.org/x/oauth2"

	flyErrors "github.com/guarzo/canifly/internal/errors"
	"github.com/guarzo/canifly/internal/persist/eve"
	"github.com/guarzo/canifly/internal/services/interfaces"
)

const (
	maxRetries = 5
	baseDelay  = 1 * time.Second
	maxDelay   = 32 * time.Second
)

var _ interfaces.EsiHttpClient = (*EsiHttpClient)(nil)

type EsiHttpClient struct {
	BaseURL      string
	HTTPClient   *http.Client
	Logger       interfaces.Logger
	AuthClient   interfaces.AuthClient
	CacheService interfaces.CacheService
}

// NewEsiHttpClient initializes and returns an EsiHttpClient instance
func NewEsiHttpClient(baseURL string, logger interfaces.Logger, auth interfaces.AuthClient, cache interfaces.CacheService) *EsiHttpClient {
	return &EsiHttpClient{
		BaseURL: baseURL,
		HTTPClient: &http.Client{
			Timeout: 10 * time.Second,
		},
		Logger:       logger,
		AuthClient:   auth,
		CacheService: cache,
	}
}

// GetJSON retrieves JSON data from the specified endpoint. It supports optional caching and token usage.
// If `useCache` is true, it will attempt to return cached data before making a request.
// If a token is provided, it will include it in the request and attempt token refresh if Unauthorized.
func (c *EsiHttpClient) GetJSON(endpoint string, token *oauth2.Token, useCache bool, target interface{}) error {
	url := fmt.Sprintf("%s%s", c.BaseURL, endpoint)
	return c.GetJSONFromURL(url, token, useCache, target)
}

func (c *EsiHttpClient) GetJSONFromURL(url string, token *oauth2.Token, useCache bool, target interface{}) error {
	// Check cache first
	if useCache && c.CacheService != nil {
		if cachedData, found := c.CacheService.Get(url); found {
			c.Logger.Debugf("using cached data for %s", url)
			return json.Unmarshal(cachedData, target)
		} else {
			c.Logger.Debugf("no cached data found for %s", url)
		}
	}

	// Define the operation for retry
	operation := func() ([]byte, error) {
		return c.doRequestWithToken("GET", url, nil, token)
	}

	bodyBytes, err := c.retryWithExponentialBackoff(operation)
	if err != nil {
		return err
	}

	// Cache the response if needed
	if useCache && c.CacheService != nil {
		c.CacheService.Set(url, bodyBytes, eve.DefaultExpiration)
	}

	return json.Unmarshal(bodyBytes, target)
}

// doRequestWithToken performs a request and handles token refresh if necessary.
func (c *EsiHttpClient) doRequestWithToken(method, url string, body interface{}, token *oauth2.Token) ([]byte, error) {
	var reqBody io.Reader
	if body != nil {
		jsonData, err := json.Marshal(body)
		if err != nil {
			c.Logger.WithError(err).Error("Failed to serialize request body")
			return nil, fmt.Errorf("failed to serialize request body: %w", err)
		}
		reqBody = bytes.NewReader(jsonData)
	}

	req, err := http.NewRequest(method, url, reqBody)
	if err != nil {
		c.Logger.WithError(err).Error("Failed to create request")
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	req.Header.Set("Content-Type", "application/json")
	if token != nil && token.AccessToken != "" {
		req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", token.AccessToken))
	}

	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		c.Logger.WithError(err).Error("Failed to execute request")
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	if (resp.StatusCode == http.StatusUnauthorized || resp.StatusCode == http.StatusForbidden) && token != nil && token.RefreshToken != "" {
		// Attempt token refresh
		newToken, refreshErr := c.AuthClient.RefreshToken(token.RefreshToken)
		if refreshErr != nil {
			return nil, fmt.Errorf("failed to refresh token: %w", refreshErr)
		}
		token.AccessToken = newToken.AccessToken
		// Retry once with the new token
		return c.doRequestWithToken(method, url, body, token)
	}

	if resp.StatusCode < 200 || resp.StatusCode > 299 {
		body, _ := io.ReadAll(resp.Body)
		c.Logger.WithFields(map[string]interface{}{
			"status_code": resp.StatusCode,
			"response":    string(body),
		}).Error("Received non-2xx response")

		return nil, flyErrors.NewCustomError(resp.StatusCode, fmt.Sprintf("unexpected status code: %d, response: %s", resp.StatusCode, body))
	}

	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		c.Logger.WithError(err).Error("Failed to read response body")
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	return respBody, nil
}

// retryWithExponentialBackoff attempts the given operation multiple times with exponential backoff on certain HTTP errors.
func (c *EsiHttpClient) retryWithExponentialBackoff(operation func() ([]byte, error)) ([]byte, error) {
	delay := baseDelay
	for i := 0; i < maxRetries; i++ {
		result, err := operation()
		if err == nil {
			return result, nil
		}

		var customErr *flyErrors.CustomError
		if !shouldRetry(err, &customErr) {
			return nil, err
		}

		// If we're at the last attempt, don't retry
		if i == maxRetries-1 {
			return nil, err
		}

		jitter := time.Duration(rand.Int63n(int64(delay)))
		time.Sleep(delay + jitter)

		delay *= 2
		if delay > maxDelay {
			delay = maxDelay
		}
	}

	return nil, fmt.Errorf("exceeded maximum retries")
}

// shouldRetry checks if the error status code warrants a retry.
func shouldRetry(err error, customErr **flyErrors.CustomError) bool {
	if errors.As(err, customErr) {
		switch (*customErr).StatusCode {
		case http.StatusServiceUnavailable, http.StatusGatewayTimeout, http.StatusInternalServerError:
			return true
		}
	}
	return false
}

================
File: internal/http/middleware_test.go
================
package http_test

import (
	"encoding/json"
	"errors"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/gorilla/mux"
	"github.com/gorilla/sessions"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	flyHttp "github.com/guarzo/canifly/internal/http"
	"github.com/guarzo/canifly/internal/services/interfaces"
	"github.com/guarzo/canifly/internal/testutil"
)

const (
	SessionName = "testSession"
	LoggedIn    = "logged_in"
)

// createTestRouter creates a router with the AuthMiddleware applied and test handlers.
func createTestRouter(sessionService interfaces.SessionService, logger interfaces.Logger) *mux.Router {
	r := mux.NewRouter()
	r.Use(flyHttp.AuthMiddleware(sessionService, logger))

	// Public routes
	r.HandleFunc("/static", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		json.NewEncoder(w).Encode(map[string]string{"status": "public ok"})
	})
	r.HandleFunc("/landing", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		json.NewEncoder(w).Encode(map[string]string{"status": "landing ok"})
	})

	// Private routes
	r.HandleFunc("/private", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		json.NewEncoder(w).Encode(map[string]string{"status": "private ok"})
	})

	return r
}

func TestAuthMiddleware_PublicRoute(t *testing.T) {
	sessionService := &testutil.MockSessionService{Store: sessions.NewCookieStore([]byte("secret"))}
	logger := &testutil.MockLogger{}

	router := createTestRouter(sessionService, logger)

	req, _ := http.NewRequest("GET", "/static", nil)
	rr := httptest.NewRecorder()
	router.ServeHTTP(rr, req)

	assert.Equal(t, http.StatusOK, rr.Code)
	var resp map[string]string
	require.NoError(t, json.Unmarshal(rr.Body.Bytes(), &resp))
	assert.Equal(t, "public ok", resp["status"])
}

func TestAuthMiddleware_PublicRoute_Landing(t *testing.T) {
	sessionService := &testutil.MockSessionService{Store: sessions.NewCookieStore([]byte("secret"))}
	logger := &testutil.MockLogger{}

	router := createTestRouter(sessionService, logger)

	req, _ := http.NewRequest("GET", "/landing", nil)
	rr := httptest.NewRecorder()
	router.ServeHTTP(rr, req)

	assert.Equal(t, http.StatusOK, rr.Code)
	var resp map[string]string
	require.NoError(t, json.Unmarshal(rr.Body.Bytes(), &resp))
	assert.Equal(t, "landing ok", resp["status"])
}

func TestAuthMiddleware_PrivateRoute_NotLoggedIn(t *testing.T) {
	sessionService := &testutil.MockSessionService{Store: sessions.NewCookieStore([]byte("secret"))}
	logger := &testutil.MockLogger{}

	router := createTestRouter(sessionService, logger)

	req, _ := http.NewRequest("GET", "/private", nil)
	rr := httptest.NewRecorder()
	router.ServeHTTP(rr, req)

	assert.Equal(t, http.StatusUnauthorized, rr.Code)
	var resp map[string]string
	require.NoError(t, json.Unmarshal(rr.Body.Bytes(), &resp))
	assert.Equal(t, "user is not logged in", resp["error"])
}

func TestAuthMiddleware_PrivateRoute_SessionError(t *testing.T) {
	sessionService := &testutil.MockSessionService{
		Err: errors.New("session retrieval error"),
	}
	logger := &testutil.MockLogger{}

	router := createTestRouter(sessionService, logger)

	req, _ := http.NewRequest("GET", "/private", nil)
	rr := httptest.NewRecorder()
	router.ServeHTTP(rr, req)

	assert.Equal(t, http.StatusInternalServerError, rr.Code)
	var resp map[string]string
	require.NoError(t, json.Unmarshal(rr.Body.Bytes(), &resp))
	assert.Equal(t, "failed to retrieve session", resp["error"])
}

func TestAuthMiddleware_PrivateRoute_LoggedIn(t *testing.T) {
	sessionService := &testutil.MockSessionService{
		Store:    sessions.NewCookieStore([]byte("secret")),
		LoggedIn: true,
	}
	logger := &testutil.MockLogger{}

	router := createTestRouter(sessionService, logger)

	req, _ := http.NewRequest("GET", "/private", nil)
	rr := httptest.NewRecorder()
	router.ServeHTTP(rr, req)

	assert.Equal(t, http.StatusOK, rr.Code, "Should be authenticated")
	var resp map[string]string
	require.NoError(t, json.Unmarshal(rr.Body.Bytes(), &resp))
	assert.Equal(t, "private ok", resp["status"])
}

================
File: internal/http/middleware.go
================
// http/middleware.go
package http

import (
	"net/http"
	"strings"

	"github.com/gorilla/mux"
	"github.com/sirupsen/logrus"

	"github.com/guarzo/canifly/internal/services/interfaces"
)

func AuthMiddleware(s interfaces.SessionService, logger interfaces.Logger) mux.MiddlewareFunc {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			logger.Info(r.URL.Path)
			// Define public routes that don't require authentication
			publicRoutes := map[string]bool{
				"/static":             true,
				"/landing":            true,
				"/api/login":          true,
				"/api/logout":         true,
				"/callback":           true,
				"/api/add-character":  true,
				"/api/finalize-login": true,
			}

			// Allow access if the request matches a public route
			for publicRoute := range publicRoutes {
				if strings.HasPrefix(r.URL.Path, publicRoute) {
					logger.WithFields(logrus.Fields{
						"path":   r.URL.Path,
						"public": true,
					}).Debug("Public route accessed")
					next.ServeHTTP(w, r)
					return
				}
			}

			logger.WithField("path", r.URL.Path).Debug("Authentication required for private route")

			// Retrieve the session
			session, err := s.Get(r, SessionName)
			if err != nil {
				logger.WithError(err).Error("Failed to retrieve session")
				http.Error(w, `{"error":"failed to retrieve session"}`, http.StatusInternalServerError)
				return
			}

			loggedIn, ok := session.Values[LoggedIn].(bool)
			if !ok || !loggedIn {
				logger.Warn("Unauthenticated access attempt")
				http.Error(w, `{"error":"user is not logged in"}`, http.StatusUnauthorized)
				return
			}

			logger.WithFields(logrus.Fields{
				"path": r.URL.Path,
			}).Debug("User authenticated")

			// Proceed to the next handler
			next.ServeHTTP(w, r)
		})
	}
}

================
File: internal/http/session.go
================
// Package http - http/session.go
package http

import (
	"github.com/guarzo/canifly/internal/services/interfaces"
	"net/http"

	"github.com/gorilla/sessions"
)

const (
	SessionName = "session"
	LoggedIn    = "logged_in"
)

type sessionService struct {
	store *sessions.CookieStore
}

func NewSessionService(secret string) interfaces.SessionService {
	return &sessionService{
		store: sessions.NewCookieStore([]byte(secret)),
	}
}

func (s *sessionService) Get(r *http.Request, name string) (*sessions.Session, error) {
	return s.store.Get(r, name)
}

================
File: internal/model/account.go
================
// model/account.go
package model

import (
	"time"

	"golang.org/x/oauth2"
)

type AccountStatus string

const (
	Alpha AccountStatus = "Alpha"
	Omega AccountStatus = "Omega"
)

type Account struct {
	Name       string
	Status     AccountStatus
	Characters []CharacterIdentity
	ID         int64 // userFile ID for this account, defaults to 0 until assigned
	Visible    bool  // toggle visibility
}

type AccountData struct {
	Accounts     []Account
	Associations []Association // in app assigned connections between user and char files (effectively connecting characters to accounts)
}

// Association are the user connections between char and user files (userID does correspond to accountId)
type Association struct {
	UserId   string `json:"userId"`
	CharId   string `json:"charId"`
	CharName string `json:"charName"`
}

type CharacterIdentity struct {
	Token           oauth2.Token
	Character       Character
	CorporationName string
	AllianceName    string
	Role            string
	MCT             bool
	Training        string
}

type Character struct {
	UserInfoResponse
	CharacterSkillsResponse `json:"CharacterSkillsResponse"`
	Location                int64  `json:"Location"`
	LocationName            string `json:"LocationName"`

	SkillQueue         []SkillQueue                `json:"SkillQueue"`
	QualifiedPlans     map[string]bool             `json:"QualifiedPlans"`
	PendingPlans       map[string]bool             `json:"PendingPlans"`
	PendingFinishDates map[string]*time.Time       `json:"PendingFinishDates"`
	MissingSkills      map[string]map[string]int32 `json:"MissingSkills"`
}

// UserInfoResponse represents the user information returned by the EVE SSO
type UserInfoResponse struct {
	CharacterID   int64  `json:"CharacterID"`
	CharacterName string `json:"CharacterName"`
}

type CharacterResponse struct {
	AllianceID     int32     `json:"alliance_id,omitempty"`
	Birthday       time.Time `json:"birthday"`
	BloodlineID    int32     `json:"bloodline_id"`
	CorporationID  int32     `json:"corporation_id"`
	Description    string    `json:"description,omitempty"`
	FactionID      int32     `json:"faction_id,omitempty"`
	Gender         string    `json:"gender"`
	Name           string    `json:"name"`
	RaceID         int32     `json:"race_id"`
	SecurityStatus float64   `json:"security_status,omitempty"`
	Title          string    `json:"title,omitempty"`
}

type CharacterSkillsResponse struct {
	Skills        []SkillResponse `json:"skills"`
	TotalSP       int64           `json:"total_sp"`
	UnallocatedSP int32           `json:"unallocated_sp"`
}

type AuthStatus struct {
	AccountName      string `json:"accountName"`
	CallBackComplete bool   `json:"callBackComplete"`
}

// Alliance contains detailed information about an EVE Online alliance
type Alliance struct {
	CreatorCorporationID  int       `json:"creator_corporation_id"`
	CreatorID             int       `json:"creator_id"`
	DateFounded           time.Time `json:"date_founded"`
	ExecutorCorporationID int       `json:"executor_corporation_id"`
	Name                  string    `json:"name"`
	Ticker                string    `json:"ticker"`
}

// Corporation represents detailed information about an EVE Online corporation
type Corporation struct {
	AllianceID    int       `json:"alliance_id"`
	CeoID         int       `json:"ceo_id"`
	CreatorID     int       `json:"creator_id"`
	DateFounded   time.Time `json:"date_founded"`
	Description   string    `json:"description"`
	HomeStationID int       `json:"home_station_id"`
	MemberCount   int       `json:"member_count"`
	Name          string    `json:"name"`
	Shares        int       `json:"shares"`
	TaxRate       float64   `json:"tax_rate"`
	Ticker        string    `json:"ticker"`
	URL           string    `json:"url"`
}

================
File: internal/model/config.go
================
// model/config.go
package model

import (
	"encoding/gob"
	"time"
)

// AppState is the data passed to the UI
type AppState struct {
	LoggedIn    bool        `json:"LoggedIn"`
	AccountData AccountData `json:"AccountData"`
	ConfigData  ConfigData  `json:"ConfigData"`
	EveData     EveData     `json:"EveData"`
}

// DropDownSelections  are the dropdown selections on the sync page
type DropDownSelections map[string]UserSelection

type UserSelection struct {
	CharId string `json:"charId"`
	UserId string `json:"userId"`
}

// ConfigData are user settings and other app specific configuration
type ConfigData struct {
	Roles              []string `json:"Roles"`         // in app created roles for organizing data
	SettingsDir        string   `json:"SettingsDir"`   // directory where the settings are kept
	LastBackupDir      string   `json:"LastBackupDir"` // directory used for the previous backup
	DropDownSelections          // dropdown selections within the app
}

func init() {
	gob.Register(CharacterIdentity{})
	gob.Register([]CharacterIdentity{})
	gob.Register([]Account{})
	gob.Register(Account{})
	gob.Register(Character{})
	gob.Register(UserInfoResponse{})
	gob.Register(CharacterSkillsResponse{})
	gob.Register(map[string]bool{})
	gob.Register(map[string]*time.Time{})
	gob.Register(map[string]map[string]int32{})
	gob.Register([]SkillQueue{})
	gob.Register(AppState{})
	gob.Register(AccountData{})
	gob.Register(EveData{})
	gob.Register(EveProfile{})
	gob.Register(ConfigData{})
	gob.Register(DropDownSelections{})
	gob.Register([]EveProfile{})
	gob.Register([]Association{})
	gob.Register(Association{})

}

================
File: internal/model/eve.go
================
// model/eve.go

package model

import (
	"time"
)

type EveData struct {
	EveProfiles    []EveProfile
	SkillPlans     map[string]SkillPlanWithStatus
	EveConversions map[string]string // converts skill id to skill name
}

// EveProfile is the data from the eve settings
type EveProfile struct {
	Profile            string     `json:"profile"`            // eve profile name
	AvailableCharFiles []CharFile `json:"availableCharFiles"` // character files for a given profile
	AvailableUserFiles []UserFile `json:"availableUserFiles"` // user files for a given profile
}

// RawFileInfo represents basic information extracted from an EVE settings file.
type RawFileInfo struct {
	FileName     string
	CharOrUserID string
	IsChar       bool // true if char file, false if user file
	Mtime        string
}

type Station struct {
	SystemID int64  `json:"system_id"`
	ID       int64  `json:"station_id"`
	Name     string `json:"station_name"`
}

type Structure struct {
	Name     string `json:"name"`
	OwnerID  int64  `json:"owner_id"`
	SystemID int64  `json:"solar_system_id"`
	TypeID   int64  `json:"type_id"`
}

type CharacterLocation struct {
	SolarSystemID int64 `json:"solar_system_id"`
	StructureID   int64 `json:"structure_id"`
}

type CloneLocation struct {
	HomeLocation struct {
		LocationID   int64  `json:"location_id"`
		LocationType string `json:"location_type"`
	} `json:"home_location"`
	JumpClones []struct {
		Implants     []int  `json:"implants"`
		JumpCloneID  int64  `json:"jump_clone_id"`
		LocationID   int64  `json:"location_id"`
		LocationType string `json:"location_type"`
	} `json:"jump_clones"`
}

// SkillPlanWithStatus holds detailed information about each eve plan
type SkillPlanWithStatus struct {
	Name                string
	TypeId              int64 // used for image lookup
	Skills              map[string]Skill
	QualifiedCharacters []string
	PendingCharacters   []string
	MissingSkills       map[string]map[string]int32 // Missing skills by character
	Characters          []CharacterSkillPlanStatus  // List of characters with their status for this eve plan
}

// CharacterSkillPlanStatus represents a character's status for a specific eve plan
type CharacterSkillPlanStatus struct {
	CharacterName     string
	Status            string // "qualified", "pending", "missing"
	MissingSkills     map[string]int32
	PendingFinishDate *time.Time
}

type SkillResponse struct {
	ActiveSkillLevel   int32 `json:"active_skill_level"`
	SkillID            int32 `json:"skill_id"`
	SkillpointsInSkill int64 `json:"skillpoints_in_skill"`
	TrainedSkillLevel  int32 `json:"trained_skill_level"`
}

type SkillQueue struct {
	FinishDate      *time.Time `json:"finish_date,omitempty"`
	FinishedLevel   int32      `json:"finished_level"`
	LevelEndSP      int32      `json:"level_end_sp"`
	LevelStartSP    int32      `json:"level_start_sp"`
	QueuePosition   int32      `json:"queue_position"`
	SkillID         int32      `json:"skill_id"`
	StartDate       *time.Time `json:"start_date,omitempty"`
	TrainingStartSP int32      `json:"training_start_sp"`
}

// Skill represents a eve with a name and level.
type Skill struct {
	Name  string `json:"Name"`
	Level int    `json:"Level"`
}

// SkillPlan represents a eve plan, with the plan name and a map of unique skills.
type SkillPlan struct {
	Name                string           `json:"Name"`
	Skills              map[string]Skill `json:"Skills"`
	QualifiedCharacters []string         `json:"QualifiedCharacters"`
	PendingCharacters   []string         `json:"PendingCharacters"`
}

// SkillType represents a eve with typeID, typeName, and description.
type SkillType struct {
	TypeID      string
	TypeName    string
	Description string
}

type CharFile struct {
	File   string `json:"file"`
	CharId string `json:"charId"`
	Name   string `json:"name"`
	Mtime  string `json:"mtime"`
}

type UserFile struct {
	File   string `json:"file"`
	UserId string `json:"userId"`
	Name   string `json:"name"`
	Mtime  string `json:"mtime"`
}

================
File: internal/persist/account/account_store_test.go
================
package account_test

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/guarzo/canifly/internal/model"
	"github.com/guarzo/canifly/internal/persist"
	"github.com/guarzo/canifly/internal/persist/account"
	"github.com/guarzo/canifly/internal/services/interfaces"
	"github.com/stretchr/testify/assert"
)

// MockLogger that does nothing.
type MockLogger struct{}

func (m *MockLogger) Debug(args ...interface{})                                  {}
func (m *MockLogger) Debugf(format string, args ...interface{})                  {}
func (m *MockLogger) Info(args ...interface{})                                   {}
func (m *MockLogger) Infof(format string, args ...interface{})                   {}
func (m *MockLogger) Warn(args ...interface{})                                   {}
func (m *MockLogger) Warnf(format string, args ...interface{})                   {}
func (m *MockLogger) Error(args ...interface{})                                  {}
func (m *MockLogger) Errorf(format string, args ...interface{})                  {}
func (m *MockLogger) Fatal(args ...interface{})                                  {}
func (m *MockLogger) Fatalf(format string, args ...interface{})                  {}
func (m *MockLogger) WithError(err error) interfaces.Logger                      { return m }
func (m *MockLogger) WithField(key string, value interface{}) interfaces.Logger  { return m }
func (m *MockLogger) WithFields(fields map[string]interface{}) interfaces.Logger { return m }

func TestAccountDataStore_EmptyOnStart(t *testing.T) {
	logger := &MockLogger{}
	basePath := t.TempDir()
	fs := persist.OSFileSystem{}

	store := account.NewAccountDataStore(logger, fs, basePath)

	// Initially, no file exists, FetchAccountData should return empty data
	ad, err := store.FetchAccountData()
	assert.NoError(t, err)
	assert.Empty(t, ad.Accounts)
	assert.Empty(t, ad.Associations)

	// Similarly, FetchAccounts should return empty slice
	accounts, err := store.FetchAccounts()
	assert.NoError(t, err)
	assert.Empty(t, accounts)
}

func TestAccountDataStore_SaveAndFetch(t *testing.T) {
	logger := &MockLogger{}
	basePath := t.TempDir()
	fs := persist.OSFileSystem{}

	store := account.NewAccountDataStore(logger, fs, basePath)

	// Create some account data
	ad := model.AccountData{
		Accounts: []model.Account{
			{
				Name:       "TestAccount",
				Status:     "Alpha",
				Characters: []model.CharacterIdentity{},
				ID:         12345,
			},
		},
		Associations: []model.Association{
			{
				UserId:   "100",
				CharId:   "200",
				CharName: "TestChar",
			},
		},
	}

	// SaveAccountData
	err := store.SaveAccountData(ad)
	assert.NoError(t, err)

	// FetchAccountData and verify
	fetchedAd, err := store.FetchAccountData()
	assert.NoError(t, err)
	assert.Equal(t, ad, fetchedAd)

	// Test FetchAccounts convenience method
	accounts, err := store.FetchAccounts()
	assert.NoError(t, err)
	assert.Len(t, accounts, 1)
	assert.Equal(t, "TestAccount", accounts[0].Name)
}

func TestAccountDataStore_SaveAccounts(t *testing.T) {
	logger := &MockLogger{}
	basePath := t.TempDir()
	fs := persist.OSFileSystem{}

	store := account.NewAccountDataStore(logger, fs, basePath)

	// Save some initial data
	err := store.SaveAccountData(model.AccountData{
		Accounts: []model.Account{
			{Name: "Acc1"},
		},
	})
	assert.NoError(t, err)

	// Now use SaveAccounts to overwrite just the Accounts
	newAccounts := []model.Account{
		{Name: "Acc2", ID: 999},
	}
	err = store.SaveAccounts(newAccounts)
	assert.NoError(t, err)

	// Verify that Accounts changed and Associations stayed empty
	ad, err := store.FetchAccountData()
	assert.NoError(t, err)
	assert.Len(t, ad.Accounts, 1)
	assert.Equal(t, "Acc2", ad.Accounts[0].Name)
	assert.Empty(t, ad.Associations)
}

func TestAccountDataStore_DeleteAccountData(t *testing.T) {
	logger := &MockLogger{}
	basePath := t.TempDir()
	fs := persist.OSFileSystem{}

	store := account.NewAccountDataStore(logger, fs, basePath)

	// Save some data
	err := store.SaveAccountData(model.AccountData{
		Accounts: []model.Account{
			{Name: "ToDelete"},
		},
	})
	assert.NoError(t, err)

	// Ensure file created
	filePath := filepath.Join(basePath, "account_data.json")
	_, err = fs.Stat(filePath)
	assert.NoError(t, err)

	// DeleteAccountData
	err = store.DeleteAccountData()
	assert.NoError(t, err)

	// Ensure file does not exist now
	_, err = fs.Stat(filePath)
	assert.True(t, os.IsNotExist(err))

	// FetchAccountData should return empty
	ad, err := store.FetchAccountData()
	assert.NoError(t, err)
	assert.Empty(t, ad.Accounts)
	assert.Empty(t, ad.Associations)
}

func TestAccountDataStore_DeleteAccounts(t *testing.T) {
	logger := &MockLogger{}
	basePath := t.TempDir()
	fs := persist.OSFileSystem{}

	store := account.NewAccountDataStore(logger, fs, basePath)

	// Save some data with Accounts
	err := store.SaveAccountData(model.AccountData{
		Accounts: []model.Account{
			{Name: "AccToDelete"},
		},
		Associations: []model.Association{
			{UserId: "U1", CharId: "C1"},
		},
	})
	assert.NoError(t, err)

	// Delete just the accounts
	err = store.DeleteAccounts()
	assert.NoError(t, err)

	// Verify accounts empty, but associations remain
	ad, err := store.FetchAccountData()
	assert.NoError(t, err)
	assert.Empty(t, ad.Accounts)
	assert.Len(t, ad.Associations, 1)
}

================
File: internal/persist/account/account_store.go
================
// account_store.go
package account

import (
	"fmt"
	"os"
	"path/filepath"
	"sync"

	"github.com/guarzo/canifly/internal/model"
	"github.com/guarzo/canifly/internal/persist"
	"github.com/guarzo/canifly/internal/services/interfaces"
)

const (
	accountFileName = "account_data.json"
)

var _ interfaces.AccountDataRepository = (*AccountDataStore)(nil)

type AccountDataStore struct {
	logger     interfaces.Logger
	fs         persist.FileSystem
	basePath   string
	mu         sync.RWMutex
	cachedData *model.AccountData // In-memory cached data
}

func NewAccountDataStore(logger interfaces.Logger, fs persist.FileSystem, basePath string) *AccountDataStore {
	return &AccountDataStore{
		logger:   logger,
		fs:       fs,
		basePath: basePath,
	}
}

func (as *AccountDataStore) FetchAccounts() ([]model.Account, error) {
	as.mu.RLock()
	defer as.mu.RUnlock()

	accountData, err := as.fetchAccountDataLocked()
	if err != nil {
		return nil, err
	}

	if accountData.Accounts == nil {
		as.logger.Infof("empty accounts retrieved")
		accountData.Accounts = make([]model.Account, 0)
	}
	return accountData.Accounts, nil
}

func (as *AccountDataStore) SaveAccounts(accounts []model.Account) error {
	as.mu.Lock()
	defer as.mu.Unlock()

	accountData, err := as.fetchAccountDataLocked()
	if err != nil {
		return err
	}
	accountData.Accounts = accounts
	return as.saveAccountDataLocked(*accountData)
}

func (as *AccountDataStore) DeleteAccounts() error {
	as.mu.Lock()
	defer as.mu.Unlock()

	accountData, err := as.fetchAccountDataLocked()
	if err != nil {
		return err
	}
	accountData.Accounts = []model.Account{}
	return as.saveAccountDataLocked(*accountData)
}

func (as *AccountDataStore) FetchAccountData() (model.AccountData, error) {
	as.mu.RLock()
	defer as.mu.RUnlock()
	data, err := as.fetchAccountDataLocked()
	if err != nil {
		return model.AccountData{}, err
	}
	return *data, nil
}

func (as *AccountDataStore) SaveAccountData(data model.AccountData) error {
	as.mu.Lock()
	defer as.mu.Unlock()

	return as.saveAccountDataLocked(data)
}

func (as *AccountDataStore) DeleteAccountData() error {
	as.mu.Lock()
	defer as.mu.Unlock()

	filePath := filepath.Join(as.basePath, accountFileName)
	if err := as.fs.Remove(filePath); err != nil && !os.IsNotExist(err) {
		as.logger.WithError(err).Errorf("Failed to delete account data file %s", filePath)
		return err
	}
	as.logger.Info("account data file deleted")

	// Clear the cache since we no longer have data on disk
	as.cachedData = nil
	return nil
}

// internal methods that assume locks are held

func (as *AccountDataStore) fetchAccountDataLocked() (*model.AccountData, error) {
	// If we have cached data, return it directly
	if as.cachedData != nil {
		return as.cachedData, nil
	}

	filePath := filepath.Join(as.basePath, accountFileName)
	fileInfo, err := as.fs.Stat(filePath)
	if os.IsNotExist(err) || (err == nil && fileInfo.Size() == 0) {
		as.logger.Info("No account data file found")
		as.cachedData = &model.AccountData{
			Accounts:     []model.Account{},
			Associations: []model.Association{},
		}
		return as.cachedData, nil
	} else if err != nil {
		return nil, fmt.Errorf("failed to stat account data file: %w", err)
	}

	var data model.AccountData
	if err := persist.ReadJsonFromFile(as.fs, filePath, &data); err != nil {
		as.logger.WithError(err).Error("Error loading account data")
		return nil, err
	}

	as.logger.Debugf("Loaded account data with %d accounts", len(data.Accounts))
	// Cache the loaded data
	as.cachedData = &data
	return as.cachedData, nil
}

func (as *AccountDataStore) saveAccountDataLocked(data model.AccountData) error {
	filePath := filepath.Join(as.basePath, accountFileName)
	if err := persist.SaveJsonToFile(as.fs, filePath, data); err != nil {
		as.logger.WithError(err).Error("Error saving account data")
		return fmt.Errorf("error saving account data: %w", err)
	}

	// Update the cache with the newly saved data
	as.cachedData = &data
	as.logger.Debugf("Saved account data with %d accounts", len(data.Accounts))
	return nil
}

================
File: internal/persist/account/login_state_store.go
================
package account

import (
	"sync"

	"github.com/guarzo/canifly/internal/model"
	"github.com/guarzo/canifly/internal/services/interfaces"
)

var _ interfaces.LoginRepository = (*LoginStateStore)(nil)

type LoginStateStore struct {
	mu    sync.Mutex
	store map[string]*model.AuthStatus
}

func NewLoginStateStore() *LoginStateStore {
	return &LoginStateStore{
		store: make(map[string]*model.AuthStatus),
	}
}

func (l *LoginStateStore) Set(state string, authStatus *model.AuthStatus) {
	l.mu.Lock()
	defer l.mu.Unlock()
	l.store[state] = authStatus
}

func (l *LoginStateStore) Get(state string) (*model.AuthStatus, bool) {
	l.mu.Lock()
	defer l.mu.Unlock()
	val, ok := l.store[state]
	return val, ok
}

func (l *LoginStateStore) Delete(state string) {
	l.mu.Lock()
	defer l.mu.Unlock()
	delete(l.store, state)
}

================
File: internal/persist/config/app_state_store_test.go
================
package config_test

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/guarzo/canifly/internal/model"
	"github.com/guarzo/canifly/internal/persist"
	"github.com/guarzo/canifly/internal/persist/config"
	"github.com/guarzo/canifly/internal/testutil"
	"github.com/stretchr/testify/assert"
)

func TestAppStateStore_InitialLoad(t *testing.T) {
	logger := &testutil.MockLogger{}
	basePath := t.TempDir()
	fs := persist.OSFileSystem{}

	// No file initially
	store := config.NewAppStateStore(logger, fs, basePath)

	state := store.GetAppState()
	// Initially empty since no file
	assert.False(t, state.LoggedIn)
	assert.Empty(t, state.AccountData.Accounts)
	assert.Empty(t, state.EveData.EveProfiles)
	assert.Empty(t, state.ConfigData.Roles)
}

func TestAppStateStore_SetAndGetAppState(t *testing.T) {
	logger := &testutil.MockLogger{}
	basePath := t.TempDir()
	fs := persist.OSFileSystem{}

	store := config.NewAppStateStore(logger, fs, basePath)

	// Set an AppState
	newState := model.AppState{
		LoggedIn: true,
		ConfigData: model.ConfigData{
			Roles: []string{"Admin"},
		},
	}
	store.SetAppState(newState)

	fetched := store.GetAppState()
	assert.True(t, fetched.LoggedIn)
	assert.Equal(t, []string{"Admin"}, fetched.ConfigData.Roles)
}

func TestAppStateStore_SetAppStateLogin(t *testing.T) {
	logger := &testutil.MockLogger{}
	basePath := t.TempDir()
	fs := persist.OSFileSystem{}

	store := config.NewAppStateStore(logger, fs, basePath)

	// Set login to true
	err := store.SetAppStateLogin(true)
	assert.NoError(t, err)

	fetched := store.GetAppState()
	assert.True(t, fetched.LoggedIn)

	// Verify it saved to file
	filePath := filepath.Join(basePath, "appstate_snapshot.json")
	_, statErr := fs.Stat(filePath)
	assert.NoError(t, statErr)

	// Create a new store and it should load the persisted state
	newStore := config.NewAppStateStore(logger, fs, basePath)
	newFetched := newStore.GetAppState()
	assert.True(t, newFetched.LoggedIn)
}

func TestAppStateStore_ClearAppState(t *testing.T) {
	logger := &testutil.MockLogger{}
	basePath := t.TempDir()
	fs := persist.OSFileSystem{}

	store := config.NewAppStateStore(logger, fs, basePath)

	// Set some state
	initial := model.AppState{
		LoggedIn: true,
		ConfigData: model.ConfigData{
			Roles: []string{"User"},
		},
	}
	store.SetAppState(initial)

	// Clear it
	store.ClearAppState()
	cleared := store.GetAppState()
	assert.False(t, cleared.LoggedIn)
	assert.Empty(t, cleared.ConfigData.Roles)
}

func TestAppStateStore_SaveAppStateSnapshot(t *testing.T) {
	logger := &testutil.MockLogger{}
	basePath := t.TempDir()
	fs := persist.OSFileSystem{}

	store := config.NewAppStateStore(logger, fs, basePath)

	// Set some state and save snapshot
	state := model.AppState{
		LoggedIn: true,
		ConfigData: model.ConfigData{
			Roles: []string{"Editor"},
		},
	}

	err := store.SaveAppStateSnapshot(state)
	assert.NoError(t, err)

	// Verify file created
	filePath := filepath.Join(basePath, "appstate_snapshot.json")
	_, err = fs.Stat(filePath)
	assert.NoError(t, err)

	// Create a new store and ensure it loads the saved state
	newStore := config.NewAppStateStore(logger, fs, basePath)
	newState := newStore.GetAppState()
	assert.True(t, newState.LoggedIn)
	assert.Equal(t, []string{"Editor"}, newState.ConfigData.Roles)
}

func TestAppStateStore_LoadError(t *testing.T) {
	logger := &testutil.MockLogger{}
	basePath := t.TempDir()
	fs := persist.OSFileSystem{}

	// Create a file that is not valid JSON
	filePath := filepath.Join(basePath, "appstate_snapshot.json")
	err := os.WriteFile(filePath, []byte("not valid json"), 0644)
	assert.NoError(t, err)

	// Creating the store should log a warning about loading state
	// but it should still return a store with default empty AppState
	store := config.NewAppStateStore(logger, fs, basePath)
	st := store.GetAppState()

	// Should be empty because it failed to load the invalid file
	assert.False(t, st.LoggedIn)
	assert.Empty(t, st.AccountData.Accounts)
	assert.Empty(t, st.EveData.EveProfiles)
	assert.Empty(t, st.ConfigData.Roles)
}

================
File: internal/persist/config/app_state_store.go
================
package config

import (
	"fmt"
	"os"
	"path/filepath"
	"sync"

	"github.com/guarzo/canifly/internal/model"
	"github.com/guarzo/canifly/internal/persist"
	"github.com/guarzo/canifly/internal/services/interfaces"
)

var _ interfaces.AppStateRepository = (*AppStateStore)(nil)

type AppStateStore struct {
	logger   interfaces.Logger
	fs       persist.FileSystem
	basePath string

	mut      sync.RWMutex
	appState model.AppState
}

func NewAppStateStore(logger interfaces.Logger, fs persist.FileSystem, basePath string) *AppStateStore {
	store := &AppStateStore{
		logger:   logger,
		fs:       fs,
		basePath: basePath,
	}
	if err := store.loadAppStateFromFile(); err != nil {
		logger.Warnf("Unable to load app state from file: %v", err)
	}
	return store
}

func (s *AppStateStore) GetAppState() model.AppState {
	s.mut.RLock()
	defer s.mut.RUnlock()
	return s.appState
}

func (s *AppStateStore) SetAppState(appState model.AppState) {
	s.mut.Lock()
	defer s.mut.Unlock()
	s.appState = appState
}

func (s *AppStateStore) SetAppStateLogin(isLoggedIn bool) error {
	appState := s.GetAppState()
	appState.LoggedIn = isLoggedIn
	s.SetAppState(appState)
	return s.SaveAppStateSnapshot(appState)
}

func (s *AppStateStore) ClearAppState() {
	s.mut.Lock()
	defer s.mut.Unlock()
	s.appState = model.AppState{}
}

func (s *AppStateStore) SaveAppStateSnapshot(appState model.AppState) error {
	snapshotPath := filepath.Join(s.basePath, "appstate_snapshot.json")
	s.logger.Debugf("app state saved at %s", snapshotPath)
	return persist.SaveJsonToFile(s.fs, snapshotPath, appState)
}

func (s *AppStateStore) loadAppStateFromFile() error {
	path := filepath.Join(s.basePath, "appstate_snapshot.json")
	if _, err := s.fs.Stat(path); os.IsNotExist(err) {
		return nil
	} else if err != nil {
		return fmt.Errorf("failed to stat appstate file: %w", err)
	}

	var appState model.AppState
	if err := persist.ReadJsonFromFile(s.fs, path, &appState); err != nil {
		return fmt.Errorf("failed to load AppState: %w", err)
	}

	s.mut.Lock()
	s.appState = appState
	s.mut.Unlock()
	s.logger.Debugf("Loaded persisted AppState from %s", path)
	return nil
}

================
File: internal/persist/config/config_store_test.go
================
package config_test

import (
	testutil "github.com/guarzo/canifly/internal/testutil"
	"os"
	"runtime"
	"testing"

	"github.com/guarzo/canifly/internal/model"
	"github.com/guarzo/canifly/internal/persist"
	"github.com/guarzo/canifly/internal/persist/config"
	"github.com/stretchr/testify/assert"
)

func TestConfigStore_EmptyInitially(t *testing.T) {
	logger := &testutil.MockLogger{}
	basePath := t.TempDir()
	fs := persist.OSFileSystem{}

	store := config.NewConfigStore(logger, fs, basePath)

	// No config file, should return empty config
	cdata, err := store.FetchConfigData()
	assert.NoError(t, err)
	assert.NotNil(t, cdata)
	assert.Empty(t, cdata.Roles)
	assert.Empty(t, cdata.SettingsDir)
	assert.Empty(t, cdata.LastBackupDir)
	assert.Empty(t, cdata.DropDownSelections)
}

func TestConfigStore_SaveAndFetchConfig(t *testing.T) {
	logger := &testutil.MockLogger{}
	basePath := t.TempDir()
	fs := persist.OSFileSystem{}

	store := config.NewConfigStore(logger, fs, basePath)

	configData := &model.ConfigData{
		Roles:         []string{"Admin", "User"},
		SettingsDir:   "/some/path",
		LastBackupDir: "/backup/dir",
		DropDownSelections: model.DropDownSelections{
			"key1": {CharId: "char1", UserId: "user1"},
		},
	}

	err := store.SaveConfigData(configData)
	assert.NoError(t, err)

	fetched, err := store.FetchConfigData()
	assert.NoError(t, err)
	assert.NotNil(t, fetched)
	assert.Equal(t, configData.Roles, fetched.Roles)
	assert.Equal(t, configData.SettingsDir, fetched.SettingsDir)
	assert.Equal(t, configData.LastBackupDir, fetched.LastBackupDir)
	assert.Equal(t, configData.DropDownSelections, fetched.DropDownSelections)
}

func TestConfigStore_UserSelections(t *testing.T) {
	logger := &testutil.MockLogger{}
	basePath := t.TempDir()
	fs := persist.OSFileSystem{}

	store := config.NewConfigStore(logger, fs, basePath)

	// Initially empty
	selections, err := store.FetchUserSelections()
	assert.NoError(t, err)
	assert.Empty(t, selections)

	newSelections := model.DropDownSelections{
		"option1": {CharId: "C1", UserId: "U1"},
		"option2": {CharId: "C2", UserId: "U2"},
	}

	err = store.SaveUserSelections(newSelections)
	assert.NoError(t, err)

	fetchedSelections, err := store.FetchUserSelections()
	assert.NoError(t, err)
	assert.Equal(t, newSelections, fetchedSelections)
}

func TestConfigStore_Roles(t *testing.T) {
	logger := &testutil.MockLogger{}
	basePath := t.TempDir()
	fs := persist.OSFileSystem{}

	store := config.NewConfigStore(logger, fs, basePath)

	roles, err := store.FetchRoles()
	assert.NoError(t, err)
	assert.Empty(t, roles)

	newRoles := []string{"Role1", "Role2"}
	err = store.SaveRoles(newRoles)
	assert.NoError(t, err)

	fetchedRoles, err := store.FetchRoles()
	assert.NoError(t, err)
	assert.Equal(t, newRoles, fetchedRoles)
}

func TestConfigStore_FailedStat(t *testing.T) {
	logger := &testutil.MockLogger{}
	basePath := t.TempDir()
	fs := persist.OSFileSystem{}

	// Remove permissions so stat fails
	err := os.Chmod(basePath, 0000)
	assert.NoError(t, err, "Should be able to remove permissions")

	store := config.NewConfigStore(logger, fs, basePath)
	_, statErr := store.FetchConfigData()
	assert.Error(t, statErr)

	// Restore permissions for cleanup
	err = os.Chmod(basePath, 0755)
	assert.NoError(t, err)
}

func TestConfigStore_GetDefaultSettingsDir(t *testing.T) {
	logger := &testutil.MockLogger{}
	basePath := t.TempDir()
	fs := persist.OSFileSystem{}

	store := config.NewConfigStore(logger, fs, basePath)

	dir, err := store.GetDefaultSettingsDir()
	// This might differ by platform. Just ensure no error is returned.
	// On unsupported platforms, error will be returned.
	if runtime.GOOS == "windows" || runtime.GOOS == "darwin" || runtime.GOOS == "linux" {
		assert.NoError(t, err)
		assert.NotEmpty(t, dir)
	} else {
		assert.Error(t, err)
	}
}

================
File: internal/persist/config/config_store.go
================
package config

import (
	"archive/zip"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"sync"
	"time"

	"github.com/guarzo/canifly/internal/model"
	"github.com/guarzo/canifly/internal/persist"
	"github.com/guarzo/canifly/internal/services/interfaces"
)

const (
	configFileName = "config.json"
)

var _ interfaces.ConfigRepository = (*ConfigStore)(nil)

type ConfigStore struct {
	logger   interfaces.Logger
	fs       persist.FileSystem
	basePath string
	mut      sync.RWMutex

	// cachedData holds an in-memory copy of the config.
	cachedData *model.ConfigData
}

func NewConfigStore(logger interfaces.Logger, fs persist.FileSystem, basePath string) *ConfigStore {
	return &ConfigStore{
		logger:   logger,
		fs:       fs,
		basePath: basePath,
	}
}

// FetchConfigData returns config data (read operation)
func (c *ConfigStore) FetchConfigData() (*model.ConfigData, error) {
	c.mut.RLock()
	defer c.mut.RUnlock()

	return c.fetchConfigDataLocked()
}

// SaveConfigData saves config data (write operation)
func (c *ConfigStore) SaveConfigData(configData *model.ConfigData) error {
	c.mut.Lock()
	defer c.mut.Unlock()

	return c.saveConfigDataLocked(configData)
}

// FetchUserSelections (read operation)
func (c *ConfigStore) FetchUserSelections() (model.DropDownSelections, error) {
	c.mut.RLock()
	defer c.mut.RUnlock()

	configData, err := c.fetchConfigDataLocked()
	if err != nil {
		return nil, err
	}
	if configData.DropDownSelections == nil {
		configData.DropDownSelections = make(model.DropDownSelections)
	}
	return configData.DropDownSelections, nil
}

// SaveUserSelections (write operation)
func (c *ConfigStore) SaveUserSelections(selections model.DropDownSelections) error {
	c.mut.Lock()
	defer c.mut.Unlock()

	configData, err := c.fetchConfigDataLocked()
	if err != nil {
		return err
	}
	configData.DropDownSelections = selections
	return c.saveConfigDataLocked(configData)
}

// FetchRoles (read operation)
func (c *ConfigStore) FetchRoles() ([]string, error) {
	c.mut.RLock()
	defer c.mut.RUnlock()

	configData, err := c.fetchConfigDataLocked()
	if err != nil {
		return nil, err
	}
	if configData.Roles == nil {
		configData.Roles = make([]string, 0)
	}
	return configData.Roles, nil
}

// SaveRoles (write operation)
func (c *ConfigStore) SaveRoles(roles []string) error {
	c.mut.Lock()
	defer c.mut.Unlock()

	configData, err := c.fetchConfigDataLocked()
	if err != nil {
		return err
	}
	configData.Roles = roles
	return c.saveConfigDataLocked(configData)
}

// GetDefaultSettingsDir returns the default settings directory.
// It uses os.UserHomeDir() normally, but if running under WSL it retrieves the Windows home directory
// (converted to WSL format) and then constructs candidate directories.
// It then checks for the existence of these candidates and returns the first one that exists,
// or, if none exist, returns the first candidate.
func (c *ConfigStore) GetDefaultSettingsDir() (string, error) {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return "", err
	}

	platform := runtime.GOOS
	if isWSL() {
		platform = "wsl"
		homeDir, err = getWindowsHomeInWSL()
		if err != nil {
			return "", err
		}
	}

	var candidates []string
	switch platform {
	case "windows":
		candidates = []string{
			filepath.Join(homeDir, "AppData", "Local", "CCP", "EVE", "c_ccp_eve_online_tq_tranquility"),
			filepath.Join(homeDir, "AppData", "Local", "CCP", "EVE", "c_ccp_eve_tq_tranquility"),
		}
	case "darwin":
		candidates = []string{
			filepath.Join(homeDir, "Library", "Application Support", "CCP", "EVE", "c_ccp_eve_online_tq_tranquility"),
		}
	case "linux":
		candidates = []string{
			filepath.Join(homeDir, ".local", "share", "CCP", "EVE", "c_ccp_eve_online_tq_tranquility"),
		}
	case "wsl":
		// In WSL we prefer the Windows equivalent without "online"
		candidates = []string{
			filepath.Join(homeDir, "AppData", "Local", "CCP", "EVE", "c_ccp_eve_tq_tranquility"),
			filepath.Join(homeDir, "AppData", "Local", "CCP", "EVE", "c_ccp_eve_online_tq_tranquility"),
		}
	default:
		return "", fmt.Errorf("unsupported platform: %s", platform)
	}

	for _, dir := range candidates {
		if info, err := os.Stat(dir); err == nil && info.IsDir() {
			return dir, nil
		}
	}

	// If none of the candidate directories exist, return the first candidate (even if it doesn't exist)
	return candidates[0], nil
}

// Internal helper: isWSL returns true if running under Windows Subsystem for Linux.
func isWSL() bool {
	if runtime.GOOS == "linux" {
		data, err := os.ReadFile("/proc/version")
		if err == nil && strings.Contains(strings.ToLower(string(data)), "microsoft") {
			return true
		}
	}
	return false
}

// Internal helper: getWindowsHomeInWSL retrieves the Windows home directory in WSL (converted to a Unix-style path).
func getWindowsHomeInWSL() (string, error) {
	out, err := runCommand("cmd.exe", []string{"/C", "echo", "%USERPROFILE%"})
	if err != nil {
		return "", fmt.Errorf("failed to retrieve Windows home directory in WSL: %w", err)
	}
	windowsHome := strings.TrimSpace(out)
	windowsHome = strings.ReplaceAll(windowsHome, "\\", "/")

	out2, err := runCommand("wslpath", []string{"-u", windowsHome})
	if err != nil {
		return "", fmt.Errorf("failed to convert Windows home path to WSL format: %w", err)
	}
	return strings.TrimSpace(out2), nil
}

func runCommand(name string, args []string) (string, error) {
	cmd := exec.Command(name, args...)
	output, err := cmd.Output()
	return string(output), err
}

// Internal read/write methods assume lock is already held.
func (c *ConfigStore) fetchConfigDataLocked() (*model.ConfigData, error) {
	if c.cachedData != nil {
		return c.cachedData, nil
	}

	filePath := filepath.Join(c.basePath, configFileName)
	var configData model.ConfigData

	fileInfo, err := c.fs.Stat(filePath)
	if os.IsNotExist(err) || (err == nil && fileInfo.Size() == 0) {
		c.logger.Info("No config data file found, returning empty config")
		c.cachedData = &configData
		return c.cachedData, nil
	} else if err != nil {
		return nil, fmt.Errorf("failed to stat config data file: %w", err)
	}

	if err := persist.ReadJsonFromFile(c.fs, filePath, &configData); err != nil {
		c.logger.WithError(err).Error("Error loading config data")
		return nil, err
	}

	c.logger.Debugf("Loaded config: %v", configData)
	c.cachedData = &configData
	return c.cachedData, nil
}

func (c *ConfigStore) saveConfigDataLocked(configData *model.ConfigData) error {
	filePath := filepath.Join(c.basePath, configFileName)
	if err := persist.SaveJsonToFile(c.fs, filePath, configData); err != nil {
		c.logger.WithError(err).Error("Error saving config data")
		return err
	}
	c.logger.Debugf("Config data saved")
	c.cachedData = configData
	return nil
}

// -------------------------------------------------------------------
// NEW METHOD: Zip up all *.json files from c.basePath into backupDir
// -------------------------------------------------------------------
func (c *ConfigStore) BackupJSONFiles(backupDir string) error {
	now := time.Now()
	timeStr := now.Format("2006-01-02_15-04-05")
	zipFileName := fmt.Sprintf("canifly_backup_%s.zip", timeStr)
	zipFilePath := filepath.Join(backupDir, zipFileName)

	c.logger.Infof("Zipping all *.json from basePath=%s into %s", c.basePath, zipFilePath)

	var jsonFiles []string
	err := filepath.Walk(c.basePath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() && strings.HasSuffix(strings.ToLower(info.Name()), ".json") {
			jsonFiles = append(jsonFiles, path)
		}
		return nil
	})
	if err != nil {
		c.logger.Errorf("Failed to walk basePath=%s: %v", c.basePath, err)
		return err
	}

	if len(jsonFiles) == 0 {
		c.logger.Warnf("No .json files found under %s", c.basePath)
		return fmt.Errorf("no .json files to backup in %s", c.basePath)
	}

	zipFile, err := os.Create(zipFilePath)
	if err != nil {
		c.logger.Errorf("Failed to create zip file %s: %v", zipFilePath, err)
		return err
	}
	defer zipFile.Close()

	zipWriter := zip.NewWriter(zipFile)
	defer zipWriter.Close()

	for _, file := range jsonFiles {
		f, err := os.Open(file)
		if err != nil {
			c.logger.Errorf("Failed to open json file %s: %v", file, err)
			return err
		}

		relPath, err := filepath.Rel(c.basePath, file)
		if err != nil {
			relPath = filepath.Base(file)
		}

		w, err := zipWriter.Create(relPath)
		if err != nil {
			c.logger.Errorf("Failed to create zip entry for %s: %v", file, err)
			f.Close()
			return err
		}

		_, err = io.Copy(w, f)
		f.Close()
		if err != nil {
			c.logger.Errorf("Failed to copy file content for %s into zip: %v", file, err)
			return err
		}
	}

	c.logger.Infof("Successfully created zip of .json files: %s", zipFilePath)
	return nil
}

================
File: internal/persist/eve/cache_store_test.go
================
package eve_test

import (
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/guarzo/canifly/internal/persist"
	"github.com/guarzo/canifly/internal/persist/eve"
	"github.com/guarzo/canifly/internal/testutil"
	"github.com/stretchr/testify/assert"
)

func TestCacheStore_EmptyInitially(t *testing.T) {
	logger := &testutil.MockLogger{}
	basePath := t.TempDir()
	fs := persist.OSFileSystem{}

	store := eve.NewCacheStore(logger, fs, basePath)

	// No items initially
	val, found := store.Get("key")
	assert.False(t, found)
	assert.Nil(t, val)

	// Loading from non-existent file should not error
	err := store.LoadApiCache()
	assert.NoError(t, err)
}

func TestCacheStore_SetGet(t *testing.T) {
	logger := &testutil.MockLogger{}
	basePath := t.TempDir()
	fs := persist.OSFileSystem{}

	store := eve.NewCacheStore(logger, fs, basePath)

	data := []byte("testdata")
	store.Set("mykey", data, 10*time.Minute)

	val, found := store.Get("mykey")
	assert.True(t, found)
	assert.Equal(t, data, val)

	val2, found2 := store.Get("otherkey")
	assert.False(t, found2)
	assert.Nil(t, val2)
}

func TestCacheStore_SaveAndLoad(t *testing.T) {
	logger := &testutil.MockLogger{}
	basePath := t.TempDir()
	fs := persist.OSFileSystem{}

	store := eve.NewCacheStore(logger, fs, basePath)

	// Add some items
	store.Set("key1", []byte("value1"), 10*time.Minute)
	store.Set("key2", []byte("value2"), 5*time.Minute)

	err := store.SaveApiCache()
	assert.NoError(t, err)

	// Create a new store and load the data
	newStore := eve.NewCacheStore(logger, fs, basePath)
	err = newStore.LoadApiCache()
	assert.NoError(t, err)

	val, found := newStore.Get("key1")
	assert.True(t, found)
	assert.Equal(t, []byte("value1"), val)

	val2, found2 := newStore.Get("key2")
	assert.True(t, found2)
	assert.Equal(t, []byte("value2"), val2)
}

func TestCacheStore_ExpiredItemsNotLoaded(t *testing.T) {
	logger := &testutil.MockLogger{}
	basePath := t.TempDir()
	fs := persist.OSFileSystem{}

	store := eve.NewCacheStore(logger, fs, basePath)

	// Set an item that expires soon
	store.Set("soonToExpire", []byte("expiring"), 1*time.Millisecond)

	// Wait for it to expire
	time.Sleep(10 * time.Millisecond)

	// Save to file (it should still be in the cache, but expired)
	err := store.SaveApiCache()
	assert.NoError(t, err)

	// Create a new store and load the data
	newStore := eve.NewCacheStore(logger, fs, basePath)
	err = newStore.LoadApiCache()
	assert.NoError(t, err)

	// The expired item should not be set
	val, found := newStore.Get("soonToExpire")
	assert.False(t, found)
	assert.Nil(t, val)
}

func TestCacheStore_LoadInvalidData(t *testing.T) {
	logger := &testutil.MockLogger{}
	basePath := t.TempDir()
	fs := persist.OSFileSystem{}

	store := eve.NewCacheStore(logger, fs, basePath)

	// Write invalid JSON to the cache file
	filePath := filepath.Join(basePath, "cache.json")
	err := os.WriteFile(filePath, []byte("not valid json"), 0600)
	assert.NoError(t, err)

	// Loading should fail
	err = store.LoadApiCache()
	assert.Error(t, err)
}

func TestCacheStore_SaveNoByteValues(t *testing.T) {
	logger := &testutil.MockLogger{}
	basePath := t.TempDir()
	fs := persist.OSFileSystem{}

	store := eve.NewCacheStore(logger, fs, basePath)

	// Insert a non-byte value directly (we can't do that easily via store.Set since it expects []byte)
	// Instead, we'll use the underlying cache for this test scenario:
	store.Set("notBytes", []byte("original"), 10*time.Minute)

	// Modify item in the underlying cache for testing:
	items := store.CacheItemsForTest()
	items["notBytes"] = items["notBytes"] // This is just a no-op; If you need to force a non-byte, you'd have to reflect or break type safety.

	// Actually, to test the "not bytes" scenario realistically:
	// Let's store a non-byte value via store.cache directly.
	store.CacheSetForTest("notBytes2", "stringValue")

	// Now save to file and ensure warning is logged
	// "notBytes2" should be skipped
	err := store.SaveApiCache()
	assert.NoError(t, err)

	// Load again
	newStore := eve.NewCacheStore(logger, fs, basePath)
	err = newStore.LoadApiCache()
	assert.NoError(t, err)

	// "notBytes2" should not be found
	val, found := newStore.Get("notBytes2")
	assert.False(t, found)
	assert.Nil(t, val)

	// "notBytes" was bytes, so it should be found
	val, found = newStore.Get("notBytes")
	assert.True(t, found)
	assert.Equal(t, []byte("original"), val)
}

================
File: internal/persist/eve/cache_store.go
================
package eve

import (
	"fmt"
	"os"
	"path/filepath"
	"time"

	"github.com/guarzo/canifly/internal/persist"
	"github.com/guarzo/canifly/internal/services/interfaces"
	"github.com/patrickmn/go-cache"
)

const (
	DefaultExpiration = 30 * time.Minute
	cleanupInterval   = 32 * time.Minute
	cacheFileName     = "cache.json"
)

var _ interfaces.CacheRepository = (*CacheStore)(nil)

type CacheStore struct {
	cache    *cache.Cache
	logger   interfaces.Logger
	fs       persist.FileSystem
	basePath string
}

func NewCacheStore(logger interfaces.Logger, fs persist.FileSystem, basePath string) *CacheStore {
	return &CacheStore{
		cache:    cache.New(DefaultExpiration, cleanupInterval),
		logger:   logger,
		fs:       fs,
		basePath: basePath,
	}
}

func (c *CacheStore) Get(key string) ([]byte, bool) {
	value, found := c.cache.Get(key)
	if !found {
		return nil, false
	}
	byteSlice, ok := value.([]byte)
	return byteSlice, ok
}

func (c *CacheStore) Set(key string, value []byte, expiration time.Duration) {
	c.cache.Set(key, value, expiration)
}

func (c *CacheStore) LoadApiCache() error {
	filename := filepath.Join(c.basePath, cacheFileName)
	var serializable map[string]cacheItem

	if _, err := c.fs.Stat(filename); os.IsNotExist(err) {
		c.logger.Infof("CacheStore file does not exist: %s", filename)
		return nil
	} else if err != nil {
		return fmt.Errorf("failed to stat cache file: %w", err)
	}

	if err := persist.ReadJsonFromFile(c.fs, filename, &serializable); err != nil {
		c.logger.WithError(err).Errorf("Failed to load cache from %s", filename)
		return err
	}

	for k, item := range serializable {
		ttl := time.Until(item.Expiration)
		if ttl > 0 {
			c.cache.Set(k, item.Value, ttl)
		} else {
			c.logger.Infof("Skipping expired cache item: %s", k)
		}
	}

	c.logger.Debugf("CacheStore successfully loaded from file: %s", filename)
	return nil
}

func (c *CacheStore) SaveApiCache() error {
	filename := filepath.Join(c.basePath, cacheFileName)
	items := c.cache.Items()

	serializable := make(map[string]cacheItem, len(items))
	for k, v := range items {
		byteSlice, ok := v.Object.([]byte)
		if !ok {
			c.logger.Warnf("Skipping key %s as its value is not []byte", k)
			continue
		}
		serializable[k] = cacheItem{
			Value:      byteSlice,
			Expiration: time.Unix(0, v.Expiration),
		}
	}

	if err := persist.SaveJsonToFile(c.fs, filename, serializable); err != nil {
		c.logger.WithError(err).Errorf("Failed to save cache to %s", filename)
		return fmt.Errorf("failed to write JSON file: %w", err)
	}

	c.logger.Debugf("CacheStore saved to %s", filename)
	return nil
}

type cacheItem struct {
	Value      []byte
	Expiration time.Time
}

func (c *CacheStore) CacheItemsForTest() map[string]cache.Item {
	return c.cache.Items()
}

func (c *CacheStore) CacheSetForTest(key string, value interface{}) {
	c.cache.Set(key, value, DefaultExpiration)
}

================
File: internal/persist/eve/deleted_store_test.go
================
package eve_test

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/guarzo/canifly/internal/persist"
	"github.com/guarzo/canifly/internal/persist/eve"
	"github.com/guarzo/canifly/internal/testutil"
	"github.com/stretchr/testify/assert"
)

func TestDeletedStore_FetchNoFile(t *testing.T) {
	logger := &testutil.MockLogger{}
	basePath := t.TempDir()
	fs := persist.OSFileSystem{}

	store := eve.NewDeletedStore(logger, fs, basePath)

	// With the updated store, no file means an empty slice and no error.
	chars, err := store.FetchDeletedCharacters()
	assert.NoError(t, err, "Should not error if file does not exist")
	assert.Empty(t, chars, "Should return empty slice if no file found")
}

func TestDeletedStore_SaveAndFetch(t *testing.T) {
	logger := &testutil.MockLogger{}
	basePath := t.TempDir()
	fs := persist.OSFileSystem{}

	store := eve.NewDeletedStore(logger, fs, basePath)

	original := []string{"char1", "char2", "char3"}

	// Save
	err := store.SaveDeletedCharacters(original)
	assert.NoError(t, err, "Save should succeed")

	// Fetch and verify
	fetched, err := store.FetchDeletedCharacters()
	assert.NoError(t, err, "Fetch should succeed after save")
	assert.Equal(t, original, fetched)
}

func TestDeletedStore_InvalidJSON(t *testing.T) {
	logger := &testutil.MockLogger{}
	basePath := t.TempDir()
	fs := persist.OSFileSystem{}

	store := eve.NewDeletedStore(logger, fs, basePath)

	// Write invalid JSON to file
	filePath := filepath.Join(basePath, "deleted.json")
	err := os.WriteFile(filePath, []byte("not valid json"), 0600)
	assert.NoError(t, err)

	// Fetch should fail
	chars, err := store.FetchDeletedCharacters()
	assert.Error(t, err)
	assert.Empty(t, chars)
	assert.Contains(t, err.Error(), "failed to load deleted characters")
}

func TestDeletedStore_StatError(t *testing.T) {
	if os.Getenv("CI") != "" {
		t.Skip("Skipping permission test in CI environment")
	}

	logger := &testutil.MockLogger{}
	basePath := t.TempDir()
	fs := persist.OSFileSystem{}

	store := eve.NewDeletedStore(logger, fs, basePath)

	// Create a file but then revoke permissions on directory to cause stat error
	filePath := filepath.Join(basePath, "deleted.json")
	err := os.WriteFile(filePath, []byte(`["charX"]`), 0600)
	assert.NoError(t, err)

	// Revoke permissions so stat fails
	err = os.Chmod(basePath, 0000)
	assert.NoError(t, err, "Should be able to remove permissions")

	defer os.Chmod(basePath, 0755) // restore permissions for cleanup

	chars, err := store.FetchDeletedCharacters()
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "failed to stat deleted character file")
	assert.Empty(t, chars)
}

================
File: internal/persist/eve/deleted_store.go
================
package eve

import (
	"fmt"
	"os"
	"path/filepath"
	"sync"

	"github.com/guarzo/canifly/internal/persist"
	"github.com/guarzo/canifly/internal/services/interfaces"
)

const (
	deletedFileName = "deleted.json"
)

var _ interfaces.DeletedCharactersRepository = (*DeletedStore)(nil)

type DeletedStore struct {
	logger      interfaces.Logger
	fs          persist.FileSystem
	basePath    string
	mu          sync.RWMutex
	cachedChars []string
}

func NewDeletedStore(l interfaces.Logger, fs persist.FileSystem, basePath string) *DeletedStore {
	return &DeletedStore{
		logger:   l,
		fs:       fs,
		basePath: basePath,
	}
}

func (ds *DeletedStore) SaveDeletedCharacters(chars []string) error {
	ds.mu.Lock()
	defer ds.mu.Unlock()

	filename := filepath.Join(ds.basePath, deletedFileName)
	if err := persist.SaveJsonToFile(ds.fs, filename, chars); err != nil {
		ds.logger.WithError(err).Errorf("Failed to save deleted characters to %s", filename)
		return err
	}

	// Update the in-memory cache
	ds.cachedChars = chars
	return nil
}

func (ds *DeletedStore) FetchDeletedCharacters() ([]string, error) {
	ds.mu.RLock()
	// If we have cached data, return a copy directly
	if ds.cachedChars != nil {
		defer ds.mu.RUnlock()
		return ds.copyChars(ds.cachedChars), nil
	}
	ds.mu.RUnlock()

	// If no cached data, load from disk
	ds.mu.Lock()
	defer ds.mu.Unlock()

	// Check again if cachedChars got populated by another goroutine in between locks
	if ds.cachedChars != nil {
		return ds.copyChars(ds.cachedChars), nil
	}

	filename := filepath.Join(ds.basePath, deletedFileName)
	if _, err := ds.fs.Stat(filename); os.IsNotExist(err) {
		// It's not necessarily an error if the file doesn't exist,
		// we can treat it as empty since we now have a cache.
		ds.logger.Infof("Deleted characters file not found: %s", filename)
		ds.cachedChars = []string{}
		return []string{}, nil
	} else if err != nil {
		return []string{}, fmt.Errorf("failed to stat deleted character file: %w", err)
	}

	var chars []string
	if err := persist.ReadJsonFromFile(ds.fs, filename, &chars); err != nil {
		return []string{}, fmt.Errorf("failed to load deleted characters from %s: %w", filename, err)
	}

	// Cache the loaded data
	ds.cachedChars = chars
	return ds.copyChars(chars), nil
}

// copyChars creates a copy of the slice to avoid sharing the underlying array.
func (ds *DeletedStore) copyChars(chars []string) []string {
	cpy := make([]string, len(chars))
	copy(cpy, chars)
	return cpy
}

================
File: internal/persist/eve/eve_profiles_store.go
================
package eve

import (
	"archive/tar"
	"compress/gzip"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"

	"github.com/guarzo/canifly/internal/model"
	"github.com/guarzo/canifly/internal/services/interfaces"
)

// EveProfilesStore manages EVE-specific settings file operations
type EveProfilesStore struct {
	logger interfaces.Logger
}

// NewEveProfilesStore returns a new instance of EveProfilesStore
func NewEveProfilesStore(logger interfaces.Logger) *EveProfilesStore {
	return &EveProfilesStore{
		logger: logger,
	}
}

// ListSettingsFiles returns raw file information for character and user files in the given subDir.
func (e *EveProfilesStore) ListSettingsFiles(subDir, settingsDir string) ([]model.RawFileInfo, error) {
	directory := filepath.Join(settingsDir, subDir)
	entries, err := os.ReadDir(directory)
	if err != nil {
		return nil, err
	}

	var results []model.RawFileInfo
	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}
		file := entry.Name()
		fullPath := filepath.Join(directory, file)

		info, err := os.Stat(fullPath)
		if err != nil {
			continue
		}
		mtime := info.ModTime().Format(time.RFC3339)

		// Check for char file pattern: core_char_<charId>.dat
		if strings.HasPrefix(file, "core_char_") && strings.HasSuffix(file, ".dat") {
			charId := strings.TrimSuffix(strings.TrimPrefix(file, "core_char_"), ".dat")
			if matched, _ := regexp.MatchString(`^\d+$`, charId); matched {
				results = append(results, model.RawFileInfo{
					FileName:     file,
					CharOrUserID: charId,
					IsChar:       true,
					Mtime:        mtime,
				})
			}
		} else if strings.HasPrefix(file, "core_user_") && strings.HasSuffix(file, ".dat") {
			userId := strings.TrimSuffix(strings.TrimPrefix(file, "core_user_"), ".dat")
			if matched, _ := regexp.MatchString(`^\d+$`, userId); matched {
				results = append(results, model.RawFileInfo{
					FileName:     file,
					CharOrUserID: userId,
					IsChar:       false,
					Mtime:        mtime,
				})
			}
		}
	}

	return results, nil
}

// BackupDirectory creates a backup tar.gz of directories under targetDir that start with "settings_"
func (e *EveProfilesStore) BackupDirectory(targetDir, backupDir string) error {
	e.logger.Infof("Starting backup of settings directories from %s to %s", targetDir, backupDir)

	subDirs, err := e.GetSubDirectories(targetDir)
	if err != nil {
		e.logger.Errorf("Failed to get subdirectories from %s: %v", targetDir, err)
		return err
	}

	if len(subDirs) == 0 {
		errMsg := fmt.Sprintf("No settings_ subdirectories found in %s", targetDir)
		e.logger.Warnf(errMsg)
		return fmt.Errorf(errMsg)
	}

	now := time.Now()
	formattedDate := now.Format("2006-01-02_15-04-05")

	backupFileName := fmt.Sprintf("%s_%s.bak.tar.gz", filepath.Base(targetDir), formattedDate)
	backupFilePath := filepath.Join(backupDir, backupFileName)

	e.logger.Infof("Creating backup file at %s", backupFilePath)
	f, err := os.Create(backupFilePath)
	if err != nil {
		e.logger.Errorf("Failed to create backup file %s: %v", backupFilePath, err)
		return err
	}
	defer f.Close()

	gz := gzip.NewWriter(f)
	defer gz.Close()

	tw := tar.NewWriter(gz)
	defer tw.Close()

	for _, dir := range subDirs {
		fullPath := filepath.Join(targetDir, dir)
		e.logger.Infof("Backing up subdirectory: %s", fullPath)
		err = filepath.Walk(fullPath, func(p string, info os.FileInfo, err error) error {
			if err != nil {
				e.logger.Errorf("Error walking through %s: %v", p, err)
				return err
			}
			relPath, _ := filepath.Rel(filepath.Dir(targetDir), p)

			header, err := tar.FileInfoHeader(info, relPath)
			if err != nil {
				e.logger.Errorf("Failed to get FileInfoHeader for %s: %v", p, err)
				return err
			}
			header.Name = relPath

			if err = tw.WriteHeader(header); err != nil {
				e.logger.Errorf("Failed to write tar header for %s: %v", p, err)
				return err
			}

			if !info.IsDir() {
				srcFile, err := os.Open(p)
				if err != nil {
					e.logger.Errorf("Failed to open file %s: %v", p, err)
					return err
				}
				defer srcFile.Close()
				if _, err := io.Copy(tw, srcFile); err != nil {
					e.logger.Errorf("Failed to copy file %s into tar: %v", p, err)
					return err
				}
			}
			return nil
		})
		if err != nil {
			e.logger.Errorf("Error walking subdirectory %s: %v", dir, err)
			return err
		}
	}

	e.logger.Infof("Backup completed successfully: %s", backupFilePath)
	return nil
}

// GetSubDirectories returns subdirs in settingsDir that start with "settings_".
func (e *EveProfilesStore) GetSubDirectories(settingsDir string) ([]string, error) {
	entries, err := os.ReadDir(settingsDir)
	if err != nil {
		e.logger.Errorf("failed to read %s, with error %v", settingsDir, err)
		return nil, err
	}

	var dirs []string
	for _, ent := range entries {
		if ent.IsDir() && strings.HasPrefix(ent.Name(), "settings_") {
			dirs = append(dirs, ent.Name())
		}
	}
	return dirs, nil
}

func (e *EveProfilesStore) SyncSubdirectory(subDir, userId, charId, settingsDir string) (int, int, error) {
	subDirPath := filepath.Join(settingsDir, subDir)
	if _, err := os.Stat(subDirPath); os.IsNotExist(err) {
		return 0, 0, fmt.Errorf("subdirectory does not exist: %s", subDirPath)
	}

	userFileName := "core_user_" + userId + ".dat"
	charFileName := "core_char_" + charId + ".dat"

	userFilePath := filepath.Join(subDirPath, userFileName)
	charFilePath := filepath.Join(subDirPath, charFileName)

	userContent, userErr := os.ReadFile(userFilePath)
	charContent, charErr := os.ReadFile(charFilePath)

	if userErr != nil {
		return 0, 0, fmt.Errorf("failed to read user file %s: %v", userFilePath, userErr)
	}
	if charErr != nil {
		return 0, 0, fmt.Errorf("failed to read char file %s: %v", charFilePath, charErr)
	}

	return e.applyContentToSubDir(subDirPath, userFileName, charFileName, userContent, charContent)
}

func (e *EveProfilesStore) SyncAllSubdirectories(baseSubDir, userId, charId, settingsDir string) (int, int, error) {
	e.logger.Infof("Starting SyncAllSubdirectories with baseSubDir=%s, userId=%s, charId=%s", baseSubDir, userId, charId)

	baseSubDirPath := filepath.Join(settingsDir, baseSubDir)
	if _, err := os.Stat(baseSubDirPath); os.IsNotExist(err) {
		e.logger.Errorf("Base subdirectory does not exist: %s", baseSubDirPath)
		return 0, 0, fmt.Errorf("base subdirectory does not exist: %s", baseSubDirPath)
	}

	userFileName := "core_user_" + userId + ".dat"
	charFileName := "core_char_" + charId + ".dat"
	userFilePath := filepath.Join(baseSubDirPath, userFileName)
	charFilePath := filepath.Join(baseSubDirPath, charFileName)

	e.logger.Infof("Reading user file: %s", userFilePath)
	userContent, userErr := os.ReadFile(userFilePath)
	if userErr != nil {
		e.logger.Errorf("Failed to read user file %s: %v", userFilePath, userErr)
		return 0, 0, fmt.Errorf("failed to read user file %s: %v", userFilePath, userErr)
	}

	e.logger.Infof("Reading character file: %s", charFilePath)
	charContent, charErr := os.ReadFile(charFilePath)
	if charErr != nil {
		e.logger.Errorf("Failed to read char file %s: %v", charFilePath, charErr)
		return 0, 0, fmt.Errorf("failed to read char file %s: %v", charFilePath, charErr)
	}

	e.logger.Infof("Retrieving all settings_ subdirectories from %s", settingsDir)
	subDirs, err := e.GetSubDirectories(settingsDir)
	if err != nil {
		e.logger.Errorf("Failed to get subdirectories from %s: %v", settingsDir, err)
		return 0, 0, fmt.Errorf("failed to get subdirectories: %v", err)
	}

	totalUserCopied := 0
	totalCharCopied := 0

	for _, otherSubDir := range subDirs {
		if otherSubDir == baseSubDir {
			continue
		}
		e.logger.Infof("Applying content to subdir: %s", otherSubDir)
		otherSubDirPath := filepath.Join(settingsDir, otherSubDir)
		uCopied, cCopied, err := e.applyContentToSubDir(otherSubDirPath, userFileName, charFileName, userContent, charContent)
		if err != nil {
			e.logger.Warnf("Error applying content to subdir %s: %v", otherSubDir, err)
			continue
		}
		e.logger.Infof("Successfully applied content to %s: %d user files, %d char files copied.", otherSubDir, uCopied, cCopied)
		totalUserCopied += uCopied
		totalCharCopied += cCopied
	}

	e.logger.Infof("SyncAllSubdirectories complete: %d total user files, %d total char files copied.", totalUserCopied, totalCharCopied)
	return totalUserCopied, totalCharCopied, nil
}

func (e *EveProfilesStore) applyContentToSubDir(
	dirPath string,
	userFileName string,
	charFileName string,
	userContent []byte,
	charContent []byte,
) (int, int, error) {
	entries, err := os.ReadDir(dirPath)
	if err != nil {
		return 0, 0, err
	}

	userFilesCopied := 0
	charFilesCopied := 0

	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}
		fName := entry.Name()
		fPath := filepath.Join(dirPath, fName)

		if strings.HasPrefix(fName, "core_user_") && strings.HasSuffix(fName, ".dat") && fName != userFileName && userContent != nil {
			if err := os.WriteFile(fPath, userContent, 0644); err == nil {
				userFilesCopied++
			} else {
				e.logger.Warnf("Failed to write user file %s: %v", fPath, err)
			}
		}

		if strings.HasPrefix(fName, "core_char_") && strings.HasSuffix(fName, ".dat") && fName != charFileName && charContent != nil {
			if err := os.WriteFile(fPath, charContent, 0644); err == nil {
				charFilesCopied++
			} else {
				e.logger.Warnf("Failed to write char file %s: %v", fPath, err)
			}
		}
	}

	return userFilesCopied, charFilesCopied, nil
}

================
File: internal/persist/eve/eve_profiles_test.go
================
package eve_test

import (
	"archive/tar"
	"compress/gzip"
	"github.com/guarzo/canifly/internal/persist/eve"
	"github.com/guarzo/canifly/internal/testutil"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"io"
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestEveProfilesStore_ListSettingsFiles(t *testing.T) {
	logger := &testutil.MockLogger{}
	store := eve.NewEveProfilesStore(logger)

	baseDir := t.TempDir()
	subDir := "profile1"
	settingsDir := filepath.Join(baseDir, subDir)
	require.NoError(t, os.MkdirAll(settingsDir, 0755))

	// Create some files
	// Valid char file
	charFile := filepath.Join(settingsDir, "core_char_12345.dat")
	require.NoError(t, os.WriteFile(charFile, []byte("char"), 0644))

	// Valid user file
	userFile := filepath.Join(settingsDir, "core_user_6789.dat")
	require.NoError(t, os.WriteFile(userFile, []byte("user"), 0644))

	// Invalid files
	require.NoError(t, os.WriteFile(filepath.Join(settingsDir, "core_char_invalid.dat"), []byte{}, 0644))
	require.NoError(t, os.WriteFile(filepath.Join(settingsDir, "core_user_abc.dat"), []byte{}, 0644))
	require.NoError(t, os.WriteFile(filepath.Join(settingsDir, "some_other_file.txt"), []byte{}, 0644))

	results, err := store.ListSettingsFiles(subDir, baseDir)
	assert.NoError(t, err)
	assert.Len(t, results, 2) // Only the valid char and user files

	// Check details
	var charFound, userFound bool
	for _, r := range results {
		if r.IsChar && r.CharOrUserID == "12345" {
			charFound = true
		}
		if !r.IsChar && r.CharOrUserID == "6789" {
			userFound = true
		}
	}

	assert.True(t, charFound)
	assert.True(t, userFound)
}

func TestEveProfilesStore_GetSubDirectories(t *testing.T) {
	logger := &testutil.MockLogger{}
	store := eve.NewEveProfilesStore(logger)

	baseDir := t.TempDir()

	// Create some dirs
	require.NoError(t, os.MkdirAll(filepath.Join(baseDir, "settings_alpha"), 0755))
	require.NoError(t, os.MkdirAll(filepath.Join(baseDir, "settings_beta"), 0755))
	require.NoError(t, os.MkdirAll(filepath.Join(baseDir, "normaldir"), 0755))

	dirs, err := store.GetSubDirectories(baseDir)
	assert.NoError(t, err)
	assert.Len(t, dirs, 2)
	assert.Contains(t, dirs, "settings_alpha")
	assert.Contains(t, dirs, "settings_beta")
}

func TestEveProfilesStore_BackupDirectory(t *testing.T) {
	logger := &testutil.MockLogger{}
	store := eve.NewEveProfilesStore(logger)

	targetDir := t.TempDir()
	backupDir := t.TempDir()

	// No settings_ dir initially
	err := store.BackupDirectory(targetDir, backupDir)
	assert.Error(t, err)

	// Create some settings_ dirs and files
	dir1 := filepath.Join(targetDir, "settings_1")
	dir2 := filepath.Join(targetDir, "settings_2")

	require.NoError(t, os.MkdirAll(dir1, 0755))
	require.NoError(t, os.MkdirAll(dir2, 0755))
	require.NoError(t, os.WriteFile(filepath.Join(dir1, "file1.txt"), []byte("content1"), 0644))
	require.NoError(t, os.WriteFile(filepath.Join(dir2, "file2.txt"), []byte("content2"), 0644))

	err = store.BackupDirectory(targetDir, backupDir)
	assert.NoError(t, err)

	// Check that a .tar.gz file was created
	files, err := os.ReadDir(backupDir)
	assert.NoError(t, err)
	assert.Len(t, files, 1)
	backupFile := filepath.Join(backupDir, files[0].Name())
	assert.FileExists(t, backupFile)
	assert.True(t, strings.HasSuffix(files[0].Name(), ".bak.tar.gz"))

	// (Optional) Check tar contents if desired
	f, err := os.Open(backupFile)
	require.NoError(t, err)
	defer f.Close()
	gz, err := gzip.NewReader(f)
	require.NoError(t, err)
	defer gz.Close()
	tr := tar.NewReader(gz)

	var foundFile1, foundFile2 bool
	for {
		hdr, err := tr.Next()
		if err == io.EOF {
			break
		}
		require.NoError(t, err)
		if filepath.Base(hdr.Name) == "file1.txt" {
			foundFile1 = true
		}
		if filepath.Base(hdr.Name) == "file2.txt" {
			foundFile2 = true
		}
	}
	assert.True(t, foundFile1)
	assert.True(t, foundFile2)
}

func TestEveProfilesStore_SyncSubdirectory(t *testing.T) {
	logger := &testutil.MockLogger{}
	store := eve.NewEveProfilesStore(logger)

	settingsDir := t.TempDir()
	subDir := "settings_base"
	subDirPath := filepath.Join(settingsDir, subDir)
	require.NoError(t, os.MkdirAll(subDirPath, 0755))

	userId := "111"
	charId := "222"
	userFileName := "core_user_111.dat"
	charFileName := "core_char_222.dat"

	// Create the required user and char files
	require.NoError(t, os.WriteFile(filepath.Join(subDirPath, userFileName), []byte("userdata"), 0644))
	require.NoError(t, os.WriteFile(filepath.Join(subDirPath, charFileName), []byte("chardata"), 0644))

	// Create another char/user file that should be replaced
	require.NoError(t, os.WriteFile(filepath.Join(subDirPath, "core_user_333.dat"), []byte("olduser"), 0644))
	require.NoError(t, os.WriteFile(filepath.Join(subDirPath, "core_char_444.dat"), []byte("oldchar"), 0644))

	userCopied, charCopied, err := store.SyncSubdirectory(subDir, userId, charId, settingsDir)
	assert.NoError(t, err)
	assert.Equal(t, 1, userCopied) // only one user file replaced
	assert.Equal(t, 1, charCopied) // only one char file replaced

	// Check that the replaced files now contain the "userdata" and "chardata"
	replacedUserData, err := os.ReadFile(filepath.Join(subDirPath, "core_user_333.dat"))
	require.NoError(t, err)
	assert.Equal(t, []byte("userdata"), replacedUserData)

	replacedCharData, err := os.ReadFile(filepath.Join(subDirPath, "core_char_444.dat"))
	require.NoError(t, err)
	assert.Equal(t, []byte("chardata"), replacedCharData)
}

func TestEveProfilesStore_SyncAllSubdirectories(t *testing.T) {
	logger := &testutil.MockLogger{}
	store := eve.NewEveProfilesStore(logger)

	settingsDir := t.TempDir()

	baseSubDir := "settings_base"
	baseSubDirPath := filepath.Join(settingsDir, baseSubDir)
	require.NoError(t, os.MkdirAll(baseSubDirPath, 0755))

	otherSubDir := "settings_other"
	otherSubDirPath := filepath.Join(settingsDir, otherSubDir)
	require.NoError(t, os.MkdirAll(otherSubDirPath, 0755))

	userId := "999"
	charId := "888"
	baseUserFile := "core_user_999.dat"
	baseCharFile := "core_char_888.dat"

	// Create base files
	require.NoError(t, os.WriteFile(filepath.Join(baseSubDirPath, baseUserFile), []byte("masterUser"), 0644))
	require.NoError(t, os.WriteFile(filepath.Join(baseSubDirPath, baseCharFile), []byte("masterChar"), 0644))

	// In the other directory, create files that should be replaced
	require.NoError(t, os.WriteFile(filepath.Join(otherSubDirPath, "core_user_777.dat"), []byte("oldUserData"), 0644))
	require.NoError(t, os.WriteFile(filepath.Join(otherSubDirPath, "core_char_666.dat"), []byte("oldCharData"), 0644))

	userCopied, charCopied, err := store.SyncAllSubdirectories(baseSubDir, userId, charId, settingsDir)
	assert.NoError(t, err)
	// Should update one user and one char file in the 'otherSubDir'
	assert.Equal(t, 1, userCopied)
	assert.Equal(t, 1, charCopied)

	// Check updated content
	newUserData, err := os.ReadFile(filepath.Join(otherSubDirPath, "core_user_777.dat"))
	require.NoError(t, err)
	assert.Equal(t, []byte("masterUser"), newUserData)

	newCharData, err := os.ReadFile(filepath.Join(otherSubDirPath, "core_char_666.dat"))
	require.NoError(t, err)
	assert.Equal(t, []byte("masterChar"), newCharData)
}

func TestEveProfilesStore_SubdirNotExist(t *testing.T) {
	logger := &testutil.MockLogger{}
	store := eve.NewEveProfilesStore(logger)

	settingsDir := t.TempDir()

	_, _, err := store.SyncSubdirectory("missing_subdir", "u", "c", settingsDir)
	assert.Error(t, err)

	_, _, err = store.SyncAllSubdirectories("missing_base", "u", "c", settingsDir)
	assert.Error(t, err)
}

func TestEveProfilesStore_ReadFilesError(t *testing.T) {
	logger := &testutil.MockLogger{}
	store := eve.NewEveProfilesStore(logger)

	settingsDir := t.TempDir()
	baseSubDir := "settings_base"
	baseSubDirPath := filepath.Join(settingsDir, baseSubDir)
	require.NoError(t, os.MkdirAll(baseSubDirPath, 0755))

	userId := "999"
	charId := "888"
	// We do not create the user and char files, so reading them should fail
	_, _, err := store.SyncSubdirectory(baseSubDir, userId, charId, settingsDir)
	assert.Error(t, err)

	// For SyncAllSubdirectories, also should fail if base files don't exist
	_, _, err = store.SyncAllSubdirectories(baseSubDir, userId, charId, settingsDir)
	assert.Error(t, err)
}

================
File: internal/persist/eve/skill_store_test.go
================
package eve_test

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/guarzo/canifly/internal/model"
	"github.com/guarzo/canifly/internal/persist"
	"github.com/guarzo/canifly/internal/persist/eve"
	"github.com/guarzo/canifly/internal/testutil"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestSkillStore_SaveAndDeleteSkillPlan(t *testing.T) {
	logger := &testutil.MockLogger{}
	fs := persist.OSFileSystem{}
	basePath := t.TempDir()

	store := eve.NewSkillStore(logger, fs, basePath)

	// Ensure the plans directory exists
	require.NoError(t, store.LoadSkillPlans())

	skills := map[string]model.Skill{
		"Gunnery":  {Name: "Gunnery", Level: 5},
		"Missiles": {Name: "Missiles", Level: 3},
	}

	err := store.SaveSkillPlan("myplan", skills)
	assert.NoError(t, err, "Saving skill plan should succeed")

	planFile := filepath.Join(basePath, "plans", "myplan.txt")
	assert.FileExists(t, planFile, "Plan file should exist")

	// Now delete it
	err = store.DeleteSkillPlan("myplan")
	assert.NoError(t, err, "Deleting skill plan should succeed")
	assert.NoFileExists(t, planFile, "Plan file should be deleted")
}

func TestSkillStore_GetSkillPlanFile(t *testing.T) {
	logger := &testutil.MockLogger{}
	fs := persist.OSFileSystem{}
	basePath := t.TempDir()

	store := eve.NewSkillStore(logger, fs, basePath)

	// Ensure the plans directory is created
	require.NoError(t, store.LoadSkillPlans())

	skills := map[string]model.Skill{
		"Engineering": {Name: "Engineering", Level: 4},
	}
	err := store.SaveSkillPlan("engineering_plan", skills)
	require.NoError(t, err)

	data, err := store.GetSkillPlanFile("engineering_plan")
	assert.NoError(t, err)
	content := string(data)
	assert.Contains(t, content, "Engineering 4")
}

func TestSkillStore_GetSkillPlans(t *testing.T) {
	logger := &testutil.MockLogger{}
	fs := persist.OSFileSystem{}
	basePath := t.TempDir()

	store := eve.NewSkillStore(logger, fs, basePath)

	// Initially empty
	plans := store.GetSkillPlans()
	assert.Empty(t, plans)

	// Manually create the plans directory so we can save a plan
	plansDir := filepath.Join(basePath, "plans")
	require.NoError(t, os.MkdirAll(plansDir, 0755), "Failed to create plans directory")

	// Save a plan
	skills := map[string]model.Skill{"Drones": {Name: "Drones", Level: 2}}
	err := store.SaveSkillPlan("drones_plan", skills)
	require.NoError(t, err)

	// Now GetSkillPlans should return exactly one
	plans = store.GetSkillPlans()
	assert.Len(t, plans, 1, "Expected exactly one plan")
	assert.Equal(t, "drones_plan", plans["drones_plan"].Name)
	assert.Equal(t, 2, plans["drones_plan"].Skills["Drones"].Level)
}

// The following tests assume that `static/plans` and `static/invTypes.csv`
// contain some test data. If they don't, you may skip these tests or mock the embed.

func TestSkillStore_LoadSkillPlans(t *testing.T) {
	// This test requires that you have some embedded plans in `static/plans`.
	// If no embedded data, skip this test.
	if os.Getenv("NO_EMBEDDED_TEST") == "1" {
		t.Skip("Skipping test because no embedded files available")
	}

	logger := &testutil.MockLogger{}
	fs := persist.OSFileSystem{}
	basePath := t.TempDir()

	store := eve.NewSkillStore(logger, fs, basePath)
	err := store.LoadSkillPlans()
	assert.NoError(t, err)

	plans := store.GetSkillPlans()
	// We can't know exactly what plans are embedded, but we can check it's not empty.
	// If you know there's a "sample_plan.txt" embedded, check for it:
	// assert.Contains(t, plans, "sample_plan")

	assert.NotEmpty(t, plans)
}

func TestSkillStore_LoadSkillTypes(t *testing.T) {
	// This test requires `static/invTypes.csv` in the embedded files.
	if os.Getenv("NO_EMBEDDED_TEST") == "1" {
		t.Skip("Skipping test because no embedded files available")
	}

	logger := &testutil.MockLogger{}
	fs := persist.OSFileSystem{}
	basePath := t.TempDir()

	store := eve.NewSkillStore(logger, fs, basePath)
	err := store.LoadSkillTypes()
	assert.NoError(t, err)

	types := store.GetSkillTypes()
	assert.NotEmpty(t, types)

	// If you know a particular skill type that should be in the CSV, assert it:
	// assert.Contains(t, types, "SomeSkillTypeName")
}

func TestSkillStore_GetSkillTypeByID(t *testing.T) {
	if os.Getenv("NO_EMBEDDED_TEST") == "1" {
		t.Skip("Skipping test because no embedded files available")
	}

	logger := &testutil.MockLogger{}
	fs := persist.OSFileSystem{}
	basePath := t.TempDir()

	store := eve.NewSkillStore(logger, fs, basePath)
	err := store.LoadSkillTypes()
	require.NoError(t, err)

	// Pick an ID you believe wont exist. Let's try "999999"
	_, found := store.GetSkillTypeByID("999999")
	assert.False(t, found, "ID 999999 should not be found in skill types")
}

================
File: internal/persist/eve/skill_store.go
================
package eve

import (
	"bufio"
	"encoding/json"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"sync"

	"github.com/guarzo/canifly/internal/embed"
	"github.com/guarzo/canifly/internal/model"
	"github.com/guarzo/canifly/internal/persist"
	"github.com/guarzo/canifly/internal/services/interfaces"
)

var _ interfaces.SkillRepository = (*SkillStore)(nil)

const (
	plansDir      = "plans"
	skillTypeFile = "static/invTypes.csv"
)

// SkillStore implements interfaces.SkillRepository
type SkillStore struct {
	logger        interfaces.Logger
	fs            persist.FileSystem
	basePath      string
	skillPlans    map[string]model.SkillPlan
	skillTypes    map[string]model.SkillType
	skillIdToType map[string]model.SkillType
	mut           sync.RWMutex
}

// NewSkillStore now accepts a FileSystem and a basePath for writable directories.
func NewSkillStore(logger interfaces.Logger, fs persist.FileSystem, basePath string) *SkillStore {
	return &SkillStore{
		logger:     logger,
		fs:         fs,
		basePath:   basePath,
		skillPlans: make(map[string]model.SkillPlan),
		skillTypes: make(map[string]model.SkillType),
	}
}

func (s *SkillStore) LoadSkillPlans() error {
	s.logger.Infof("load skill plans")

	writableDir := filepath.Join(s.basePath, plansDir)
	if err := s.fs.MkdirAll(writableDir, os.ModePerm); err != nil {
		return fmt.Errorf("failed to ensure plans directory: %w", err)
	}

	// Copy embedded plans if needed
	if err := s.copyEmbeddedPlansToWritable(writableDir); err != nil {
		return fmt.Errorf("failed to copy embedded plans: %w", err)
	}

	plans, err := s.loadSkillPlans(writableDir)
	if err != nil {
		return fmt.Errorf("failed to load eve plans: %w", err)
	}

	s.mut.Lock()
	s.skillPlans = plans
	s.mut.Unlock()

	s.logger.Debugf("Loaded %d eve plans", len(plans))
	return nil
}

func (s *SkillStore) SaveSkillPlan(planName string, skills map[string]model.Skill) error {
	if len(skills) == 0 {
		return fmt.Errorf("cannot save an empty eve plan for planName: %s", planName)
	}

	planFilePath := filepath.Join(s.basePath, plansDir, planName+".txt")

	var sb strings.Builder
	for skillName, skill := range skills {
		sb.WriteString(fmt.Sprintf("%s %d\n", skillName, skill.Level))
	}

	if err := s.fs.WriteFile(planFilePath, []byte(sb.String()), 0644); err != nil {
		return fmt.Errorf("failed to write plan file: %w", err)
	}

	planKey := planName
	s.mut.Lock()
	s.skillPlans[planKey] = model.SkillPlan{Name: planKey, Skills: skills}
	s.mut.Unlock()
	s.logger.Infof("Saved eve plan %s with %d skills", planKey, len(skills))
	return nil
}

func (s *SkillStore) GetSkillPlans() map[string]model.SkillPlan {
	s.mut.RLock()
	defer s.mut.RUnlock()

	// Return a copy if needed, or the original if safe
	plansCopy := make(map[string]model.SkillPlan, len(s.skillPlans))
	for k, v := range s.skillPlans {
		plansCopy[k] = v
	}
	return plansCopy
}

func (s *SkillStore) GetSkillPlanFile(planName string) ([]byte, error) {
	planName += ".txt"
	s.logger.Infof("Attempting to serve eve plan file: %s", planName)

	skillPlanDir := filepath.Join(s.basePath, plansDir)

	filePath := filepath.Join(skillPlanDir, planName)
	return os.ReadFile(filePath)
}

func (s *SkillStore) copyEmbeddedFile(srcPath, destPath string) error {
	srcFile, err := embed.StaticFiles.Open(srcPath)
	if err != nil {
		return fmt.Errorf("failed to open embedded file %s: %w", srcPath, err)
	}
	defer srcFile.Close()

	data, err := io.ReadAll(srcFile)
	if err != nil {
		return fmt.Errorf("failed to read embedded file %s: %w", srcPath, err)
	}

	dir := filepath.Dir(destPath)
	if err := s.fs.MkdirAll(dir, os.ModePerm); err != nil {
		return fmt.Errorf("failed to create directory for %s: %w", destPath, err)
	}

	if err := s.fs.WriteFile(destPath, data, 0644); err != nil {
		return fmt.Errorf("failed to write file %s: %w", destPath, err)
	}
	return nil
}

func (s *SkillStore) loadSkillPlans(dir string) (map[string]model.SkillPlan, error) {
	plans := make(map[string]model.SkillPlan)

	// We need to list files in dir. Since we're using fs abstraction for reading,
	// we might still rely on os.ReadDir if fs does not provide a listing method.
	// If needed, extend FileSystem or handle that logic outside.
	entries, err := os.ReadDir(dir)
	if err != nil {
		return nil, fmt.Errorf("failed to read eve plans directory: %w", err)
	}

	for _, entry := range entries {
		if entry.IsDir() || !strings.HasSuffix(entry.Name(), ".txt") {
			continue
		}

		planName := strings.TrimSuffix(entry.Name(), ".txt")
		path := filepath.Join(dir, entry.Name())

		skills, err := s.readSkillsFromFile(path)
		if err != nil {
			return nil, fmt.Errorf("failed to read skills from %s: %w", path, err)
		}
		plans[planName] = model.SkillPlan{Name: planName, Skills: skills}
	}

	return plans, nil
}

func (s *SkillStore) readSkillsFromFile(filePath string) (map[string]model.Skill, error) {
	data, err := s.fs.ReadFile(filePath)
	if err != nil {
		return nil, fmt.Errorf("failed to read eve plan file %s: %w", filePath, err)
	}

	skills := make(map[string]model.Skill)
	scanner := bufio.NewScanner(strings.NewReader(string(data)))
	lineNumber := 0
	for scanner.Scan() {
		lineNumber++
		line := scanner.Text()
		if strings.TrimSpace(line) == "" {
			continue
		}

		parts := strings.Fields(line)
		if len(parts) < 2 {
			return nil, fmt.Errorf("invalid format in file %s at line %d: %s", filePath, lineNumber, line)
		}

		skillLevelStr := parts[len(parts)-1]
		skillName := strings.Join(parts[:len(parts)-1], " ")
		skillLevel, err := strconv.Atoi(skillLevelStr)
		if err != nil {
			return nil, fmt.Errorf("invalid eve level in %s at line %d: %s", filePath, lineNumber, skillLevelStr)
		}

		if currentSkill, exists := skills[skillName]; !exists || skillLevel > currentSkill.Level {
			skills[skillName] = model.Skill{Name: skillName, Level: skillLevel}
		}
	}
	if err := scanner.Err(); err != nil {
		return nil, fmt.Errorf("error scanning file %s: %w", filePath, err)
	}

	s.logger.Debugf("Read %d skills from %s", len(skills), filePath)
	return skills, nil
}

func (s *SkillStore) LoadSkillTypes() error {
	s.logger.Infof("load skill types")
	file, err := embed.StaticFiles.Open(skillTypeFile)
	if err != nil {
		return fmt.Errorf("failed to open eve type file %s: %w", skillTypeFile, err)
	}
	defer file.Close()

	records, err := persist.ReadCsvRecords(file)
	if err != nil {
		return fmt.Errorf("failed to read CSV records from %s: %w", skillTypeFile, err)
	}

	skillTypes, skillIDTypes, err := s.parseSkillTypes(records)
	if err != nil {
		return fmt.Errorf("failed to parse eve types: %w", err)
	}

	s.mut.Lock()
	s.skillTypes = skillTypes
	s.skillIdToType = skillIDTypes
	s.mut.Unlock()

	s.logger.Debugf("Loaded %d eve types", len(skillTypes))
	return nil
}

func (s *SkillStore) parseSkillTypes(records [][]string) (map[string]model.SkillType, map[string]model.SkillType, error) {
	if len(records) == 0 {
		return nil, nil, fmt.Errorf("no data in eve type file")
	}

	headers := records[0]
	records = records[1:] // skip header

	colIndices := map[string]int{"typeID": -1, "typeName": -1, "description": -1}
	for i, header := range headers {
		switch strings.TrimSpace(header) {
		case "typeID":
			colIndices["typeID"] = i
		case "typeName":
			colIndices["typeName"] = i
		case "description":
			colIndices["description"] = i
		}
	}

	if colIndices["typeID"] == -1 || colIndices["typeName"] == -1 {
		return nil, nil, fmt.Errorf("required columns (typeID, typeName) are missing")
	}

	skillTypes := make(map[string]model.SkillType)
	skillIDTypes := make(map[string]model.SkillType)

	lineNumber := 1
	for _, row := range records {
		lineNumber++
		if len(row) < 2 {
			s.logger.Warnf("Skipping malformed row %d in eve types", lineNumber)
			continue
		}

		typeID := strings.TrimSpace(row[colIndices["typeID"]])
		typeName := strings.TrimSpace(row[colIndices["typeName"]])

		if typeName == "" {
			continue
		}

		desc := ""
		if di := colIndices["description"]; di != -1 && di < len(row) {
			desc = strings.TrimSpace(row[di])
		}

		st := model.SkillType{
			TypeID:      typeID,
			TypeName:    typeName,
			Description: desc,
		}

		skillTypes[typeName] = st
		skillIDTypes[typeID] = st
	}

	return skillTypes, skillIDTypes, nil
}

func (s *SkillStore) GetSkillTypes() map[string]model.SkillType {
	s.mut.RLock()
	defer s.mut.RUnlock()
	// return a copy if needed
	cpy := make(map[string]model.SkillType, len(s.skillTypes))
	for k, v := range s.skillTypes {
		cpy[k] = v
	}
	return cpy
}

func (s *SkillStore) GetSkillTypeByID(id string) (model.SkillType, bool) {
	s.mut.RLock()
	defer s.mut.RUnlock()
	st, ok := s.skillIdToType[id]
	return st, ok
}

// A helper function to load deleted embedded plans from a JSON or text file
func (s *SkillStore) loadDeletedEmbeddedPlans() (map[string]bool, error) {
	deletedPlans := make(map[string]bool)
	deletedListPath := filepath.Join(s.basePath, plansDir, "deleted_embedded_plans.json")

	if _, err := os.Stat(deletedListPath); os.IsNotExist(err) {
		// No file, so no deleted plans
		return deletedPlans, nil
	}

	data, err := s.fs.ReadFile(deletedListPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read deleted embedded plans: %w", err)
	}

	// Suppose we store them as a simple JSON array of plan names
	var planNames []string
	if err := json.Unmarshal(data, &planNames); err != nil {
		return nil, fmt.Errorf("failed to parse deleted embedded plans: %w", err)
	}
	for _, name := range planNames {
		deletedPlans[name] = true
	}
	return deletedPlans, nil
}

func (s *SkillStore) saveDeletedEmbeddedPlans(deletedPlans map[string]bool) error {
	planNames := make([]string, 0, len(deletedPlans))
	for name := range deletedPlans {
		planNames = append(planNames, name)
	}
	data, err := json.MarshalIndent(planNames, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal deleted embedded plans: %w", err)
	}

	deletedListPath := filepath.Join(s.basePath, plansDir, "deleted_embedded_plans.json")
	if err := s.fs.WriteFile(deletedListPath, data, 0644); err != nil {
		return fmt.Errorf("failed to write deleted embedded plans file: %w", err)
	}
	return nil
}

// Enhance copyEmbeddedPlansToWritable to skip deleted plans
func (s *SkillStore) copyEmbeddedPlansToWritable(writableDir string) error {
	deletedPlans, err := s.loadDeletedEmbeddedPlans()
	if err != nil {
		return err
	}

	entries, err := embed.StaticFiles.ReadDir("static/plans")
	if err != nil {
		return fmt.Errorf("failed to read embedded plans: %w", err)
	}

	for _, entry := range entries {
		if !entry.IsDir() {
			fileName := entry.Name()
			planName := strings.TrimSuffix(fileName, ".txt")

			// If the user previously deleted this embedded plan, skip copying it
			if deletedPlans[planName] {
				s.logger.Debugf("Skipping previously deleted embedded plan: %s", planName)
				continue
			}

			destPath := filepath.Join(writableDir, fileName)
			// Only copy if file does not exist to avoid overwriting custom user changes
			if _, err := s.fs.Stat(destPath); os.IsNotExist(err) {
				if err := s.copyEmbeddedFile("static/plans/"+fileName, destPath); err != nil {
					return fmt.Errorf("failed to copy embedded plan %s: %w", fileName, err)
				}
			}
		}
	}
	return nil
}

// Modify DeleteSkillPlan to record deletions of embedded plans
func (s *SkillStore) DeleteSkillPlan(planName string) error {
	planFilePath := filepath.Join(s.basePath, plansDir, planName+".txt")

	if err := s.fs.Remove(planFilePath); err != nil {
		if os.IsNotExist(err) {
			s.logger.Warnf("Skill plan %s does not exist", planName)
			return fmt.Errorf("eve plan does not exist: %w", err)
		}
		return fmt.Errorf("failed to delete eve plan file: %w", err)
	}

	// If this plan was embedded originally, add it to the deleted list
	// One way is to check if it matches an embedded plan name
	// For a robust solution, store the original embedded plan list somewhere.
	// Here, we read from embed and check if planName was one of them.
	entries, err := embed.StaticFiles.ReadDir("static/plans")
	if err == nil {
		embeddedPlan := false
		for _, entry := range entries {
			if !entry.IsDir() && strings.TrimSuffix(entry.Name(), ".txt") == planName {
				embeddedPlan = true
				break
			}
		}
		if embeddedPlan {
			deletedPlans, err := s.loadDeletedEmbeddedPlans()
			if err != nil {
				return err
			}
			deletedPlans[planName] = true
			if err := s.saveDeletedEmbeddedPlans(deletedPlans); err != nil {
				return err
			}
		}
	}

	s.mut.Lock()
	delete(s.skillPlans, planName)
	s.mut.Unlock()

	s.logger.Infof("Deleted eve plan %s", planName)
	return nil
}

================
File: internal/persist/eve/system_store.go
================
package eve

import (
	"fmt"
	"strconv"

	"github.com/guarzo/canifly/internal/embed"
	"github.com/guarzo/canifly/internal/persist"
	"github.com/guarzo/canifly/internal/services/interfaces"
)

var _ interfaces.SystemRepository = (*SystemStore)(nil)

// SystemStore implements interfaces.SystemRepository
type SystemStore struct {
	logger      interfaces.Logger
	sysIdToName map[int64]string
	sysNameToId map[string]int64
}

// NewSystemStore creates a new SystemStore.
// We still read from embedded files directly here since it's static data.
func NewSystemStore(logger interfaces.Logger) *SystemStore {
	return &SystemStore{
		logger:      logger,
		sysIdToName: make(map[int64]string),
		sysNameToId: make(map[string]int64),
	}
}

func (sys *SystemStore) LoadSystems() error {
	sys.logger.Infof("load systems")
	file, err := embed.StaticFiles.Open("static/systems.csv")
	if err != nil {
		return fmt.Errorf("failed to read systems file: %w", err)
	}
	defer file.Close()

	records, err := persist.ReadCsvRecords(file)
	if err != nil {
		return fmt.Errorf("error reading systems CSV: %w", err)
	}

	// Parse records into the maps
	if err := sys.parseSystemRecords(records); err != nil {
		return fmt.Errorf("failed to parse system records: %w", err)
	}

	sys.logger.Debugf("Loaded %d systems", len(sys.sysIdToName))
	return nil
}

func (sys *SystemStore) parseSystemRecords(records [][]string) error {
	lineNumber := 0
	for _, record := range records {
		lineNumber++
		if len(record) < 2 {
			sys.logger.Warnf("Skipping line %d: not enough columns", lineNumber)
			continue
		}

		sysIDStr := record[0]
		sysName := record[1]

		sysID, err := strconv.ParseInt(sysIDStr, 10, 64)
		if err != nil {
			sys.logger.Warnf("Invalid system ID at line %d: %v", lineNumber, err)
			continue
		}

		sys.sysIdToName[sysID] = sysName
		sys.sysNameToId[sysName] = sysID
	}
	return nil
}

// GetSystemName returns the system name for a given ID.
func (sys *SystemStore) GetSystemName(systemID int64) string {
	name, ok := sys.sysIdToName[systemID]
	if !ok {
		// Not found is not necessarily an error, just return ""
		return ""
	}
	return name
}

================
File: internal/persist/crypto_test.go
================
package persist_test

import (
	"path/filepath"
	"testing"

	"github.com/guarzo/canifly/internal/persist"
	"github.com/stretchr/testify/assert"
)

func TestInitialize(t *testing.T) {
	// Invalid key length
	err := persist.Initialize([]byte("short"))
	assert.Error(t, err, "Should fail with invalid key length")

	// Valid 16-byte key
	key16 := make([]byte, 16)
	err = persist.Initialize(key16)
	assert.NoError(t, err, "Should succeed with 16-byte key")

	// Valid 24-byte key
	key24 := make([]byte, 24)
	err = persist.Initialize(key24)
	assert.NoError(t, err, "Should succeed with 24-byte key")

	// Valid 32-byte key
	key32 := make([]byte, 32)
	err = persist.Initialize(key32)
	assert.NoError(t, err, "Should succeed with 32-byte key")
}

func TestEncryptDecryptData(t *testing.T) {
	// Initialize with a 32-byte key
	key := make([]byte, 32)
	err := persist.Initialize(key)
	assert.NoError(t, err)

	type TestData struct {
		Name  string
		Value int
	}

	inputData := TestData{
		Name:  "example",
		Value: 42,
	}

	tempDir := t.TempDir()
	filePath := filepath.Join(tempDir, "encrypted_data.bin")

	// Encrypt data
	err = persist.EncryptData(inputData, filePath)
	assert.NoError(t, err, "Encryption should succeed")

	// Decrypt data
	var outputData TestData
	err = persist.DecryptData(filePath, &outputData)
	assert.NoError(t, err, "Decryption should succeed")

	assert.Equal(t, inputData.Name, outputData.Name)
	assert.Equal(t, inputData.Value, outputData.Value)
}

func TestEncryptDecryptData_NoKey(t *testing.T) {
	persist.ResetKeyForTest()
	type TestData struct{ Foo string }
	data := TestData{Foo: "bar"}

	tempDir := t.TempDir()
	filePath := filepath.Join(tempDir, "no_key.bin")

	// Attempting to EncryptData without initializing key should fail
	err := persist.EncryptData(data, filePath)
	assert.Error(t, err)

	err = persist.DecryptData(filePath, &data)
	assert.Error(t, err)
}

func TestEncryptDecryptString(t *testing.T) {
	key := make([]byte, 32)
	err := persist.Initialize(key)
	assert.NoError(t, err)

	plaintext := "Hello, World!"
	encrypted, err := persist.EncryptString(plaintext)
	assert.NoError(t, err)
	assert.NotEmpty(t, encrypted)

	decrypted, err := persist.DecryptString(encrypted)
	assert.NoError(t, err)
	assert.Equal(t, plaintext, decrypted)
}

func TestEncryptDecryptString_NoKey(t *testing.T) {
	persist.ResetKeyForTest()
	_, err := persist.EncryptString("test")
	assert.Error(t, err)

	_, err = persist.DecryptString("somecipher")
	assert.Error(t, err)
}

func TestGenerateSecret(t *testing.T) {
	secret, err := persist.GenerateSecret()
	assert.NoError(t, err)
	assert.Len(t, secret, 32, "GenerateSecret should return 32 bytes")

	// Try initializing with the generated secret
	err = persist.Initialize(secret)
	assert.NoError(t, err)
}

func TestGenerateRandomString(t *testing.T) {
	str, err := persist.GenerateRandomString(16)
	assert.NoError(t, err)
	assert.Len(t, str, 32, "Hex encoded length should be double the byte length")

	// Try another length
	str2, err := persist.GenerateRandomString(10)
	assert.NoError(t, err)
	assert.Len(t, str2, 20)
}

func TestDecryptData_FileNotExist(t *testing.T) {
	key := make([]byte, 32)
	err := persist.Initialize(key)
	assert.NoError(t, err)

	// File doesn't exist
	var data interface{}
	err = persist.DecryptData("non_existent.bin", &data)
	assert.Error(t, err)
}

func TestEncryptData_WriteError(t *testing.T) {
	key := make([]byte, 32)
	err := persist.Initialize(key)
	assert.NoError(t, err)

	// Invalid path (unwritable directory)
	err = persist.EncryptData("data", "/root/forbidden.bin")
	assert.Error(t, err)
}

================
File: internal/persist/crypto.go
================
package persist

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"encoding/base64"
	"encoding/gob"
	"encoding/hex"
	"errors"
	"fmt"
	"io"
	"os"
)

var key []byte

// Initialize sets up the encryption key. Key length must be 16, 24, or 32 bytes for AES-128, AES-192, or AES-256.
func Initialize(encryptionKey []byte) error {
	keyLength := len(encryptionKey)
	if keyLength != 16 && keyLength != 24 && keyLength != 32 {
		return fmt.Errorf("invalid key length: %d. Key must be 16, 24, or 32 bytes", keyLength)
	}
	key = encryptionKey
	return nil
}

// EncryptData encrypts the given data and writes it to the specified file.
func EncryptData(data interface{}, outputFile string) error {
	if !isKeyInitialized() {
		return errors.New("encryption key is not initialized")
	}

	outFile, err := os.OpenFile(outputFile, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
	if err != nil {
		return err
	}
	defer outFile.Close()

	block, err := aes.NewCipher(key)
	if err != nil {
		return err
	}

	iv := make([]byte, aes.BlockSize)
	if _, err := io.ReadFull(rand.Reader, iv); err != nil {
		return err
	}

	if _, err := outFile.Write(iv); err != nil {
		return err
	}

	stream := cipher.NewCFBEncrypter(block, iv)
	writer := &cipher.StreamWriter{S: stream, W: outFile}

	encoder := gob.NewEncoder(writer)
	if err := encoder.Encode(data); err != nil {
		return err
	}

	return nil
}

// DecryptData reads the encrypted data from the specified file, decrypts it, and populates the given data struct.
func DecryptData(inputFile string, data interface{}) error {
	if !isKeyInitialized() {
		return errors.New("decryption key is not initialized")
	}

	inFile, err := os.Open(inputFile)
	if err != nil {
		return err
	}
	defer inFile.Close()

	block, err := aes.NewCipher(key)
	if err != nil {
		return err
	}

	iv := make([]byte, aes.BlockSize)
	if _, err := io.ReadFull(inFile, iv); err != nil {
		return err
	}

	stream := cipher.NewCFBDecrypter(block, iv)
	reader := &cipher.StreamReader{S: stream, R: inFile}

	decoder := gob.NewDecoder(reader)
	if err := decoder.Decode(data); err != nil {
		return err
	}

	return nil
}

// isKeyInitialized checks if the encryption key is set.
func isKeyInitialized() bool {
	return len(key) > 0
}

func GenerateSecret() ([]byte, error) {
	newKey := make([]byte, 32)
	if _, err := rand.Read(newKey); err != nil {
		return nil, err
	}
	return newKey, nil
}

// EncryptString encrypts a plaintext string and returns a base64-encoded ciphertext string.
func EncryptString(plaintext string) (string, error) {
	if !isKeyInitialized() {
		return "", errors.New("encryption key is not initialized")
	}

	block, err := aes.NewCipher(key)
	if err != nil {
		return "", err
	}

	iv := make([]byte, aes.BlockSize)
	if _, err := io.ReadFull(rand.Reader, iv); err != nil {
		return "", err
	}

	stream := cipher.NewCFBEncrypter(block, iv)
	ciphertext := make([]byte, len(plaintext))
	stream.XORKeyStream(ciphertext, []byte(plaintext))

	// Prepend IV to ciphertext
	finalData := append(iv, ciphertext...)
	// Return as base64
	return base64.StdEncoding.EncodeToString(finalData), nil
}

// DecryptString takes a base64-encoded ciphertext and returns the decrypted plaintext.
func DecryptString(ciphertextB64 string) (string, error) {
	if !isKeyInitialized() {
		return "", errors.New("decryption key is not initialized")
	}

	ciphertext, err := base64.StdEncoding.DecodeString(ciphertextB64)
	if err != nil {
		return "", err
	}

	if len(ciphertext) < aes.BlockSize {
		return "", errors.New("ciphertext too short")
	}

	block, err := aes.NewCipher(key)
	if err != nil {
		return "", err
	}

	iv := ciphertext[:aes.BlockSize]
	ciphertext = ciphertext[aes.BlockSize:]

	stream := cipher.NewCFBDecrypter(block, iv)
	plaintext := make([]byte, len(ciphertext))
	stream.XORKeyStream(plaintext, ciphertext)

	return string(plaintext), nil
}

func GenerateRandomString(lengthBytes int) (string, error) {
	b := make([]byte, lengthBytes)
	_, err := rand.Read(b)
	if err != nil {
		return "", fmt.Errorf("failed to generate random bytes: %w", err)
	}
	// Encode as hex string
	return hex.EncodeToString(b), nil
}

func ResetKeyForTest() {
	key = nil
}

================
File: internal/persist/filesystem.go
================
// persist/filesystem.go

package persist

import (
	"io"
	"os"
)

type FileSystem interface {
	ReadFile(path string) ([]byte, error)
	WriteFile(path string, data []byte, perm os.FileMode) error
	Stat(path string) (os.FileInfo, error)
	Open(path string) (io.ReadCloser, error)
	MkdirAll(path string, perm os.FileMode) error
	Remove(path string) error
}

type OSFileSystem struct{}

func (OSFileSystem) ReadFile(path string) ([]byte, error) {
	return os.ReadFile(path)
}

func (OSFileSystem) WriteFile(path string, data []byte, perm os.FileMode) error {
	return os.WriteFile(path, data, perm)
}

func (OSFileSystem) Stat(path string) (os.FileInfo, error) {
	return os.Stat(path)
}

func (OSFileSystem) Open(path string) (io.ReadCloser, error) {
	return os.Open(path)
}

func (OSFileSystem) MkdirAll(path string, perm os.FileMode) error {
	return os.MkdirAll(path, perm)
}

func (OSFileSystem) Remove(path string) error {
	return os.Remove(path)
}

================
File: internal/persist/fileutils_test.go
================
package persist_test

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/guarzo/canifly/internal/persist"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestSaveAndReadJsonFromFile(t *testing.T) {
	fs := persist.OSFileSystem{}
	basePath := t.TempDir()

	type TestData struct {
		Name  string `json:"name"`
		Value int    `json:"value"`
	}

	data := TestData{Name: "test", Value: 42}
	filePath := filepath.Join(basePath, "data.json")

	// Save JSON
	err := persist.SaveJsonToFile(fs, filePath, data)
	assert.NoError(t, err)
	assert.FileExists(t, filePath)

	// Read JSON back
	var result TestData
	err = persist.ReadJsonFromFile(fs, filePath, &result)
	assert.NoError(t, err)
	assert.Equal(t, data.Name, result.Name)
	assert.Equal(t, data.Value, result.Value)
}

func TestReadJsonFromFile_FileNotExist(t *testing.T) {
	fs := persist.OSFileSystem{}
	basePath := t.TempDir()

	var result interface{}
	err := persist.ReadJsonFromFile(fs, filepath.Join(basePath, "non_existent.json"), &result)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "failed to read file")
}

func TestReadJsonFromFile_InvalidJSON(t *testing.T) {
	fs := persist.OSFileSystem{}
	basePath := t.TempDir()
	filePath := filepath.Join(basePath, "invalid.json")

	// Write invalid JSON
	require.NoError(t, os.WriteFile(filePath, []byte("not valid json"), 0644))

	var result interface{}
	err := persist.ReadJsonFromFile(fs, filePath, &result)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "failed to unmarshal JSON data")
}

func TestSaveJsonToFile_InvalidDir(t *testing.T) {
	fs := persist.OSFileSystem{}
	// Attempt to save in a directory that doesn't exist and can't be created (e.g., a file instead of a dir)
	basePath := t.TempDir()
	filePath := filepath.Join(basePath, "somefile")
	require.NoError(t, os.WriteFile(filePath, []byte("I'm a file, not a dir"), 0644))

	// Now try to save JSON in a "subdirectory" of that file
	invalidPath := filepath.Join(filePath, "data.json") // filePath is a file, not a directory
	err := persist.SaveJsonToFile(fs, invalidPath, map[string]string{"key": "value"})
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "failed to create directories")
}

func TestReadCsvRecords(t *testing.T) {
	csvData := `typeID,typeName,description
1234,"My Type","A test type"
5678,"Another Type","Another description"
`

	records, err := persist.ReadCsvRecords(strings.NewReader(csvData))
	assert.NoError(t, err)
	// Expect three rows: the header + two data rows
	assert.Len(t, records, 3, "Should have three rows total (1 header, 2 data)")

	// Header row
	assert.Equal(t, []string{"typeID", "typeName", "description"}, records[0])

	// First data row
	assert.Equal(t, []string{"1234", "My Type", "A test type"}, records[1])

	// Second data row
	assert.Equal(t, []string{"5678", "Another Type", "Another description"}, records[2])
}

func TestReadCsvRecords_Invalid(t *testing.T) {
	csvData := "typeID,typeName\ntypeIDOnly"

	_, err := persist.ReadCsvRecords(strings.NewReader(csvData))
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "error reading CSV")
}

================
File: internal/persist/fileutils.go
================
package persist

import (
	"encoding/csv"
	"encoding/json"
	"fmt"
	"io"
	"os"
	"path/filepath"
)

func ReadJsonFromFile(fs FileSystem, filePath string, target interface{}) error {
	data, err := fs.ReadFile(filePath)
	if err != nil {
		return fmt.Errorf("failed to read file %s: %w", filePath, err)
	}
	if err := json.Unmarshal(data, target); err != nil {
		return fmt.Errorf("failed to unmarshal JSON data from %s: %w", filePath, err)
	}
	return nil
}

func SaveJsonToFile(fs FileSystem, filePath string, source interface{}) error {
	dir := filepath.Dir(filePath)
	if err := fs.MkdirAll(dir, os.ModePerm); err != nil {
		return fmt.Errorf("failed to create directories for %s: %w", filePath, err)
	}

	data, err := json.MarshalIndent(source, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal JSON data for %s: %w", filePath, err)
	}

	if err := fs.WriteFile(filePath, data, 0644); err != nil {
		return fmt.Errorf("failed to write JSON file %s: %w", filePath, err)
	}
	return nil
}

func ReadCsvRecords(r io.Reader) ([][]string, error) {
	reader := csv.NewReader(r)
	var records [][]string
	for {
		record, err := reader.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			return nil, fmt.Errorf("error reading CSV: %w", err)
		}
		records = append(records, record)
	}
	return records, nil
}

================
File: internal/server/env.go
================
package server

import (
	"encoding/base64"
	"fmt"
	"github.com/guarzo/canifly/internal/embed"
	"github.com/guarzo/canifly/internal/persist"
	"github.com/guarzo/canifly/internal/services/interfaces"
	"github.com/joho/godotenv"
	"os"
	"path/filepath"
)

type Config struct {
	Port         string
	SecretKey    string
	ClientID     string
	ClientSecret string
	CallbackURL  string
	PathSuffix   string
	BasePath     string
}

func LoadConfig(logger interfaces.Logger) (Config, error) {
	// Try local .env
	if err := godotenv.Load(); err != nil {
		// Try embedded .env
		embeddedEnv, err := embed.EnvFiles.Open("config/.env")
		if err != nil {
			logger.Warn("Failed to load embedded .env file. Using system environment variables.")
		} else {
			defer embeddedEnv.Close()
			envMap, err := godotenv.Parse(embeddedEnv)
			if err != nil {
				logger.WithError(err).Warn("Failed to parse embedded .env file.")
			} else {
				for key, value := range envMap {
					os.Setenv(key, value)
				}
			}
		}
	}

	cfg := Config{}

	cfg.Port = getPort()
	cfg.SecretKey = getSecretKey(logger)

	cfg.ClientID = os.Getenv("EVE_CLIENT_ID")
	cfg.ClientSecret = os.Getenv("EVE_CLIENT_SECRET")
	cfg.CallbackURL = os.Getenv("EVE_CALLBACK_URL")

	if cfg.ClientID == "" || cfg.ClientSecret == "" || cfg.CallbackURL == "" {
		return cfg, fmt.Errorf("EVE_CLIENT_ID, EVE_CLIENT_SECRET, and EVE_CALLBACK_URL must be set")
	}

	cfg.PathSuffix = os.Getenv("PATH_SUFFIX")
	configDir, err := os.UserConfigDir()
	if err != nil {
		return cfg, fmt.Errorf("unable to get user config dir: %v", err)
	}
	cfg.BasePath = filepath.Join(configDir, "canifly")

	return cfg, nil
}

// getSecretKey retrieves or generates the encryption secret key
func getSecretKey(logger interfaces.Logger) string {
	secret := os.Getenv("SECRET_KEY")
	if secret == "" {
		key, err := persist.GenerateSecret()
		if err != nil {
			logger.WithError(err).Fatal("Failed to generate secret key")
		}
		secret = base64.StdEncoding.EncodeToString(key)
		logger.Warn("Using a generated key for testing only.")
	}
	return secret
}

// getPort returns the port the server should listen on
func getPort() string {
	port := os.Getenv("PORT")
	if port == "" {
		port = "8713"
	}
	return port
}

================
File: internal/server/logger.go
================
package server

import (
	"github.com/sirupsen/logrus"

	flyLogger "github.com/guarzo/canifly/internal/services/config"
	"github.com/guarzo/canifly/internal/services/interfaces"
)

func SetupLogger() interfaces.Logger {

	logrusLogger := logrus.New()

	// logrusLogger.SetReportCaller(true) // Enable caller reporting

	logrusLogger.SetFormatter(&logrus.TextFormatter{
		ForceColors:   true,
		FullTimestamp: false,
		//CallerPrettyfier: func(frame *runtime.Frame) (function string, file string) {
		//	// Extract only the file name and line number
		//	filename := filepath.Base(frame.File)
		//	return frame.Function, fmt.Sprintf("%s:%d", filename, frame.Line)
		//},
	})

	logrusLogger.SetLevel(logrus.InfoLevel)
	return flyLogger.NewLogrusAdapter(logrusLogger)
}

================
File: internal/server/router.go
================
package server

import (
	"net/http"

	"github.com/gorilla/handlers"
	"github.com/gorilla/mux"

	"github.com/guarzo/canifly/internal/embed"
	flyHandlers "github.com/guarzo/canifly/internal/handlers"
	flyHttp "github.com/guarzo/canifly/internal/http"
	"github.com/guarzo/canifly/internal/services/interfaces"
)

// SetupHandlers configures and returns the apps router
func SetupHandlers(secret string, logger interfaces.Logger, appServices *AppServices) http.Handler {
	sessionStore := flyHttp.NewSessionService(secret)
	r := mux.NewRouter()

	// Add authentication middleware
	r.Use(flyHttp.AuthMiddleware(sessionStore, logger))
	dashboardHandler := flyHandlers.NewDashboardHandler(sessionStore, logger, appServices.DashBoardService)
	authHandler := flyHandlers.NewAuthHandler(sessionStore, appServices.EsiService, logger, appServices.AccountService, appServices.StateService, appServices.LoginService, appServices.AuthClient)
	accountHandler := flyHandlers.NewAccountHandler(sessionStore, logger, appServices.AccountService)
	characterHandler := flyHandlers.NewCharacterHandler(logger, appServices.CharacterService)
	skillPlanHandler := flyHandlers.NewSkillPlanHandler(logger, appServices.SkillService)
	configHandler := flyHandlers.NewConfigHandler(logger, appServices.ConfigService)
	eveDataHandler := flyHandlers.NewEveDataHandler(logger, appServices.EveProfileService)
	assocHandler := flyHandlers.NewAssociationHandler(logger, appServices.AssocService)

	// Public routes
	r.HandleFunc("/callback/", authHandler.CallBack())
	r.HandleFunc("/api/add-character", authHandler.AddCharacterHandler())
	r.HandleFunc("/api/finalize-login", authHandler.FinalizeLogin())

	// Auth routes
	r.HandleFunc("/api/app-data", dashboardHandler.GetDashboardData()).Methods("GET")
	r.HandleFunc("/api/app-data-no-cache", dashboardHandler.GetDashboardDataNoCache()).Methods("GET")

	r.HandleFunc("/api/logout", authHandler.Logout())
	r.HandleFunc("/api/login", authHandler.Login())
	r.HandleFunc("/api/reset-identities", authHandler.ResetAccounts())

	r.HandleFunc("/api/get-skill-plan", skillPlanHandler.GetSkillPlanFile())
	r.HandleFunc("/api/save-skill-plan", skillPlanHandler.SaveSkillPlan())
	r.HandleFunc("/api/delete-skill-plan", skillPlanHandler.DeleteSkillPlan())

	r.HandleFunc("/api/update-account-name", accountHandler.UpdateAccountName())
	r.HandleFunc("/api/toggle-account-status", accountHandler.ToggleAccountStatus())
	r.HandleFunc("/api/toggle-account-visibility", accountHandler.ToggleAccountVisibility())
	r.HandleFunc("/api/remove-account", accountHandler.RemoveAccount())

	r.HandleFunc("/api/update-character", characterHandler.UpdateCharacter)
	r.HandleFunc("/api/remove-character", characterHandler.RemoveCharacter)

	r.HandleFunc("/api/choose-settings-dir", configHandler.ChooseSettingsDir)
	r.HandleFunc("/api/reset-to-default-directory", configHandler.ResetToDefaultDir)
	r.HandleFunc("/api/save-user-selections", configHandler.SaveUserSelections)

	r.HandleFunc("/api/sync-subdirectory", eveDataHandler.SyncSubDirectory)
	r.HandleFunc("/api/sync-all-subdirectories", eveDataHandler.SyncAllSubdirectories)
	r.HandleFunc("/api/backup-directory", eveDataHandler.BackupDirectory)

	r.HandleFunc("/api/associate-character", assocHandler.AssociateCharacter)
	r.HandleFunc("/api/unassociate-character", assocHandler.UnassociateCharacter)

	// Serve static files
	staticFileServer := http.FileServer(http.FS(embed.StaticFilesSub))
	r.PathPrefix("/static/").Handler(http.StripPrefix("/static/", staticFileServer))

	return createCORSHandler(r)
}

func createCORSHandler(h http.Handler) http.Handler {
	return handlers.CORS(
		handlers.AllowedOrigins([]string{"http://localhost:5173"}),
		handlers.AllowedMethods([]string{"GET", "POST", "OPTIONS", "DELETE"}),
		handlers.AllowedHeaders([]string{"Content-Type", "Authorization", "X-Requested-With"}),
		handlers.AllowCredentials(),
	)(h)
}

================
File: internal/server/services.go
================
package server

import (
	"fmt"

	"github.com/guarzo/canifly/internal/embed"
	"github.com/guarzo/canifly/internal/http"
	"github.com/guarzo/canifly/internal/persist"
	"github.com/guarzo/canifly/internal/persist/account"
	"github.com/guarzo/canifly/internal/persist/config"
	"github.com/guarzo/canifly/internal/persist/eve"
	accountSvc "github.com/guarzo/canifly/internal/services/account"
	configSvc "github.com/guarzo/canifly/internal/services/config"
	eveSvc "github.com/guarzo/canifly/internal/services/eve"
	"github.com/guarzo/canifly/internal/services/interfaces"
)

type AppServices struct {
	EsiService        interfaces.ESIService
	EveProfileService interfaces.EveProfilesService
	AccountService    interfaces.AccountService
	SkillService      interfaces.SkillService
	ConfigService     interfaces.ConfigService
	CharacterService  interfaces.CharacterService
	DashBoardService  interfaces.DashboardService
	AssocService      interfaces.AssociationService
	StateService      interfaces.AppStateService
	LoginService      interfaces.LoginService
	AuthClient        interfaces.AuthClient
}

func GetServices(logger interfaces.Logger, cfg Config) (*AppServices, error) {

	skillService, err := initSkillService(logger, cfg.BasePath)
	if err != nil {
		return nil, err
	}

	loginService := initLoginService(logger)
	authClient := initAuthClient(logger, cfg)
	esiService := initESIService(logger, cfg, authClient)
	accountService, assocService := initAccountAndAssoc(logger, esiService, cfg.BasePath)
	configService, err := initConfigService(logger, cfg.BasePath)
	if err != nil {
		return nil, err
	}
	appStateStr := config.NewAppStateStore(logger, persist.OSFileSystem{}, cfg.BasePath)
	stateService := configSvc.NewAppStateService(logger, appStateStr)

	eveProfileService := initEveProfileService(logger, esiService, configService, accountService)

	characterService, dashboardService, err := initCharacterAndDashboard(logger, esiService, skillService, accountService, configService, stateService, eveProfileService)
	if err != nil {
		return nil, err
	}

	return &AppServices{
		EsiService:        esiService,
		EveProfileService: eveProfileService,
		AccountService:    accountService,
		SkillService:      skillService,
		ConfigService:     configService,
		CharacterService:  characterService,
		DashBoardService:  dashboardService,
		AssocService:      assocService,
		StateService:      stateService,
		LoginService:      loginService,
		AuthClient:        authClient,
	}, nil
}

func initAuthClient(logger interfaces.Logger, cfg Config) interfaces.AuthClient {
	return accountSvc.NewAuthClient(logger, cfg.ClientID, cfg.ClientSecret, cfg.CallbackURL)
}

func initEveProfileService(logger interfaces.Logger, esi interfaces.ESIService, con interfaces.ConfigService, ac interfaces.AccountService) interfaces.EveProfilesService {
	eveRepo := eve.NewEveProfilesStore(logger)
	return eveSvc.NewEveProfileservice(logger, eveRepo, ac, esi, con)
}

func initCharacterAndDashboard(l interfaces.Logger, e interfaces.ESIService, sk interfaces.SkillService, as interfaces.AccountService, s interfaces.ConfigService, st interfaces.AppStateService, ev interfaces.EveProfilesService) (interfaces.CharacterService, interfaces.DashboardService, error) {
	sysStore := eve.NewSystemStore(l)
	if err := sysStore.LoadSystems(); err != nil {
		return nil, nil, fmt.Errorf("failed to load systems %v", err)
	}

	characterService := eveSvc.NewCharacterService(e, l, sysStore, sk, as, s)
	dashboardService := configSvc.NewDashboardService(l, sk, characterService, as, s, st, ev)
	return characterService, dashboardService, nil

}

func initAccountAndAssoc(l interfaces.Logger, e interfaces.ESIService, basePath string) (interfaces.AccountService, interfaces.AssociationService) {
	accountStr := account.NewAccountDataStore(l, persist.OSFileSystem{}, basePath)

	assocService := accountSvc.NewAssociationService(l, accountStr, e)
	accountService := accountSvc.NewAccountService(l, accountStr, e, assocService)
	return accountService, assocService
}

func initSkillService(logger interfaces.Logger, basePath string) (interfaces.SkillService, error) {
	skillStore := eve.NewSkillStore(logger, persist.OSFileSystem{}, basePath)
	if err := skillStore.LoadSkillPlans(); err != nil {
		return nil, fmt.Errorf("failed to load eve plans %v", err)
	}
	if err := skillStore.LoadSkillTypes(); err != nil {
		return nil, fmt.Errorf("failed to load eve types %v", err)
	}
	return eveSvc.NewSkillService(logger, skillStore), nil
}

func initLoginService(logger interfaces.Logger) interfaces.LoginService {
	loginStateStore := account.NewLoginStateStore()
	return accountSvc.NewLoginService(logger, loginStateStore)
}

func initESIService(logger interfaces.Logger, cfg Config, authClient interfaces.AuthClient) interfaces.ESIService {
	cacheStr := eve.NewCacheStore(logger, persist.OSFileSystem{}, cfg.BasePath)
	deletedStr := eve.NewDeletedStore(logger, persist.OSFileSystem{}, cfg.BasePath)
	cacheService := eveSvc.NewCacheService(logger, cacheStr)
	httpClient := http.NewEsiHttpClient("https://esi.evetech.net", logger, authClient, cacheService)
	return eveSvc.NewESIService(httpClient, authClient, logger, cacheService, deletedStr)
}

// Modified initConfigService: if EnsureSettingsDir fails, log a warning and reset SettingsDir to empty.
func initConfigService(l interfaces.Logger, basePath string) (interfaces.ConfigService, error) {
	configStr := config.NewConfigStore(l, persist.OSFileSystem{}, basePath)
	if err := embed.LoadStatic(); err != nil {
		return nil, fmt.Errorf("failed to load static files %v", err)
	}

	srv := configSvc.NewConfigService(l, configStr)
	if err := srv.EnsureSettingsDir(); err != nil {
		l.Warnf("unable to ensure settings dir: %v; proceeding with empty SettingsDir", err)
		configData, fetchErr := configStr.FetchConfigData()
		if fetchErr != nil {
			l.Warnf("failed to fetch config data: %v", fetchErr)
		} else {
			configData.SettingsDir = ""
			if saveErr := configStr.SaveConfigData(configData); saveErr != nil {
				l.Warnf("failed to save config data with empty SettingsDir: %v", saveErr)
			}
		}
	}
	return srv, nil
}

================
File: internal/services/account/account_service_test.go
================
package account_test

import (
	"testing"
	"time"

	"golang.org/x/oauth2"

	"github.com/guarzo/canifly/internal/model"
	"github.com/guarzo/canifly/internal/services/account"
	"github.com/guarzo/canifly/internal/testutil"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

func TestFindOrCreateAccount_NewAccount(t *testing.T) {
	logger := &testutil.MockLogger{}
	repo := &testutil.MockAccountDataRepository{}
	esi := &testutil.MockESIService{}
	assoc := &testutil.MockAssociationService{}

	svc := account.NewAccountService(logger, repo, esi, assoc)

	char := &model.UserInfoResponse{CharacterID: 12345, CharacterName: "TestChar"}
	token := &oauth2.Token{AccessToken: "abc"}

	// Initially no accounts
	repo.On("FetchAccountData").Return(model.AccountData{Accounts: []model.Account{}}, nil).Once()

	// UpdateAssociationsAfterNewCharacter called once a new account is created
	assoc.On("UpdateAssociationsAfterNewCharacter", mock.Anything, int64(12345)).Return(nil).Once()

	// After creation, we must save
	repo.On("SaveAccountData", mock.Anything).Return(nil).Once()

	err := svc.FindOrCreateAccount("testAccount", char, token)
	assert.NoError(t, err)

	repo.AssertExpectations(t)
	assoc.AssertExpectations(t)
}

func TestFindOrCreateAccount_ExistingAccount(t *testing.T) {
	logger := &testutil.MockLogger{}
	repo := &testutil.MockAccountDataRepository{}
	esi := &testutil.MockESIService{}
	assoc := &testutil.MockAssociationService{}

	svc := account.NewAccountService(logger, repo, esi, assoc)

	char := &model.UserInfoResponse{CharacterID: 9999, CharacterName: "ExistingChar"}
	token := &oauth2.Token{AccessToken: "xyz"}

	existingAccount := model.Account{
		Name:   "testAccount",
		Status: model.Alpha,
		Characters: []model.CharacterIdentity{
			{Character: model.Character{UserInfoResponse: model.UserInfoResponse{CharacterID: 1111, CharacterName: "OtherChar"}}},
		},
		ID: time.Now().Unix(),
	}

	repo.On("FetchAccountData").Return(model.AccountData{Accounts: []model.Account{existingAccount}}, nil).Once()
	// Associates after adding new char
	assoc.On("UpdateAssociationsAfterNewCharacter", mock.Anything, int64(9999)).Return(nil).Once()
	repo.On("SaveAccountData", mock.Anything).Return(nil).Once()

	err := svc.FindOrCreateAccount("testAccount", char, token)
	assert.NoError(t, err)

	repo.AssertExpectations(t)
	assoc.AssertExpectations(t)
}

func TestUpdateAccountName(t *testing.T) {
	logger := &testutil.MockLogger{}
	repo := &testutil.MockAccountDataRepository{}
	esi := &testutil.MockESIService{}
	assoc := &testutil.MockAssociationService{}

	svc := account.NewAccountService(logger, repo, esi, assoc)

	accID := int64(123)
	accounts := []model.Account{
		{Name: "OldName", ID: accID},
	}
	repo.On("FetchAccountData").Return(model.AccountData{Accounts: accounts}, nil).Once()
	repo.On("SaveAccountData", mock.Anything).Return(nil).Once()

	err := svc.UpdateAccountName(accID, "NewName")
	assert.NoError(t, err)
	repo.AssertExpectations(t)
}

func TestUpdateAccountName_NotFound(t *testing.T) {
	logger := &testutil.MockLogger{}
	repo := &testutil.MockAccountDataRepository{}
	esi := &testutil.MockESIService{}
	assoc := &testutil.MockAssociationService{}

	svc := account.NewAccountService(logger, repo, esi, assoc)

	repo.On("FetchAccountData").Return(model.AccountData{Accounts: []model.Account{}}, nil).Once()

	err := svc.UpdateAccountName(999, "NewName")
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "account not found")
	repo.AssertExpectations(t)
}

func TestToggleAccountStatus(t *testing.T) {
	logger := &testutil.MockLogger{}
	repo := &testutil.MockAccountDataRepository{}
	esi := &testutil.MockESIService{}
	assoc := &testutil.MockAssociationService{}

	svc := account.NewAccountService(logger, repo, esi, assoc)

	accID := int64(100)
	accounts := []model.Account{{Name: "test", ID: accID, Status: model.Alpha}}
	repo.On("FetchAccountData").Return(model.AccountData{Accounts: accounts}, nil).Once()
	repo.On("SaveAccountData", mock.Anything).Return(nil).Once()

	err := svc.ToggleAccountStatus(accID)
	assert.NoError(t, err)
	repo.AssertExpectations(t)
}

func TestToggleAccountStatus_NotFound(t *testing.T) {
	logger := &testutil.MockLogger{}
	repo := &testutil.MockAccountDataRepository{}
	esi := &testutil.MockESIService{}
	assoc := &testutil.MockAssociationService{}

	svc := account.NewAccountService(logger, repo, esi, assoc)

	repo.On("FetchAccountData").Return(model.AccountData{Accounts: []model.Account{}}, nil).Once()

	err := svc.ToggleAccountStatus(999)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "account not found")
	repo.AssertExpectations(t)
}

func TestRemoveAccountByName(t *testing.T) {
	logger := &testutil.MockLogger{}
	repo := &testutil.MockAccountDataRepository{}
	esi := &testutil.MockESIService{}
	assoc := &testutil.MockAssociationService{}

	svc := account.NewAccountService(logger, repo, esi, assoc)

	accounts := []model.Account{{Name: "DelMe"}}
	repo.On("FetchAccountData").Return(model.AccountData{Accounts: accounts}, nil).Once()
	repo.On("SaveAccountData", mock.Anything).Return(nil).Once()

	err := svc.RemoveAccountByName("DelMe")
	assert.NoError(t, err)
	repo.AssertExpectations(t)
}

func TestRemoveAccountByName_NotFound(t *testing.T) {
	logger := &testutil.MockLogger{}
	repo := &testutil.MockAccountDataRepository{}
	esi := &testutil.MockESIService{}
	assoc := &testutil.MockAssociationService{}

	svc := account.NewAccountService(logger, repo, esi, assoc)

	repo.On("FetchAccountData").Return(model.AccountData{Accounts: []model.Account{}}, nil).Once()

	err := svc.RemoveAccountByName("NoSuch")
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "not found")
	repo.AssertExpectations(t)
}

func TestFetchAccounts(t *testing.T) {
	logger := &testutil.MockLogger{}
	repo := &testutil.MockAccountDataRepository{}
	esi := &testutil.MockESIService{}
	assoc := &testutil.MockAssociationService{}

	svc := account.NewAccountService(logger, repo, esi, assoc)

	accounts := []model.Account{{Name: "Acc1"}, {Name: "Acc2"}}
	repo.On("FetchAccountData").Return(model.AccountData{Accounts: accounts}, nil).Once()

	result, err := svc.FetchAccounts()
	assert.NoError(t, err)
	assert.Len(t, result, 2)
	repo.AssertExpectations(t)
}

func TestFetchAccounts_Error(t *testing.T) {
	logger := &testutil.MockLogger{}
	repo := &testutil.MockAccountDataRepository{}
	esi := &testutil.MockESIService{}
	assoc := &testutil.MockAssociationService{}

	svc := account.NewAccountService(logger, repo, esi, assoc)

	repo.On("FetchAccountData").Return(model.AccountData{}, assert.AnError).Once()

	result, err := svc.FetchAccounts()
	assert.Error(t, err)
	assert.Nil(t, result)
	repo.AssertExpectations(t)
}

================
File: internal/services/account/account_service.go
================
// services/account/account_service.go
package account

import (
	"fmt"
	"strconv"
	"time"

	"golang.org/x/oauth2"

	"github.com/guarzo/canifly/internal/model"
	"github.com/guarzo/canifly/internal/services/interfaces"
)

const AlphaMaxSp = 5000000

var _ interfaces.AccountService = (*accountService)(nil)

type accountService struct {
	logger       interfaces.Logger
	accountRepo  interfaces.AccountDataRepository
	esi          interfaces.ESIService
	assocService interfaces.AssociationService
}

func NewAccountService(
	logger interfaces.Logger,
	accountRepo interfaces.AccountDataRepository,
	esi interfaces.ESIService,
	assoc interfaces.AssociationService,
) interfaces.AccountService {
	return &accountService{
		logger:       logger,
		accountRepo:  accountRepo,
		esi:          esi,
		assocService: assoc,
	}
}

func (a *accountService) GetAccountNameByID(id string) (string, bool) {
	accounts, err := a.accountRepo.FetchAccounts()
	if err != nil {
		a.logger.Errorf("unable to retrieve accounts, returning false %v", err)
		return "", false
	}
	for _, account := range accounts {
		if strconv.FormatInt(account.ID, 10) == id {
			return account.Name, true
		}
	}

	return "", false
}

func (a *accountService) FindOrCreateAccount(state string, char *model.UserInfoResponse, token *oauth2.Token) error {
	accountData, err := a.accountRepo.FetchAccountData()
	if err != nil {
		return err
	}
	accounts := accountData.Accounts

	account := a.FindAccountByName(state, accounts)
	if account == nil {
		account = createNewAccountWithCharacter(state, token, char)
		accounts = append(accounts, *account)
	} else {
		// Check if character already exists in this account
		var characterAssigned bool
		for i := range account.Characters {
			if account.Characters[i].Character.CharacterID == char.CharacterID {
				account.Characters[i].Token = *token
				characterAssigned = true
				a.logger.Debugf("found character: %d already assigned", char.CharacterID)
				break
			}
		}
		if !characterAssigned {
			a.logger.Infof("adding %s to existing account %s", char.CharacterName, account.Name)
			newChar := model.CharacterIdentity{
				Token: *token,
				Character: model.Character{
					UserInfoResponse: *char,
				},
			}
			account.Characters = append(account.Characters, newChar)
		}
	}

	// Update the accounts back to accountData
	accountData.Accounts = accounts

	// Update associations after new character
	if err := a.assocService.UpdateAssociationsAfterNewCharacter(account, char.CharacterID); err != nil {
		a.logger.Warnf("error updating associations after updating character %v", err)
	}

	// Save updated accountData
	if err := a.accountRepo.SaveAccountData(accountData); err != nil {
		return err
	}

	return nil
}

func (a *accountService) DeleteAllAccounts() error {
	accountData, err := a.accountRepo.FetchAccountData()
	if err != nil {
		return fmt.Errorf("failed to fetch account data: %w", err)
	}

	accountData.Accounts = []model.Account{}

	if err := a.accountRepo.SaveAccountData(accountData); err != nil {
		return fmt.Errorf("failed to save empty accounts: %w", err)
	}

	return nil
}

func createNewAccountWithCharacter(name string, token *oauth2.Token, user *model.UserInfoResponse) *model.Account {
	newChar := model.CharacterIdentity{
		Token: *token,
		Character: model.Character{
			UserInfoResponse: *user,
		},
	}

	return &model.Account{
		Name:       name,
		Status:     model.Alpha,
		Characters: []model.CharacterIdentity{newChar},
		ID:         time.Now().Unix(),
	}
}

func (a *accountService) FindAccountByName(accountName string, accounts []model.Account) *model.Account {
	for i := range accounts {
		if accounts[i].Name == accountName {
			return &accounts[i]
		}
	}
	return nil
}

func (a *accountService) UpdateAccountName(accountID int64, accountName string) error {
	accountData, err := a.accountRepo.FetchAccountData()
	if err != nil {
		return fmt.Errorf("error fetching account data: %w", err)
	}

	accounts := accountData.Accounts
	var accountToUpdate *model.Account
	for i := range accounts {
		if accounts[i].ID == accountID {
			accountToUpdate = &accounts[i]
			break
		}
	}

	if accountToUpdate == nil {
		return fmt.Errorf("account not found")
	}

	accountToUpdate.Name = accountName
	accountData.Accounts = accounts

	if err = a.accountRepo.SaveAccountData(accountData); err != nil {
		return fmt.Errorf("failed to save account data: %w", err)
	}

	return nil
}

func (a *accountService) ToggleAccountStatus(accountID int64) error {
	accountData, err := a.accountRepo.FetchAccountData()
	if err != nil {
		return fmt.Errorf("error fetching account data: %w", err)
	}

	accounts := accountData.Accounts
	var accountFound bool
	for i := range accounts {
		if accounts[i].ID == accountID {
			if accounts[i].Status == "Alpha" {
				accounts[i].Status = "Omega"
			} else {
				accounts[i].Status = "Alpha"
			}
			accountFound = true
			break
		}
	}

	if !accountFound {
		return fmt.Errorf("account not found")
	}

	accountData.Accounts = accounts
	if err = a.accountRepo.SaveAccountData(accountData); err != nil {
		return fmt.Errorf("failed to save account data: %w", err)
	}

	return nil
}

func (a *accountService) ToggleAccountVisibility(accountID int64) error {
	accountData, err := a.accountRepo.FetchAccountData()
	if err != nil {
		return fmt.Errorf("error fetching account data: %w", err)
	}

	accounts := accountData.Accounts
	var accountFound bool
	for i := range accounts {
		if accounts[i].ID == accountID {
			accounts[i].Visible = !accounts[i].Visible
			accountFound = true
			break
		}
	}

	if !accountFound {
		return fmt.Errorf("account not found")
	}

	accountData.Accounts = accounts
	if err = a.accountRepo.SaveAccountData(accountData); err != nil {
		return fmt.Errorf("failed to save account data: %w", err)
	}

	return nil
}

func (a *accountService) RemoveAccountByName(accountName string) error {
	accountData, err := a.accountRepo.FetchAccountData()
	if err != nil {
		return fmt.Errorf("error fetching account data: %w", err)
	}

	accounts := accountData.Accounts
	index := -1
	for i, acc := range accounts {
		if acc.Name == accountName {
			index = i
			break
		}
	}

	if index == -1 {
		return fmt.Errorf("account %s not found", accountName)
	}

	accounts = append(accounts[:index], accounts[index+1:]...)
	accountData.Accounts = accounts

	if err := a.accountRepo.SaveAccountData(accountData); err != nil {
		return fmt.Errorf("failed to save account data: %w", err)
	}

	return nil
}

func (a *accountService) RefreshAccountData(characterSvc interfaces.CharacterService) (*model.AccountData, error) {
	a.logger.Debug("Refreshing account data")
	accountData, err := a.accountRepo.FetchAccountData()
	if err != nil {
		return nil, fmt.Errorf("failed to load account data: %w", err)
	}

	accounts := accountData.Accounts
	a.logger.Debugf("Fetched %d accounts", len(accounts))

	for i := range accounts {
		account := &accounts[i]
		a.logger.Debugf("Processing account: %s", account.Name)

		for j := range account.Characters {
			charIdentity := &account.Characters[j]
			a.logger.Debugf("Processing character: %s (ID: %d)", charIdentity.Character.CharacterName, charIdentity.Character.CharacterID)

			updatedCharIdentity, err := characterSvc.ProcessIdentity(charIdentity)
			if err != nil {
				a.logger.Errorf("Failed to process identity for character %d: %v", charIdentity.Character.CharacterID, err)
				continue
			}

			if updatedCharIdentity.MCT && updatedCharIdentity.Character.TotalSP > AlphaMaxSp {
				account.Status = model.Omega
			}

			account.Characters[j] = *updatedCharIdentity
		}

		a.logger.Debugf("Account %s has %d characters after processing", account.Name, len(account.Characters))
	}

	accountData.Accounts = accounts

	if err := a.accountRepo.SaveAccountData(accountData); err != nil {
		return nil, fmt.Errorf("failed to save account data: %w", err)
	}

	if err := a.esi.SaveEsiCache(); err != nil {
		a.logger.WithError(err).Infof("save cache failed in refresh accounts")
	}

	return &accountData, nil
}

func (a *accountService) FetchAccounts() ([]model.Account, error) {
	accountData, err := a.accountRepo.FetchAccountData()
	if err != nil {
		return nil, err
	}
	return accountData.Accounts, nil
}

func (a *accountService) SaveAccounts(accounts []model.Account) error {
	accountData, err := a.accountRepo.FetchAccountData()
	if err != nil {
		return err
	}
	accountData.Accounts = accounts
	return a.accountRepo.SaveAccountData(accountData)
}

================
File: internal/services/account/association_service_test.go
================
package account_test

import (
	"fmt"
	"github.com/guarzo/canifly/internal/model"
	"github.com/guarzo/canifly/internal/services/account"
	"github.com/guarzo/canifly/internal/testutil"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"testing"
)

func TestUpdateAssociationsAfterNewCharacter(t *testing.T) {
	logger := &testutil.MockLogger{}
	repo := &testutil.MockAccountDataRepository{}
	esi := &testutil.MockESIService{}

	assocSvc := account.NewAssociationService(logger, repo, esi)

	acc := model.Account{Name: "TestAcc", ID: 100, Characters: []model.CharacterIdentity{
		{Character: model.Character{UserInfoResponse: model.UserInfoResponse{CharacterID: 9999, CharacterName: "OldChar"}}},
	}}
	accountData := model.AccountData{
		Accounts:     []model.Account{acc},
		Associations: []model.Association{},
	}

	// Mock fetch and save
	repo.On("FetchAccountData").Return(accountData, nil).Once()
	repo.On("SaveAccountData", mock.Anything).Return(nil).Once()

	// The method internally calls syncAccountWithUserFileAndAssociations, which tries to getUserIdWithCharId and associate missing chars.
	// Here, we have no associations, so getUserIdWithCharId will fail. Let's simulate that:
	// If we want a success scenario, we must have an association that matches the charID.
	// Let's add one association to match charID=9999 -> userId="101"
	accountData.Associations = []model.Association{
		{UserId: "101", CharId: "9999", CharName: "OldChar"},
	}
	repo.ExpectedCalls = nil // reset expectations
	repo.On("FetchAccountData").Return(accountData, nil).Once()
	repo.On("SaveAccountData", mock.Anything).Return(nil).Once()

	// Now it should succeed in updating the account ID and associating missing chars.
	err := assocSvc.UpdateAssociationsAfterNewCharacter(&accountData.Accounts[0], 9999)
	assert.NoError(t, err)
	repo.AssertExpectations(t)
}

func TestAssociateCharacter_Success(t *testing.T) {
	logger := &testutil.MockLogger{}
	repo := &testutil.MockAccountDataRepository{}
	esi := &testutil.MockESIService{}

	assocSvc := account.NewAssociationService(logger, repo, esi)

	accountData := model.AccountData{
		Accounts:     []model.Account{{Name: "Acc1", ID: 0}},
		Associations: []model.Association{},
	}

	repo.On("FetchAccountData").Return(accountData, nil).Once()
	esi.On("GetCharacter", "300").Return(&model.CharacterResponse{Name: "Char300"}, nil).Once()

	// Expect only one save call
	repo.On("SaveAccountData", mock.Anything).Return(nil).Once()

	err := assocSvc.AssociateCharacter("200", "300")
	assert.NoError(t, err)

	repo.AssertExpectations(t)
	esi.AssertExpectations(t)
}

func TestAssociateCharacter_MaxChars(t *testing.T) {
	logger := &testutil.MockLogger{}
	repo := &testutil.MockAccountDataRepository{}
	esi := &testutil.MockESIService{}

	assocSvc := account.NewAssociationService(logger, repo, esi)

	// userId="200" already has 3 chars
	associations := []model.Association{
		{UserId: "200", CharId: "101"},
		{UserId: "200", CharId: "102"},
		{UserId: "200", CharId: "103"},
	}
	accountData := model.AccountData{Associations: associations}

	repo.On("FetchAccountData").Return(accountData, nil).Once()

	// Should fail due to max 3 chars
	err := assocSvc.AssociateCharacter("200", "104")
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "maximum of 3 associated characters")
	repo.AssertExpectations(t)
}

func TestAssociateCharacter_AlreadyAssociated(t *testing.T) {
	logger := &testutil.MockLogger{}
	repo := &testutil.MockAccountDataRepository{}
	esi := &testutil.MockESIService{}

	assocSvc := account.NewAssociationService(logger, repo, esi)

	associations := []model.Association{
		{UserId: "200", CharId: "300"},
	}
	accountData := model.AccountData{Associations: associations}

	repo.On("FetchAccountData").Return(accountData, nil).Once()

	// Trying to associate charId=300 again should fail
	err := assocSvc.AssociateCharacter("200", "300")
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "already associated")
	repo.AssertExpectations(t)
}

func TestAssociateCharacter_GetCharacterError(t *testing.T) {
	logger := &testutil.MockLogger{}
	repo := &testutil.MockAccountDataRepository{}
	esi := &testutil.MockESIService{}

	assocSvc := account.NewAssociationService(logger, repo, esi)

	accountData := model.AccountData{
		Accounts:     []model.Account{{Name: "Acc1", ID: 0}},
		Associations: []model.Association{},
	}

	repo.On("FetchAccountData").Return(accountData, nil).Once()
	esi.On("GetCharacter", "400").Return((*model.CharacterResponse)(nil), fmt.Errorf("character fetch error")).Once()

	err := assocSvc.AssociateCharacter("200", "400")
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "failed to fetch character name")
	repo.AssertExpectations(t)
	esi.AssertExpectations(t)
}

func TestUnassociateCharacter_Success(t *testing.T) {
	logger := &testutil.MockLogger{}
	repo := &testutil.MockAccountDataRepository{}
	esi := &testutil.MockESIService{}

	assocSvc := account.NewAssociationService(logger, repo, esi)

	// userId=300 has 2 associations: char1, char2
	associations := []model.Association{
		{UserId: "300", CharId: "500", CharName: "Char500"},
		{UserId: "300", CharId: "600", CharName: "Char600"},
	}
	accounts := []model.Account{
		{Name: "AccFor300", ID: 300, Characters: []model.CharacterIdentity{
			{Character: model.Character{UserInfoResponse: model.UserInfoResponse{CharacterID: 500}}},
			{Character: model.Character{UserInfoResponse: model.UserInfoResponse{CharacterID: 600}}},
		}},
	}
	accountData := model.AccountData{Accounts: accounts, Associations: associations}

	repo.On("FetchAccountData").Return(accountData, nil).Once()
	repo.On("SaveAccountData", mock.Anything).Return(nil).Once()

	// Remove association for userId=300, charId=500
	err := assocSvc.UnassociateCharacter("300", "500")
	assert.NoError(t, err)

	repo.AssertExpectations(t)
}

func TestUnassociateCharacter_NotFound(t *testing.T) {
	logger := &testutil.MockLogger{}
	repo := &testutil.MockAccountDataRepository{}
	esi := &testutil.MockESIService{}

	assocSvc := account.NewAssociationService(logger, repo, esi)

	accountData := model.AccountData{Associations: []model.Association{}}
	repo.On("FetchAccountData").Return(accountData, nil).Once()

	err := assocSvc.UnassociateCharacter("999", "abc")
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "not found")
	repo.AssertExpectations(t)
}

func TestUnassociateCharacter_ResetAccountID(t *testing.T) {
	logger := &testutil.MockLogger{}
	repo := &testutil.MockAccountDataRepository{}
	esi := &testutil.MockESIService{}

	assocSvc := account.NewAssociationService(logger, repo, esi)

	// userId=1000 associated with charId=2000, removing it leaves userId=1000 with no chars
	associations := []model.Association{
		{UserId: "1000", CharId: "2000", CharName: "Char2000"},
	}
	accounts := []model.Account{
		{Name: "AccountFor1000", ID: 1000, Characters: []model.CharacterIdentity{
			{Character: model.Character{UserInfoResponse: model.UserInfoResponse{CharacterID: 2000}}},
		}},
	}
	accountData := model.AccountData{Accounts: accounts, Associations: associations}

	repo.On("FetchAccountData").Return(accountData, nil).Once()
	repo.On("SaveAccountData", mock.Anything).Return(nil).Once()

	err := assocSvc.UnassociateCharacter("1000", "2000")
	assert.NoError(t, err)

	repo.AssertExpectations(t)
}

func TestUnassociateCharacter_SaveError(t *testing.T) {
	logger := &testutil.MockLogger{}
	repo := &testutil.MockAccountDataRepository{}
	esi := &testutil.MockESIService{}

	assocSvc := account.NewAssociationService(logger, repo, esi)

	associations := []model.Association{
		{UserId: "100", CharId: "300", CharName: "Char300"},
	}
	accountData := model.AccountData{Associations: associations}

	repo.On("FetchAccountData").Return(accountData, nil).Once()
	// Removing charId=300 from userId=100 leaves an empty list. Then save fails.
	repo.On("SaveAccountData", mock.Anything).Return(fmt.Errorf("save error")).Once()

	err := assocSvc.UnassociateCharacter("100", "300")
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "save error")
	repo.AssertExpectations(t)
}

================
File: internal/services/account/association_service.go
================
// services/association/association_service.go
package account

import (
	"fmt"
	"strconv"

	"github.com/guarzo/canifly/internal/model"
	"github.com/guarzo/canifly/internal/services/interfaces"
)

var _ interfaces.AssociationService = (*associationService)(nil)

type associationService struct {
	logger      interfaces.Logger
	accountRepo interfaces.AccountDataRepository
	esi         interfaces.ESIService
}

func NewAssociationService(logger interfaces.Logger, accountRepo interfaces.AccountDataRepository, esi interfaces.ESIService) interfaces.AssociationService {
	return &associationService{
		logger:      logger,
		accountRepo: accountRepo,
		esi:         esi,
	}
}

func (assoc *associationService) UpdateAssociationsAfterNewCharacter(account *model.Account, charID int64) error {
	accountData, err := assoc.accountRepo.FetchAccountData()
	if err != nil {
		return err
	}

	updatedAssociations, err := assoc.syncAccountWithUserFileAndAssociations(account, charID, accountData.Associations)
	if err != nil {
		return err
	}

	accountData.Associations = updatedAssociations
	if err := assoc.accountRepo.SaveAccountData(accountData); err != nil {
		return err
	}
	return nil
}

func (assoc *associationService) AssociateCharacter(userId, charId string) error {
	accountData, err := assoc.accountRepo.FetchAccountData()
	if err != nil {
		return fmt.Errorf("failed to fetch account data: %w", err)
	}
	associations := accountData.Associations
	associations, err = assoc.associateCharacter(userId, charId, associations)
	if err != nil {
		return err
	}
	accountData.Associations = associations

	assoc.logger.Infof("assocations after associate character %v", associations)

	charIdInt, err := strconv.ParseInt(charId, 10, 64)
	if err != nil {
		return fmt.Errorf("invalid charId %s: %w", charId, err)
	}

	userIdInt, err := strconv.ParseInt(userId, 10, 64)
	if err != nil {
		return fmt.Errorf("invalid userId %s: %w", userId, err)
	}

	foundAccount := assoc.findAccountByCharacterID(accountData.Accounts, charIdInt)
	if foundAccount == nil {
		assoc.logger.Infof("no matching account found for charId %s", charId)
	} else if foundAccount.ID != userIdInt {
		foundAccount.ID = userIdInt
		updatedAssociations, err := assoc.associateMissingCharacters(foundAccount, userId, accountData.Associations)
		if err != nil {
			assoc.logger.Warnf("failed to associate missing characters for account %s, userId %s: %v", foundAccount.Name, userId, err)
		} else {
			accountData.Associations = updatedAssociations
		}
	}

	assoc.logger.Infof("assocations after assign missing %v", associations)

	if err = assoc.accountRepo.SaveAccountData(accountData); err != nil {
		return fmt.Errorf("failed to save updated account data: %w", err)
	}

	return nil
}

func (assoc *associationService) UnassociateCharacter(userId, charId string) error {
	accountData, err := assoc.accountRepo.FetchAccountData()
	if err != nil {
		return fmt.Errorf("failed to fetch account data: %w", err)
	}

	associations := accountData.Associations
	index := -1
	for i, a := range associations {
		if a.UserId == userId && a.CharId == charId {
			index = i
			break
		}
	}

	if index == -1 {
		return fmt.Errorf("association between User ID %s and Character ID %s not found", userId, charId)
	}

	// Remove the association
	associations = append(associations[:index], associations[index+1:]...)

	// Check if userId still has any associated characters
	hasAssociations := false
	for _, a := range associations {
		if a.UserId == userId {
			hasAssociations = true
			break
		}
	}

	// If no associations remain for this userId
	if !hasAssociations {
		assoc.logger.Infof("No more associations for userId %s. Resetting name and account if needed.", userId)

		// Reset account if needed
		accounts := accountData.Accounts
		userIdInt, err := strconv.ParseInt(userId, 10, 64)
		if err == nil && userIdInt != 0 {
			// Find account with ID == userIdInt and reset it
			for i := range accounts {
				if accounts[i].ID == userIdInt {
					assoc.logger.Infof("Resetting account with ID %d since no associations remain", userIdInt)
					accounts[i].ID = 0
					break
				}
			}
		}
		accountData.Accounts = accounts
	}

	// Save the updated account data
	accountData.Associations = associations
	if err := assoc.accountRepo.SaveAccountData(accountData); err != nil {
		return fmt.Errorf("failed to save updated account data: %w", err)
	}

	return nil
}

func (assoc *associationService) updateAccountId(account *model.Account, userID string) error {
	convertedFoundUserID, err := strconv.ParseInt(userID, 10, 64)
	if err != nil {
		return err
	}

	if convertedFoundUserID != account.ID {
		account.ID = convertedFoundUserID
	}

	return nil
}

func (assoc *associationService) getUserIdWithCharId(associations []model.Association, charID string) (string, error) {
	assocCharIds := assoc.getAssociationMap(associations)
	foundUserID, ok := assocCharIds[charID]
	if !ok {
		return "", fmt.Errorf("no matching user file for character id %s", charID)
	}
	return foundUserID, nil
}

func (assoc *associationService) getAssociationMap(associations []model.Association) map[string]string {
	assocCharIds := make(map[string]string)
	for _, a := range associations {
		assocCharIds[a.CharId] = a.UserId
	}
	return assocCharIds
}

func (assoc *associationService) findAccountByCharacterID(accounts []model.Account, charIdInt int64) *model.Account {
	for i := range accounts {
		for j := range accounts[i].Characters {
			if accounts[i].Characters[j].Character.CharacterID == charIdInt {
				return &accounts[i]
			}
		}
	}
	return nil
}

func (assoc *associationService) associateCharacter(userId string, charId string, associations []model.Association) ([]model.Association, error) {
	// Enforce a maximum of 3 characters per user
	userAssociations := 0
	for _, a := range associations {
		if a.UserId == userId {
			userAssociations++
		}
	}
	if userAssociations >= 3 {
		return nil, fmt.Errorf("user ID %s already has the maximum of 3 associated characters", userId)
	}

	if err := checkForExistingAssociation(associations, charId); err != nil {
		assoc.logger.Errorf("already associated")
		return nil, err
	}

	character, err := assoc.esi.GetCharacter(charId)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch character name for ID %s: %v", charId, err)
	}

	associations = append(associations, model.Association{
		UserId:   userId,
		CharId:   charId,
		CharName: character.Name,
	})
	assoc.logger.Infof("associated userfile %s with character %s-%s", userId, charId, character.Name)

	return associations, nil
}

func checkForExistingAssociation(associations []model.Association, charId string) error {
	for _, assoc := range associations {
		if assoc.CharId == charId {
			return fmt.Errorf("character ID %s is already associated with User ID %s", charId, assoc.UserId)
		}
	}
	return nil
}

func (assoc *associationService) associateMissingCharacters(foundAccount *model.Account, userId string, associations []model.Association) ([]model.Association, error) {
	assocCharIds := assoc.getAssociationMap(associations)

	for _, ch := range foundAccount.Characters {
		cidStr := fmt.Sprintf("%d", ch.Character.CharacterID)
		err := checkForExistingAssociation(associations, cidStr)
		if _, hasId := assocCharIds[cidStr]; !hasId && err == nil {
			updatedAssociations, err := assoc.associateCharacter(userId, cidStr, associations)
			if err != nil {
				assoc.logger.Warnf("failed to associate character %d: %v", ch.Character.CharacterID, err)
			} else {
				associations = updatedAssociations
			}
			assocCharIds[cidStr] = userId
		} else {
			assocCharIds[cidStr] = userId
			assoc.logger.Debugf("character %s already associated", ch.Character.CharacterName)
		}
	}
	return associations, nil
}

func (assoc *associationService) syncAccountWithUserFileAndAssociations(
	account *model.Account,
	charID int64,
	associations []model.Association,
) ([]model.Association, error) {
	foundUserID, err := assoc.getUserIdWithCharId(associations, strconv.FormatInt(charID, 10))
	if err != nil {
		return nil, err
	}

	if err = assoc.updateAccountId(account, foundUserID); err != nil {
		return nil, fmt.Errorf("failed to update account id: %w", err)
	}
	assoc.logger.Infof("associated user: %s with account %s", foundUserID, account.Name)

	updatedAssociations, err := assoc.associateMissingCharacters(account, foundUserID, associations)
	if err != nil {
		assoc.logger.Warnf("failed to associate missing characters for account %s, userId %s: %v", account.Name, foundUserID, err)
		return associations, nil // intentionally not returning the error to allow the account update to save
	}

	return updatedAssociations, nil
}

================
File: internal/services/account/auth_client.go
================
// auth/auth_client.go
package account

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"golang.org/x/oauth2"

	"github.com/guarzo/canifly/internal/services/interfaces"
)

var _ interfaces.AuthClient = (*authClient)(nil)

const (
	tokenURL        = "https://login.eveonline.com/v2/oauth/token"
	requestTimeout  = 10 * time.Second
	contentType     = "application/x-www-form-urlencoded"
	authorization   = "Authorization"
	contentTypeName = "Content-Type"
)

// authClient is a concrete implementation of AuthClient
type authClient struct {
	logger interfaces.Logger
	config *oauth2.Config
	client *http.Client
}

// NewAuthClient initializes and returns an AuthClient implementation.
func NewAuthClient(logger interfaces.Logger, clientID, clientSecret, callbackURL string) interfaces.AuthClient {
	return &authClient{
		logger: logger,
		config: &oauth2.Config{
			ClientID:     clientID,
			ClientSecret: clientSecret,
			RedirectURL:  callbackURL,
			Scopes: []string{
				"publicData",
				"esi-location.read_location.v1",
				"esi-skills.read_skills.v1",
				"esi-clones.read_clones.v1",
				"esi-clones.read_implants.v1",
				"esi-skills.read_skillqueue.v1",
				"esi-characters.read_corporation_roles.v1",
			},
			Endpoint: oauth2.Endpoint{
				AuthURL:  "https://login.eveonline.com/v2/oauth/authorize",
				TokenURL: tokenURL,
			},
		},
		// Inject a custom HTTP client if needed, otherwise use default
		client: &http.Client{Timeout: requestTimeout},
	}
}

// GetAuthURL returns the URL for OAuth2 authentication
func (a *authClient) GetAuthURL(state string) string {
	return a.config.AuthCodeURL(state)
}

// ExchangeCode exchanges the authorization code for an access token
func (a *authClient) ExchangeCode(code string) (*oauth2.Token, error) {
	token, err := a.config.Exchange(context.Background(), code)
	if err != nil {
		a.logger.Errorf("Failed to exchange code: %v", err)
		return nil, fmt.Errorf("failed to exchange code: %w", err)
	}
	return token, nil
}

// RefreshToken performs a token refresh using the current oauth2.Config
func (a *authClient) RefreshToken(refreshToken string) (*oauth2.Token, error) {
	data := url.Values{}
	data.Set("grant_type", "refresh_token")
	data.Set("refresh_token", refreshToken)

	req, err := http.NewRequest(http.MethodPost, tokenURL, strings.NewReader(data.Encode()))
	if err != nil {
		a.logger.Errorf("Failed to create request to refresh token: %v", err)
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	req.Header.Add(contentTypeName, contentType)
	req.Header.Add(authorization, "Basic "+base64.StdEncoding.EncodeToString([]byte(a.config.ClientID+":"+a.config.ClientSecret)))

	resp, err := a.client.Do(req)
	if err != nil {
		a.logger.Errorf("Failed to make request to refresh token: %v", err)
		return nil, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		bodyBytes, readErr := io.ReadAll(resp.Body)
		if readErr != nil {
			a.logger.Infof("Failed to read response body: %v", readErr)
			return nil, fmt.Errorf("failed to read response body: %w", readErr)
		}
		bodyString := string(bodyBytes)

		a.logger.Warnf("Received non-OK status code %d for request to refresh token. Response body: %s", resp.StatusCode, bodyString)
		return nil, fmt.Errorf("received non-OK status code %d: %s", resp.StatusCode, bodyString)
	}

	var token oauth2.Token
	if decodeErr := json.NewDecoder(resp.Body).Decode(&token); decodeErr != nil {
		a.logger.Errorf("Failed to decode response body: %v", decodeErr)
		return nil, fmt.Errorf("failed to decode response: %w", decodeErr)
	}

	return &token, nil
}

================
File: internal/services/account/login_service.go
================
package account

import (
	"errors"
	"github.com/guarzo/canifly/internal/model"
	"github.com/guarzo/canifly/internal/persist"
	"github.com/guarzo/canifly/internal/services/interfaces"
)

var _ interfaces.LoginService = (*loginService)(nil)

type loginService struct {
	logger    interfaces.Logger
	loginRepo interfaces.LoginRepository
}

func NewLoginService(logger interfaces.Logger, loginRepo interfaces.LoginRepository) interfaces.LoginService {
	return &loginService{
		logger:    logger,
		loginRepo: loginRepo,
	}
}

func (l *loginService) GenerateAndStoreInitialState(value string) (string, error) {
	state, err := persist.GenerateRandomString(16)
	if err != nil {
		return "", err
	}
	l.loginRepo.Set(state, &model.AuthStatus{
		AccountName:      value,
		CallBackComplete: false,
	})
	return state, nil
}

func (l *loginService) ResolveAccountAndStatusByState(state string) (string, bool, bool) {
	authStatus, ok := l.loginRepo.Get(state)
	if !ok {
		return "", false, false
	}
	return authStatus.AccountName, authStatus.CallBackComplete, true
}

func (l *loginService) UpdateStateStatusAfterCallBack(state string) error {
	authStatus, ok := l.loginRepo.Get(state)
	if !ok {
		return errors.New("unable to retrieve authStatus for provided state")
	}
	authStatus.CallBackComplete = true
	l.loginRepo.Set(state, authStatus)
	return nil
}

func (l *loginService) ClearState(state string) {
	l.loginRepo.Delete(state)
}

================
File: internal/services/config/appstate_service.go
================
// services/state/appstate_service.go
package config

import (
	"fmt"

	"github.com/guarzo/canifly/internal/model"
	"github.com/guarzo/canifly/internal/services/interfaces"
)

var _ interfaces.AppStateService = (*appStateService)(nil)

type appStateService struct {
	logger    interfaces.Logger
	stateRepo interfaces.AppStateRepository
}

func NewAppStateService(logger interfaces.Logger, ds interfaces.AppStateRepository) interfaces.AppStateService {
	return &appStateService{
		logger:    logger,
		stateRepo: ds,
	}
}

func (s *appStateService) GetAppState() model.AppState {
	return s.stateRepo.GetAppState()
}

func (s *appStateService) SetAppStateLogin(isLoggedIn bool) error {
	if err := s.stateRepo.SetAppStateLogin(isLoggedIn); err != nil {
		return fmt.Errorf("failed to set login state: %w", err)
	}
	return nil
}

func (s *appStateService) UpdateAndSaveAppState(data model.AppState) error {
	s.stateRepo.SetAppState(data)
	if err := s.stateRepo.SaveAppStateSnapshot(data); err != nil {
		return fmt.Errorf("failed to save app state snapshot: %w", err)
	}
	return nil
}

func (s *appStateService) ClearAppState() {
	s.stateRepo.ClearAppState()
}

================
File: internal/services/config/config_service_test.go
================
package config_test

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/guarzo/canifly/internal/model"
	"github.com/guarzo/canifly/internal/services/config"
	"github.com/guarzo/canifly/internal/testutil"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

func TestUpdateSettingsDir_Success(t *testing.T) {
	logger := &testutil.MockLogger{}
	repo := &testutil.MockConfigRepository{}
	svc := config.NewConfigService(logger, repo)

	configData := &model.ConfigData{
		Roles: []string{},
	}

	repo.On("FetchConfigData").Return(configData, nil).Once()

	existingDir := t.TempDir() // create a directory that actually exists
	// Now os.Stat(existingDir) should not return an error

	repo.On("SaveConfigData", mock.Anything).Return(nil).Once()

	err := svc.UpdateSettingsDir(existingDir)
	assert.NoError(t, err)
	assert.Equal(t, existingDir, configData.SettingsDir)

	repo.AssertExpectations(t)
}

func TestUpdateSettingsDir_DirNotExist(t *testing.T) {
	logger := &testutil.MockLogger{}
	repo := &testutil.MockConfigRepository{}
	svc := config.NewConfigService(logger, repo)

	configData := &model.ConfigData{}

	repo.On("FetchConfigData").Return(configData, nil).Once()

	nonExistentDir := filepath.Join(os.TempDir(), "ThisShouldNotExist-12345")

	err := svc.UpdateSettingsDir(nonExistentDir)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "unable to find directory")

	repo.AssertExpectations(t) // Save not called
}

func TestUpdateBackupDir(t *testing.T) {
	logger := &testutil.MockLogger{}
	repo := &testutil.MockConfigRepository{}
	svc := config.NewConfigService(logger, repo)

	configData := &model.ConfigData{}
	repo.On("FetchConfigData").Return(configData, nil).Once()
	repo.On("SaveConfigData", mock.Anything).Return(nil).Once()

	err := svc.UpdateBackupDir("/backup/path")
	assert.NoError(t, err)
	assert.Equal(t, "/backup/path", configData.LastBackupDir)

	repo.AssertExpectations(t)
}

func TestGetSettingsDir(t *testing.T) {
	logger := &testutil.MockLogger{}
	repo := &testutil.MockConfigRepository{}
	svc := config.NewConfigService(logger, repo)

	configData := &model.ConfigData{SettingsDir: "/some/dir"}
	repo.On("FetchConfigData").Return(configData, nil).Once()

	dir, err := svc.GetSettingsDir()
	assert.NoError(t, err)
	assert.Equal(t, "/some/dir", dir)

	repo.AssertExpectations(t)
}

func TestFetchUserSelections(t *testing.T) {
	logger := &testutil.MockLogger{}
	repo := &testutil.MockConfigRepository{}
	svc := config.NewConfigService(logger, repo)

	selections := model.DropDownSelections{"option1": {CharId: "c1", UserId: "u1"}}
	repo.On("FetchUserSelections").Return(selections, nil).Once()

	result, err := svc.FetchUserSelections()
	assert.NoError(t, err)
	assert.Equal(t, selections, result)

	repo.AssertExpectations(t)
}

func TestSaveUserSelections(t *testing.T) {
	logger := &testutil.MockLogger{}
	repo := &testutil.MockConfigRepository{}
	svc := config.NewConfigService(logger, repo)

	newSelections := model.DropDownSelections{"option2": {CharId: "c2", UserId: "u2"}}
	repo.On("SaveUserSelections", newSelections).Return(nil).Once()

	err := svc.SaveUserSelections(newSelections)
	assert.NoError(t, err)

	repo.AssertExpectations(t)
}

func TestEnsureSettingsDir_AlreadySetAndExists(t *testing.T) {
	logger := &testutil.MockLogger{}
	repo := &testutil.MockConfigRepository{}
	svc := config.NewConfigService(logger, repo)

	existingDir := t.TempDir()
	configData := &model.ConfigData{SettingsDir: existingDir}
	repo.On("FetchConfigData").Return(configData, nil).Once()

	// If directory exists and accessible, no need to call Save or GetDefaultSettingsDir
	err := svc.EnsureSettingsDir()
	assert.NoError(t, err)

	repo.AssertExpectations(t)
}

func TestEnsureSettingsDir_UseDefaultDir(t *testing.T) {
	logger := &testutil.MockLogger{}
	repo := &testutil.MockConfigRepository{}
	svc := config.NewConfigService(logger, repo)

	configData := &model.ConfigData{SettingsDir: ""}
	repo.On("FetchConfigData").Return(configData, nil).Once()

	// Mock default dir
	defaultDir := t.TempDir() // directory that exists
	repo.On("GetDefaultSettingsDir").Return(defaultDir, nil).Once()

	// Since defaultDir exists, we just set it and save
	repo.On("SaveConfigData", mock.Anything).Return(nil).Once()

	err := svc.EnsureSettingsDir()
	assert.NoError(t, err)
	assert.Equal(t, defaultDir, configData.SettingsDir)

	repo.AssertExpectations(t)
}

func TestEnsureSettingsDir_DefaultDirNotExistAndFind(t *testing.T) {
	// This is a more complex scenario:
	// If defaultDir does not exist, it tries to findEveSettingsDir in homeDir.
	// We'll skip actually searching. Let's just return error from defaultDir and ensure error propogates
	logger := &testutil.MockLogger{}
	repo := &testutil.MockConfigRepository{}
	svc := config.NewConfigService(logger, repo)

	configData := &model.ConfigData{SettingsDir: ""}
	repo.On("FetchConfigData").Return(configData, nil).Once()

	// return a defaultDir that doesn't exist
	nonExistDir := filepath.Join(os.TempDir(), "NoSuchDefaultDir-123")
	repo.On("GetDefaultSettingsDir").Return(nonExistDir, nil).Once()

	// Now it tries to find "c_ccp_eve_online_tq_tranquility". We'll skip real search.
	// findEveSettingsDir tries to walk user home, let's mock user home or just let it fail:
	// The code tries to find a directory. If it fails, returns error.
	// We'll rely on the error from findEveSettingsDir since no such directory is found.

	// We can't easily mock os.UserHomeDir or filepath.Walk. We'll rely on the directory not found error:
	// So just check we get a "no directory found" error.
	err := svc.EnsureSettingsDir()
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "failed to find c_ccp_eve_online_tq_tranquility")

	repo.AssertExpectations(t)
}

func TestUpdateRoles_ExistingRole(t *testing.T) {
	logger := &testutil.MockLogger{}
	repo := &testutil.MockConfigRepository{}
	svc := config.NewConfigService(logger, repo)

	roles := []string{"Admin", "User"}
	repo.On("FetchRoles").Return(roles, nil).Once()

	// No need to save if role exists
	err := svc.UpdateRoles("Admin")
	assert.NoError(t, err)

	repo.AssertExpectations(t)
}

func TestUpdateRoles_NewRole(t *testing.T) {
	logger := &testutil.MockLogger{}
	repo := &testutil.MockConfigRepository{}
	svc := config.NewConfigService(logger, repo)

	roles := []string{"Admin"}
	repo.On("FetchRoles").Return(roles, nil).Once()
	// Save updated roles
	repo.On("SaveRoles", []string{"Admin", "Tester"}).Return(nil).Once()

	err := svc.UpdateRoles("Tester")
	assert.NoError(t, err)

	repo.AssertExpectations(t)
}

func TestGetRoles(t *testing.T) {
	logger := &testutil.MockLogger{}
	repo := &testutil.MockConfigRepository{}
	svc := config.NewConfigService(logger, repo)

	roles := []string{"Alpha", "Omega"}
	repo.On("FetchRoles").Return(roles, nil).Once()

	r, err := svc.GetRoles()
	assert.NoError(t, err)
	assert.Equal(t, roles, r)

	repo.AssertExpectations(t)
}

func TestFetchConfigData(t *testing.T) {
	logger := &testutil.MockLogger{}
	repo := &testutil.MockConfigRepository{}
	svc := config.NewConfigService(logger, repo)

	configData := &model.ConfigData{SettingsDir: "/some/path"}
	repo.On("FetchConfigData").Return(configData, nil).Once()

	data, err := svc.FetchConfigData()
	assert.NoError(t, err)
	assert.Equal(t, configData, data)

	repo.AssertExpectations(t)
}

================
File: internal/services/config/config_service.go
================
package config

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/guarzo/canifly/internal/model"
	"github.com/guarzo/canifly/internal/services/interfaces"
)

var _ interfaces.ConfigService = (*configService)(nil)

type configService struct {
	logger     interfaces.Logger
	configRepo interfaces.ConfigRepository
}

func NewConfigService(
	logger interfaces.Logger,
	configRepo interfaces.ConfigRepository,
) interfaces.ConfigService {
	return &configService{
		logger:     logger,
		configRepo: configRepo,
	}
}

func (s *configService) BackupJSONFiles(backupDir string) error {
	return s.configRepo.BackupJSONFiles(backupDir)
}

func (s *configService) UpdateSettingsDir(dir string) error {
	configData, err := s.configRepo.FetchConfigData()
	if err != nil {
		return err
	}

	if _, err = os.Stat(dir); os.IsNotExist(err) {
		return fmt.Errorf("unable to find directory %s: %v", dir, err)
	}

	configData.SettingsDir = dir
	return s.configRepo.SaveConfigData(configData)
}

func (s *configService) UpdateBackupDir(dir string) error {
	configData, err := s.configRepo.FetchConfigData()
	if err != nil {
		return err
	}

	configData.LastBackupDir = dir
	return s.configRepo.SaveConfigData(configData)
}

func (s *configService) GetSettingsDir() (string, error) {
	configData, err := s.configRepo.FetchConfigData()
	if err != nil {
		s.logger.Infof("error fetching config data %v", err)
		return "", err
	}
	return configData.SettingsDir, nil
}

func (s *configService) FetchUserSelections() (model.DropDownSelections, error) {
	return s.configRepo.FetchUserSelections()
}

func (s *configService) SaveUserSelections(selections model.DropDownSelections) error {
	return s.configRepo.SaveUserSelections(selections)
}

func (s *configService) EnsureSettingsDir() error {
	configData, err := s.configRepo.FetchConfigData()
	if err != nil {
		return fmt.Errorf("failed to fetch config data: %w", err)
	}

	if configData.SettingsDir != "" {
		if _, err := os.Stat(configData.SettingsDir); !os.IsNotExist(err) {
			// SettingsDir exists and is accessible
			return nil
		}
		s.logger.Warnf("SettingsDir %s does not exist, attempting to reset to default", configData.SettingsDir)
	}

	defaultDir, err := s.configRepo.GetDefaultSettingsDir()
	if err != nil {
		return err
	}

	if _, err = os.Stat(defaultDir); os.IsNotExist(err) {
		// Attempt to find "c_ccp_eve_online_tq_tranquility"
		homeDir, homeErr := os.UserHomeDir()
		if homeErr != nil {
			return fmt.Errorf("default directory does not exist and failed to get home directory: %v", homeErr)
		}

		searchPath, findErr := s.findEveSettingsDir(homeDir, "c_ccp_eve_online_tq_tranquility")
		if findErr != nil {
			return fmt.Errorf("default directory does not exist and failed to find c_ccp_eve_online_tq_tranquility: %w", findErr)
		}
		configData.SettingsDir = searchPath
	} else {
		configData.SettingsDir = defaultDir
	}

	if err = s.configRepo.SaveConfigData(configData); err != nil {
		return fmt.Errorf("failed to save default SettingsDir: %w", err)
	}

	s.logger.Debugf("Set default SettingsDir to: %s", configData.SettingsDir)
	return nil
}

func (s *configService) findEveSettingsDir(startDir, targetName string) (string, error) {
	var foundPath string
	err := filepath.Walk(startDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return nil // skip errors
		}
		if info.IsDir() && strings.Contains(path, targetName) {
			foundPath = path
			return filepath.SkipDir
		}
		return nil
	})
	if err != nil && !errors.Is(err, filepath.SkipDir) {
		return "", err
	}
	if foundPath == "" {
		return "", fmt.Errorf("no directory containing %q found under %s", targetName, startDir)
	}
	return foundPath, nil
}

func (s *configService) UpdateRoles(newRole string) error {
	roles, err := s.configRepo.FetchRoles()
	if err != nil {
		return err
	}

	for _, role := range roles {
		if role == newRole {
			s.logger.Debugf("role %s already exists", newRole)
			return nil
		}
	}

	roles = append(roles, newRole)
	return s.configRepo.SaveRoles(roles)
}

func (s *configService) SaveRoles(roles []string) error {
	return s.configRepo.SaveRoles(roles)
}

func (s *configService) GetRoles() ([]string, error) {
	return s.configRepo.FetchRoles()
}

func (s *configService) FetchConfigData() (*model.ConfigData, error) {
	return s.configRepo.FetchConfigData()
}

================
File: internal/services/config/dashboard_service_test.go
================
package config_test

import (
	"errors"
	"testing"

	"github.com/guarzo/canifly/internal/model"
	"github.com/guarzo/canifly/internal/services/config"
	"github.com/guarzo/canifly/internal/testutil"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

func TestRefreshAccountsAndState_Success(t *testing.T) {
	logger := &testutil.MockLogger{}
	as := &testutil.MockAccountService{}
	sk := &testutil.MockSkillService{}
	cs := &testutil.MockConfigService{}
	cSvc := &testutil.MockCharacterService{}
	stateSvc := &testutil.MockAppStateService{}
	esi := &testutil.MockEveProfilesService{}

	ds := config.NewDashboardService(logger, sk, cSvc, as, cs, stateSvc, esi)

	accounts := []model.Account{{Name: "Acc1"}}
	as.On("RefreshAccountData", cSvc).Return(&model.AccountData{Accounts: accounts}, nil).Once()

	sk.On("GetSkillPlans").Return(map[string]model.SkillPlan{}).Once()
	sk.On("GetSkillTypes").Return(map[string]model.SkillType{}).Once()
	sk.On("GetPlanAndConversionData", accounts, mock.Anything, mock.Anything).
		Return(map[string]model.SkillPlanWithStatus{}, map[string]string{}).Once()

	esi.On("LoadCharacterSettings").Return([]model.EveProfile{}, nil).Once()
	cs.On("FetchConfigData").Return(&model.ConfigData{}, nil).Once()

	// Add this line to mock UpdateAndSaveAppState
	stateSvc.On("UpdateAndSaveAppState", mock.Anything).Return(nil).Once()

	_, err := ds.RefreshAccountsAndState()
	assert.NoError(t, err)

	as.AssertExpectations(t)
	sk.AssertExpectations(t)
	cs.AssertExpectations(t)
	esi.AssertExpectations(t)
	stateSvc.AssertExpectations(t)
}

func TestRefreshAccountsAndState_AccountDataError(t *testing.T) {
	logger := &testutil.MockLogger{}
	skillSvc := &testutil.MockSkillService{}
	charSvc := &testutil.MockCharacterService{}
	accSvc := &testutil.MockAccountService{}
	conSvc := &testutil.MockConfigService{}
	stateSvc := &testutil.MockAppStateService{}
	eveSvc := &testutil.MockEveProfilesService{}

	ds := config.NewDashboardService(logger, skillSvc, charSvc, accSvc, conSvc, stateSvc, eveSvc)

	accSvc.On("RefreshAccountData", charSvc).Return((*model.AccountData)(nil), errors.New("fetch error")).Once()

	_, err := ds.RefreshAccountsAndState()
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "failed to validate accounts")

	accSvc.AssertExpectations(t)
}

func TestGetCurrentAppState(t *testing.T) {
	logger := &testutil.MockLogger{}
	skillSvc := &testutil.MockSkillService{}
	charSvc := &testutil.MockCharacterService{}
	accSvc := &testutil.MockAccountService{}
	conSvc := &testutil.MockConfigService{}
	stateSvc := &testutil.MockAppStateService{}
	eveSvc := &testutil.MockEveProfilesService{}

	ds := config.NewDashboardService(logger, skillSvc, charSvc, accSvc, conSvc, stateSvc, eveSvc)

	expectedState := model.AppState{LoggedIn: false}
	stateSvc.On("GetAppState").Return(expectedState).Once()

	result := ds.GetCurrentAppState()
	assert.Equal(t, expectedState, result)

	stateSvc.AssertExpectations(t)
}
func TestRefreshDataInBackground_Success(t *testing.T) {
	logger := &testutil.MockLogger{}
	skillSvc := &testutil.MockSkillService{}
	charSvc := &testutil.MockCharacterService{}
	accSvc := &testutil.MockAccountService{}
	conSvc := &testutil.MockConfigService{}
	stateSvc := &testutil.MockAppStateService{}
	eveSvc := &testutil.MockEveProfilesService{}

	ds := config.NewDashboardService(logger, skillSvc, charSvc, accSvc, conSvc, stateSvc, eveSvc)

	accountData := &model.AccountData{
		Accounts: []model.Account{{Name: "SomeAccount"}},
	}
	accSvc.On("RefreshAccountData", charSvc).Return(accountData, nil).Once()

	skillSvc.On("GetSkillPlans").Return(map[string]model.SkillPlan{}).Once()
	skillSvc.On("GetSkillTypes").Return(map[string]model.SkillType{}).Once()
	// Mock GetPlanAndConversionData
	skillSvc.On("GetPlanAndConversionData", accountData.Accounts, mock.Anything, mock.Anything).
		Return(map[string]model.SkillPlanWithStatus{}, map[string]string{}).Once()

	conSvc.On("FetchConfigData").Return(&model.ConfigData{}, nil).Once()
	eveSvc.On("LoadCharacterSettings").Return([]model.EveProfile{}, nil).Once()
	stateSvc.On("UpdateAndSaveAppState", mock.Anything).Return(nil).Once()

	err := ds.RefreshDataInBackground()
	assert.NoError(t, err)

	accSvc.AssertExpectations(t)
	skillSvc.AssertExpectations(t)
	conSvc.AssertExpectations(t)
	eveSvc.AssertExpectations(t)
	stateSvc.AssertExpectations(t)
}

func TestRefreshDataInBackground_Error(t *testing.T) {
	logger := &testutil.MockLogger{}
	skillSvc := &testutil.MockSkillService{}
	charSvc := &testutil.MockCharacterService{}
	accSvc := &testutil.MockAccountService{}
	conSvc := &testutil.MockConfigService{}
	stateSvc := &testutil.MockAppStateService{}
	eveSvc := &testutil.MockEveProfilesService{}

	ds := config.NewDashboardService(logger, skillSvc, charSvc, accSvc, conSvc, stateSvc, eveSvc)

	accSvc.On("RefreshAccountData", charSvc).Return((*model.AccountData)(nil), errors.New("account refresh error")).Once()

	err := ds.RefreshDataInBackground()
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "failed to validate accounts")

	accSvc.AssertExpectations(t)
}

================
File: internal/services/config/dashboard_service.go
================
// services/dashboard/dashboard_service.go
package config

import (
	"fmt"
	"time"

	"github.com/guarzo/canifly/internal/model"
	"github.com/guarzo/canifly/internal/services/interfaces"
)

var _ interfaces.DashboardService = (*dashboardService)(nil)

type dashboardService struct {
	logger            interfaces.Logger
	skillService      interfaces.SkillService
	characterService  interfaces.CharacterService
	accountService    interfaces.AccountService
	configService     interfaces.ConfigService
	eveProfileService interfaces.EveProfilesService
	stateService      interfaces.AppStateService
}

func NewDashboardService(
	logger interfaces.Logger,
	skillSvc interfaces.SkillService,
	charSvc interfaces.CharacterService,
	accSvc interfaces.AccountService,
	conSvc interfaces.ConfigService,
	stateSvc interfaces.AppStateService,
	eveSvc interfaces.EveProfilesService,
) interfaces.DashboardService {
	return &dashboardService{
		logger:            logger,
		skillService:      skillSvc,
		characterService:  charSvc,
		accountService:    accSvc,
		configService:     conSvc,
		stateService:      stateSvc,
		eveProfileService: eveSvc,
	}
}

func (d *dashboardService) RefreshAccountsAndState() (model.AppState, error) {

	accountData, err := d.accountService.RefreshAccountData(d.characterService)
	if err != nil {
		return model.AppState{}, fmt.Errorf("failed to validate accounts: %v", err)
	}

	updatedData := d.prepareAppData(accountData)

	if err = d.stateService.UpdateAndSaveAppState(updatedData); err != nil {
		d.logger.Errorf("Failed to update persist and session: %v", err)
	}

	return updatedData, nil
}

func (d *dashboardService) GetCurrentAppState() model.AppState {
	return d.stateService.GetAppState()
}

func (d *dashboardService) prepareAppData(accountData *model.AccountData) model.AppState {
	skillPlans, eveConversions := d.skillService.GetPlanAndConversionData(
		accountData.Accounts,
		d.skillService.GetSkillPlans(),
		d.skillService.GetSkillTypes(),
	)

	configData, err := d.configService.FetchConfigData()
	if err != nil {
		d.logger.Errorf("Failed to fetch config data: %v", err)
		configData = &model.ConfigData{}
	}

	subDirData, err := d.eveProfileService.LoadCharacterSettings()

	if err != nil {
		d.logger.Errorf("Failed to load character settings: %v", err)
	}

	eveData := &model.EveData{
		EveProfiles:    subDirData,
		SkillPlans:     skillPlans,
		EveConversions: eveConversions,
	}

	return model.AppState{
		LoggedIn:    true,
		AccountData: *accountData,
		EveData:     *eveData,
		ConfigData:  *configData,
	}
}

func (d *dashboardService) RefreshDataInBackground() error {
	start := time.Now()
	d.logger.Debugf("Refreshing data in background...")

	_, err := d.RefreshAccountsAndState()
	if err != nil {
		d.logger.Errorf("Failed in background refresh: %v", err)
		return err
	}

	timeElapsed := time.Since(start)
	d.logger.Infof("Background refresh complete in %s", timeElapsed)
	return nil
}

================
File: internal/services/config/logrus_adapter.go
================
// services/config/logrus_adapter.go
package config

import (
	"github.com/sirupsen/logrus"

	"github.com/guarzo/canifly/internal/services/interfaces"
)

type LogrusAdapter struct {
	entry *logrus.Entry
}

func NewLogrusAdapter(l *logrus.Logger) interfaces.Logger {
	return &LogrusAdapter{entry: logrus.NewEntry(l)}
}

func (l *LogrusAdapter) Debug(args ...interface{}) {
	l.entry.Debug(args...)
}

func (l *LogrusAdapter) Debugf(format string, args ...interface{}) {
	l.entry.Debugf(format, args...)
}

func (l *LogrusAdapter) Info(args ...interface{}) {
	l.entry.Info(args...)
}

func (l *LogrusAdapter) Infof(format string, args ...interface{}) {
	l.entry.Infof(format, args...)
}

func (l *LogrusAdapter) Warn(args ...interface{}) {
	l.entry.Warn(args...)
}

func (l *LogrusAdapter) Warnf(format string, args ...interface{}) {
	l.entry.Warnf(format, args...)
}

func (l *LogrusAdapter) Error(args ...interface{}) {
	l.entry.Error(args...)
}

func (l *LogrusAdapter) Errorf(format string, args ...interface{}) {
	l.entry.Errorf(format, args...)
}

func (l *LogrusAdapter) Fatal(args ...interface{}) {
	l.entry.Fatal(args...)
}

func (l *LogrusAdapter) Fatalf(format string, args ...interface{}) {
	l.entry.Fatalf(format, args...)
}

// WithError creates a new LogrusAdapter with the error field set, returning Logger
func (l *LogrusAdapter) WithError(err error) interfaces.Logger {
	return &LogrusAdapter{entry: l.entry.WithError(err)}
}

func (l *LogrusAdapter) WithField(key string, value interface{}) interfaces.Logger {
	return &LogrusAdapter{entry: l.entry.WithField(key, value)}
}

func (l *LogrusAdapter) WithFields(fields map[string]interface{}) interfaces.Logger {
	return &LogrusAdapter{
		entry: l.entry.WithFields(logrus.Fields(fields)),
	}
}

================
File: internal/services/eve/cache_service.go
================
// services/cache/cache_service.go
package eve

import (
	"time"

	"github.com/guarzo/canifly/internal/services/interfaces"
)

var _ interfaces.CacheService = (*cacheService)(nil)

type cacheService struct {
	logger       interfaces.Logger
	persistCache interfaces.CacheRepository // We'll define CacheRepository below
}

func NewCacheService(logger interfaces.Logger, persistCache interfaces.CacheRepository) interfaces.CacheService {
	return &cacheService{
		logger:       logger,
		persistCache: persistCache,
	}
}

func (c *cacheService) Get(key string) ([]byte, bool) {
	return c.persistCache.Get(key)
}

func (c *cacheService) Set(key string, value []byte, expiration time.Duration) {
	c.persistCache.Set(key, value, expiration)
}

func (c *cacheService) LoadCache() error {
	return c.persistCache.LoadApiCache()
}

func (c *cacheService) SaveCache() error {
	return c.persistCache.SaveApiCache()
}

================
File: internal/services/eve/character_service_test.go
================
package eve_test

import (
	"errors"
	"testing"
	"time"

	"github.com/guarzo/canifly/internal/model"
	"github.com/guarzo/canifly/internal/services/eve"
	"github.com/guarzo/canifly/internal/testutil"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"golang.org/x/oauth2"
)

func TestProcessIdentity_Success(t *testing.T) {
	esi := &testutil.MockESIService{}
	logger := &testutil.MockLogger{}
	sys := &testutil.MockSystemRepository{}
	sk := &testutil.MockSkillService{}
	as := &testutil.MockAccountService{}
	cs := &testutil.MockConfigService{}

	charSvc := eve.NewCharacterService(esi, logger, sys, sk, as, cs)

	charId := int64(12345)
	charIdentity := &model.CharacterIdentity{
		Token: oauth2.Token{},
		Character: model.Character{
			UserInfoResponse: model.UserInfoResponse{CharacterID: charId},
		},
	}

	user := &model.UserInfoResponse{CharacterID: charId, CharacterName: "TestChar"}
	esi.On("GetUserInfo", &charIdentity.Token).Return(user, nil).Once()

	// Mock GetCharacter call
	charResp := &model.CharacterResponse{
		CorporationID:  456,
		Name:           "TestChar",
		Birthday:       time.Now().AddDate(-1, 0, 0),
		SecurityStatus: 5.0,
	}
	esi.On("GetCharacter", "12345").Return(charResp, nil).Once()

	// Mock GetCorporation call
	corpResp := &model.Corporation{
		Name:       "TestCorp",
		AllianceID: 789,
	}
	esi.On("GetCorporation", int64(456), &charIdentity.Token).Return(corpResp, nil).Once()

	// Mock GetAlliance call
	allianceResp := &model.Alliance{Name: "TestAlliance"}
	esi.On("GetAlliance", int64(789), &charIdentity.Token).Return(allianceResp, nil).Once()

	skills := &model.CharacterSkillsResponse{Skills: []model.SkillResponse{{SkillID: 1}}}
	esi.On("GetCharacterSkills", charId, &charIdentity.Token).Return(skills, nil).Once()

	queue := &[]model.SkillQueue{
		{
			SkillID:    100,
			StartDate:  timePtr(time.Now().Add(-1 * time.Hour)),
			FinishDate: timePtr(time.Now().Add(1 * time.Hour)), // currently training
		},
	}
	esi.On("GetCharacterSkillQueue", charId, &charIdentity.Token).Return(queue, nil).Once()

	esi.On("GetCharacterLocation", charId, &charIdentity.Token).Return(int64(1000), nil).Once()

	sys.On("GetSystemName", int64(1000)).Return("Jita").Once()

	// MCT scenario: GetSkillName called
	sk.On("GetSkillName", int32(100)).Return("Some Skill").Once()

	esi.On("SaveEsiCache").Return(nil).Once()

	updated, err := charSvc.ProcessIdentity(charIdentity)
	assert.NoError(t, err)
	assert.Equal(t, "TestChar", updated.Character.CharacterName)
	assert.Len(t, updated.Character.Skills, 1)
	assert.Len(t, updated.Character.SkillQueue, 1)
	assert.Equal(t, "Jita", updated.Character.LocationName)
	assert.True(t, updated.MCT)
	assert.Equal(t, "Some Skill", updated.Training)
	assert.Equal(t, "TestCorp", updated.CorporationName)
	assert.Equal(t, "TestAlliance", updated.AllianceName)

	esi.AssertExpectations(t)
	sys.AssertExpectations(t)
	sk.AssertExpectations(t)
}

func TestProcessIdentity_UserInfoError(t *testing.T) {
	esi := &testutil.MockESIService{}
	logger := &testutil.MockLogger{}
	sys := &testutil.MockSystemRepository{}
	sk := &testutil.MockSkillService{}
	as := &testutil.MockAccountService{}
	cs := &testutil.MockConfigService{}

	charSvc := eve.NewCharacterService(esi, logger, sys, sk, as, cs)

	charIdentity := &model.CharacterIdentity{Token: oauth2.Token{}}
	esi.On("GetUserInfo", &charIdentity.Token).Return((*model.UserInfoResponse)(nil), errors.New("user info error")).Once()

	_, err := charSvc.ProcessIdentity(charIdentity)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "failed to get user info")

	esi.AssertExpectations(t)
}

func TestDoesCharacterExist_Found(t *testing.T) {
	esi := &testutil.MockESIService{}
	logger := &testutil.MockLogger{}
	sys := &testutil.MockSystemRepository{}
	sk := &testutil.MockSkillService{}
	as := &testutil.MockAccountService{}
	cs := &testutil.MockConfigService{}

	charSvc := eve.NewCharacterService(esi, logger, sys, sk, as, cs)

	accounts := []model.Account{
		{
			Name: "Acc1",
			Characters: []model.CharacterIdentity{
				{Character: model.Character{UserInfoResponse: model.UserInfoResponse{CharacterID: 9999}}},
			},
		},
	}

	as.On("FetchAccounts").Return(accounts, nil).Once()

	found, charId, err := charSvc.DoesCharacterExist(9999)
	assert.NoError(t, err)
	assert.True(t, found)
	assert.Equal(t, int64(9999), charId.Character.CharacterID)

	as.AssertExpectations(t)
}

func TestDoesCharacterExist_NotFound(t *testing.T) {
	esi := &testutil.MockESIService{}
	logger := &testutil.MockLogger{}
	sys := &testutil.MockSystemRepository{}
	sk := &testutil.MockSkillService{}
	as := &testutil.MockAccountService{}
	cs := &testutil.MockConfigService{}

	charSvc := eve.NewCharacterService(esi, logger, sys, sk, as, cs)

	as.On("FetchAccounts").Return([]model.Account{}, nil).Once()

	found, _, err := charSvc.DoesCharacterExist(1234)
	assert.NoError(t, err)
	assert.False(t, found)

	as.AssertExpectations(t)
}

func TestDoesCharacterExist_Error(t *testing.T) {
	esi := &testutil.MockESIService{}
	logger := &testutil.MockLogger{}
	sys := &testutil.MockSystemRepository{}
	sk := &testutil.MockSkillService{}
	as := &testutil.MockAccountService{}
	cs := &testutil.MockConfigService{}

	charSvc := eve.NewCharacterService(esi, logger, sys, sk, as, cs)

	// Return an error and a typed nil slice
	as.On("FetchAccounts").Return([]model.Account(nil), errors.New("fetch error")).Once()

	found, _, err := charSvc.DoesCharacterExist(111)
	assert.Error(t, err)
	assert.False(t, found)
	assert.Contains(t, err.Error(), "failed to fetch accounts")

	as.AssertExpectations(t)
}

func TestUpdateCharacterFields_Success(t *testing.T) {
	esi := &testutil.MockESIService{}
	logger := &testutil.MockLogger{}
	sys := &testutil.MockSystemRepository{}
	sk := &testutil.MockSkillService{}
	as := &testutil.MockAccountService{}
	cs := &testutil.MockConfigService{}

	charSvc := eve.NewCharacterService(esi, logger, sys, sk, as, cs)

	accounts := []model.Account{
		{
			Name: "Acc1",
			Characters: []model.CharacterIdentity{
				{Role: "OldRole", Character: model.Character{UserInfoResponse: model.UserInfoResponse{CharacterID: 9999}}},
			},
		},
	}

	as.On("FetchAccounts").Return(accounts, nil).Once()
	cs.On("UpdateRoles", "NewRole").Return(nil).Once()
	as.On("SaveAccounts", mock.Anything).Return(nil).Once()

	err := charSvc.UpdateCharacterFields(9999, map[string]interface{}{"Role": "NewRole"})
	assert.NoError(t, err)

	as.AssertExpectations(t)
	cs.AssertExpectations(t)
}

func TestUpdateCharacterFields_UnknownField(t *testing.T) {
	esi := &testutil.MockESIService{}
	logger := &testutil.MockLogger{}
	sys := &testutil.MockSystemRepository{}
	sk := &testutil.MockSkillService{}
	as := &testutil.MockAccountService{}
	cs := &testutil.MockConfigService{}

	charSvc := eve.NewCharacterService(esi, logger, sys, sk, as, cs)

	accounts := []model.Account{
		{
			Name: "Acc1",
			Characters: []model.CharacterIdentity{
				{Character: model.Character{UserInfoResponse: model.UserInfoResponse{CharacterID: 123}}},
			},
		},
	}

	as.On("FetchAccounts").Return(accounts, nil).Once()

	err := charSvc.UpdateCharacterFields(123, map[string]interface{}{"Unknown": "Field"})
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "unknown update field")

	as.AssertExpectations(t)
}

func TestUpdateCharacterFields_SaveError(t *testing.T) {
	esi := &testutil.MockESIService{}
	logger := &testutil.MockLogger{}
	sys := &testutil.MockSystemRepository{}
	sk := &testutil.MockSkillService{}
	as := &testutil.MockAccountService{}
	cs := &testutil.MockConfigService{}

	charSvc := eve.NewCharacterService(esi, logger, sys, sk, as, cs)

	accounts := []model.Account{
		{
			Name: "Acc1",
			Characters: []model.CharacterIdentity{
				{Character: model.Character{UserInfoResponse: model.UserInfoResponse{CharacterID: 9999}}},
			},
		},
	}

	as.On("FetchAccounts").Return(accounts, nil).Once()
	cs.On("UpdateRoles", "Admin").Return(nil).Once()
	as.On("SaveAccounts", mock.Anything).Return(errors.New("save error")).Once()

	err := charSvc.UpdateCharacterFields(9999, map[string]interface{}{"Role": "Admin"})
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "failed to save accounts")
}

func TestRemoveCharacter_Success(t *testing.T) {
	esi := &testutil.MockESIService{}
	logger := &testutil.MockLogger{}
	sys := &testutil.MockSystemRepository{}
	sk := &testutil.MockSkillService{}
	as := &testutil.MockAccountService{}
	cs := &testutil.MockConfigService{}

	charSvc := eve.NewCharacterService(esi, logger, sys, sk, as, cs)

	accounts := []model.Account{
		{
			Name: "Acc1",
			Characters: []model.CharacterIdentity{
				{Character: model.Character{UserInfoResponse: model.UserInfoResponse{CharacterID: 111}}},
				{Character: model.Character{UserInfoResponse: model.UserInfoResponse{CharacterID: 222}}},
			},
		},
	}

	as.On("FetchAccounts").Return(accounts, nil).Once()
	as.On("SaveAccounts", mock.Anything).Return(nil).Once()

	// After removal, we fetch again
	updatedAccounts := []model.Account{
		{
			Name: "Acc1",
			Characters: []model.CharacterIdentity{
				{Character: model.Character{UserInfoResponse: model.UserInfoResponse{CharacterID: 222}}},
			},
		},
	}
	as.On("FetchAccounts").Return(updatedAccounts, nil).Once()

	err := charSvc.RemoveCharacter(111)
	assert.NoError(t, err)

	as.AssertExpectations(t)
}

func TestRemoveCharacter_NotFound(t *testing.T) {
	esi := &testutil.MockESIService{}
	logger := &testutil.MockLogger{}
	sys := &testutil.MockSystemRepository{}
	sk := &testutil.MockSkillService{}
	as := &testutil.MockAccountService{}
	cs := &testutil.MockConfigService{}

	charSvc := eve.NewCharacterService(esi, logger, sys, sk, as, cs)

	as.On("FetchAccounts").Return([]model.Account{}, nil).Once()

	err := charSvc.RemoveCharacter(999)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "character not found in accounts")
}

func TestRemoveCharacter_SaveError(t *testing.T) {
	esi := &testutil.MockESIService{}
	logger := &testutil.MockLogger{}
	sys := &testutil.MockSystemRepository{}
	sk := &testutil.MockSkillService{}
	as := &testutil.MockAccountService{}
	cs := &testutil.MockConfigService{}

	charSvc := eve.NewCharacterService(esi, logger, sys, sk, as, cs)

	accounts := []model.Account{
		{
			Name: "Acc1",
			Characters: []model.CharacterIdentity{
				{Character: model.Character{UserInfoResponse: model.UserInfoResponse{CharacterID: 123}}},
			},
		},
	}

	as.On("FetchAccounts").Return(accounts, nil).Once()
	as.On("SaveAccounts", mock.Anything).Return(errors.New("save accounts error")).Once()

	err := charSvc.RemoveCharacter(123)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "failed to save accounts after character removal")
}

// Helper to return a time pointer
func timePtr(t time.Time) *time.Time {
	return &t
}

================
File: internal/services/eve/character_service.go
================
// services/character/character_service.go
package eve

import (
	"fmt"
	"strconv"
	"time"

	"github.com/guarzo/canifly/internal/model"
	"github.com/guarzo/canifly/internal/services/interfaces"
)

var _ interfaces.CharacterService = (*characterService)(nil)

// CharacterService orchestrates character data updates by using ESIService
type characterService struct {
	esi            interfaces.ESIService
	logger         interfaces.Logger
	sysRepo        interfaces.SystemRepository
	skillService   interfaces.SkillService
	accountService interfaces.AccountService
	configService  interfaces.ConfigService
}

func NewCharacterService(esi interfaces.ESIService,
	logger interfaces.Logger,
	sys interfaces.SystemRepository, sk interfaces.SkillService,
	as interfaces.AccountService, c interfaces.ConfigService) interfaces.CharacterService {
	return &characterService{
		esi:            esi,
		logger:         logger,
		sysRepo:        sys,
		skillService:   sk,
		accountService: as,
		configService:  c,
	}
}

func (c *characterService) ProcessIdentity(charIdentity *model.CharacterIdentity) (*model.CharacterIdentity, error) {
	c.logger.Debugf("Processing identity for character ID: %d", charIdentity.Character.CharacterID)

	user, err := c.esi.GetUserInfo(&charIdentity.Token)
	if err != nil {
		return nil, fmt.Errorf("failed to get user info: %v", err)
	}
	c.logger.Debugf("Fetched user info for character %s (ID: %d)", user.CharacterName, user.CharacterID)

	characterResponse, err := c.esi.GetCharacter(strconv.FormatInt(charIdentity.Character.CharacterID, 10))
	if err != nil {
		c.logger.Warnf("Failed to get character %s: %v", charIdentity.Character.CharacterName, err)
	}

	skills, err := c.esi.GetCharacterSkills(charIdentity.Character.CharacterID, &charIdentity.Token)
	if err != nil {
		c.logger.Warnf("Failed to get skills for character %d: %v", charIdentity.Character.CharacterID, err)
		skills = &model.CharacterSkillsResponse{Skills: []model.SkillResponse{}}
	}
	c.logger.Debugf("Fetched %d skills for character %d", len(skills.Skills), charIdentity.Character.CharacterID)

	skillQueue, err := c.esi.GetCharacterSkillQueue(charIdentity.Character.CharacterID, &charIdentity.Token)
	if err != nil {
		c.logger.Warnf("Failed to get eve queue for character %d: %v", charIdentity.Character.CharacterID, err)
		skillQueue = &[]model.SkillQueue{}
	}
	c.logger.Debugf("Fetched %d eve queue entries for character %d", len(*skillQueue), charIdentity.Character.CharacterID)

	characterLocation, err := c.esi.GetCharacterLocation(charIdentity.Character.CharacterID, &charIdentity.Token)
	if err != nil {
		c.logger.Warnf("Failed to get location for character %d: %v", charIdentity.Character.CharacterID, err)
		characterLocation = 0
	}

	corporationName := ""
	allianceName := ""
	if characterResponse != nil {
		characterCorporation, err := c.esi.GetCorporation(int64(characterResponse.CorporationID), &charIdentity.Token)
		if err != nil {
			c.logger.Warnf("Failed to get corporation for corporation %d: %v", characterResponse.CorporationID, err)
		} else {
			corporationName = characterCorporation.Name
		}
		if characterCorporation != nil && characterCorporation.AllianceID != 0 {
			characterAlliance, err := c.esi.GetAlliance(int64(characterCorporation.AllianceID), &charIdentity.Token)
			if err != nil {
				c.logger.Warnf("Failed to get alliance for character %s: %v", characterCorporation.AllianceID, err)
			} else {
				allianceName = characterAlliance.Name
			}
		}
	}

	c.logger.Debugf("Character %d is located at %d", charIdentity.Character.CharacterID, characterLocation)

	// Update charIdentity with fetched data
	c.logger.Debugf("updating %s", user.CharacterName)
	charIdentity.Character.UserInfoResponse = *user
	charIdentity.Character.CharacterSkillsResponse = *skills
	charIdentity.Character.SkillQueue = *skillQueue
	charIdentity.Character.Location = characterLocation
	charIdentity.Character.LocationName = c.sysRepo.GetSystemName(charIdentity.Character.Location)
	charIdentity.MCT = c.isCharacterTraining(*skillQueue)
	if charIdentity.MCT {
		charIdentity.Training = c.skillService.GetSkillName(charIdentity.Character.SkillQueue[0].SkillID)
	}
	charIdentity.CorporationName = corporationName
	charIdentity.AllianceName = allianceName

	// Initialize maps if nil
	if charIdentity.Character.QualifiedPlans == nil {
		charIdentity.Character.QualifiedPlans = make(map[string]bool)
	}
	if charIdentity.Character.PendingPlans == nil {
		charIdentity.Character.PendingPlans = make(map[string]bool)
	}
	if charIdentity.Character.PendingFinishDates == nil {
		charIdentity.Character.PendingFinishDates = make(map[string]*time.Time)
	}
	if charIdentity.Character.MissingSkills == nil {
		charIdentity.Character.MissingSkills = make(map[string]map[string]int32)
	}

	err = c.esi.SaveEsiCache()
	if err != nil {
		c.logger.WithError(err).Infof("failed to save esi cache after processing identity")
	}

	return charIdentity, nil
}

func (c *characterService) isCharacterTraining(queue []model.SkillQueue) bool {
	for _, q := range queue {
		if q.StartDate != nil && q.FinishDate != nil && q.FinishDate.After(time.Now()) {
			c.logger.Debugf("training - start %s, finish %s, eve %d", q.StartDate, q.FinishDate, q.SkillID)
			return true
		}
	}
	return false
}

func (c *characterService) DoesCharacterExist(characterID int64) (bool, *model.CharacterIdentity, error) {
	accounts, err := c.accountService.FetchAccounts()
	if err != nil {
		return false, nil, fmt.Errorf("failed to fetch accounts: %w", err)
	}
	charIdentity := c.findCharacterInAccounts(accounts, characterID)
	if charIdentity == nil {
		return false, nil, nil
	}
	return true, charIdentity, nil
}

func (c *characterService) UpdateCharacterFields(characterID int64, updates map[string]interface{}) error {
	accounts, err := c.accountService.FetchAccounts()
	if err != nil {
		return fmt.Errorf("failed to fetch accounts: %w", err)
	}

	charIdentity := c.findCharacterInAccounts(accounts, characterID)
	if charIdentity == nil {
		return fmt.Errorf("character not found")
	}

	for key, value := range updates {
		switch key {
		case "Role":
			roleStr, ok := value.(string)
			if !ok {
				return fmt.Errorf("role must be a string")
			}
			// Update roles via configService
			if err := c.configService.UpdateRoles(roleStr); err != nil {
				c.logger.Infof("Failed to update roles: %v", err)
			}
			charIdentity.Role = roleStr

		case "MCT":
			mctBool, ok := value.(bool)
			if !ok {
				return fmt.Errorf("MCT must be boolean")
			}
			charIdentity.MCT = mctBool

		default:
			return fmt.Errorf("unknown update field: %s", key)
		}
	}

	if err := c.accountService.SaveAccounts(accounts); err != nil {
		return fmt.Errorf("failed to save accounts: %w", err)
	}

	return nil
}

func (a *characterService) removeUnusedRoles() error {
	// 1) Get current roles
	roles, err := a.configService.GetRoles()
	if err != nil {
		return fmt.Errorf("failed to fetch roles: %w", err)
	}

	// 2) Get all accounts to see which roles are in use
	accounts, err := a.accountService.FetchAccounts()
	if err != nil {
		return fmt.Errorf("failed to fetch accounts: %w", err)
	}

	usedRoles := make(map[string]struct{})
	for _, account := range accounts {
		for _, character := range account.Characters {
			if character.Role != "" {
				usedRoles[character.Role] = struct{}{}
			}
		}
	}

	// 3) Filter out unused roles
	var filtered []string
	for _, role := range roles {
		if _, ok := usedRoles[role]; ok {
			filtered = append(filtered, role)
		} else {
			a.logger.Infof("Removing unused role: %s", role)
		}
	}

	// 4) Save pruned list
	return a.configService.SaveRoles(filtered)
}

func (c *characterService) RemoveCharacter(characterID int64) error {
	accounts, err := c.accountService.FetchAccounts()
	if err != nil {
		return fmt.Errorf("failed to fetch accounts: %w", err)
	}

	accountIndex, charIndex, found := c.findCharacterIndices(accounts, characterID)
	if !found {
		return fmt.Errorf("character not found in accounts")
	}

	accountName := accounts[accountIndex].Name
	c.logger.Infof("Removing character %d from account %s", characterID, accountName)

	// Remove character
	accounts[accountIndex].Characters = append(
		accounts[accountIndex].Characters[:charIndex],
		accounts[accountIndex].Characters[charIndex+1:]...,
	)

	if err := c.accountService.SaveAccounts(accounts); err != nil {
		return fmt.Errorf("failed to save accounts after character removal: %w", err)
	}

	// Optional verification log if needed
	updatedAccounts, err := c.accountService.FetchAccounts()
	if err == nil {
		idx, found := c.findAccountIndex(updatedAccounts, accountName)
		if found {
			c.logger.Infof("after removal - length of %s characters is %d", accountName, len(updatedAccounts[idx].Characters))
		}
	}

	return nil
}

func (c *characterService) findCharacterInAccounts(accounts []model.Account, characterID int64) *model.CharacterIdentity {
	for i := range accounts {
		for j := range accounts[i].Characters {
			if accounts[i].Characters[j].Character.CharacterID == characterID {
				return &accounts[i].Characters[j]
			}
		}
	}
	return nil
}

func (c *characterService) findCharacterIndices(accounts []model.Account, characterID int64) (int, int, bool) {
	for i := range accounts {
		for j := range accounts[i].Characters {
			if accounts[i].Characters[j].Character.CharacterID == characterID {
				return i, j, true
			}
		}
	}
	return 0, 0, false
}

func (c *characterService) findAccountIndex(accounts []model.Account, accountName string) (int, bool) {
	for i, acc := range accounts {
		if acc.Name == accountName {
			return i, true
		}
	}
	return -1, false
}

================
File: internal/services/eve/esi_service_test.crap
================
package eve_test

import (
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"testing"

	flyErrors "github.com/guarzo/canifly/internal/errors"
	"github.com/guarzo/canifly/internal/model"
	"github.com/guarzo/canifly/internal/services/eve"
	"github.com/guarzo/canifly/internal/testutil"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
	"golang.org/x/oauth2"
)

// TestResolveCharacterNames_Success tests a successful scenario where a character is found.
func TestResolveCharacterNames_Success(t *testing.T) {
	httpClient := &testutil.MockHTTPClient{}
	auth := &testutil.MockAuthClient{}
	logger := &testutil.MockLogger{}
	cache := &testutil.MockCacheService{}
	deleted := &testutil.MockDeletedCharactersRepository{}

	esiSvc := eve.NewESIService(httpClient, auth, logger, cache, deleted)

	deleted.On("FetchDeletedCharacters").Return([]string{}, nil).Once()

	cache.On("Get", "https://esi.evetech.net/latest/characters/1234/?datasource=tranquility").
		Return([]byte(nil), false).Once()

	charBytes := []byte(`{
        "name": "TestChar",
        "gender": "male",
        "birthday": "2000-01-01T00:00:00Z",
        "corporation_id": 1000
    }`)

	httpClient.On("DoRequest", "GET", "https://esi.evetech.net/latest/characters/1234/?datasource=tranquility", nil, mock.Anything).
		Run(func(args mock.Arguments) {
			raw := args.Get(3).(*json.RawMessage)
			*raw = json.RawMessage(charBytes)
		}).
		Return(nil).Once()

	cache.On("Set", "https://esi.evetech.net/latest/characters/1234/?datasource=tranquility", mock.Anything, mock.Anything).
		Return().Once()

	deleted.On("SaveDeletedCharacters", []string{}).Return(nil).Once()
	cache.On("SaveCache").Return(nil).Once()

	names, err := esiSvc.ResolveCharacterNames([]string{"1234"})
	assert.NoError(t, err)
	assert.Equal(t, "TestChar", names["1234"])

	httpClient.AssertExpectations(t)
	deleted.AssertExpectations(t)
	cache.AssertExpectations(t)
}

// TestResolveCharacterNames_404 tests a scenario where GetCharacter returns a 404.
func TestResolveCharacterNames_404(t *testing.T) {
	httpClient := &testutil.MockHTTPClient{}
	auth := &testutil.MockAuthClient{}
	logger := &testutil.MockLogger{}
	cache := &testutil.MockCacheService{}
	deleted := &testutil.MockDeletedCharactersRepository{}

	esiSvc := eve.NewESIService(httpClient, auth, logger, cache, deleted)

	deleted.On("FetchDeletedCharacters").Return([]string{}, nil).Once()

	cache.On("Get", "https://esi.evetech.net/latest/characters/1234/?datasource=tranquility").
		Return([]byte(nil), false).Once()

	notFoundErr := flyErrors.NewCustomError(http.StatusNotFound, "Not found")
	httpClient.On("DoRequest", "GET", "https://esi.evetech.net/latest/characters/1234/?datasource=tranquility", nil, mock.Anything).
		Return(notFoundErr).Once()

	deleted.On("SaveDeletedCharacters", []string{"1234"}).Return(nil).Once()
	cache.On("SaveCache").Return(nil).Once()

	names, err := esiSvc.ResolveCharacterNames([]string{"1234"})
	require.NoError(t, err)
	require.Empty(t, names)

	httpClient.AssertExpectations(t)
	deleted.AssertExpectations(t)
	cache.AssertExpectations(t)
}

// TestResolveCharacterNames_FetchDeletedError tests a scenario where FetchDeletedCharacters returns an error.
func TestResolveCharacterNames_FetchDeletedError(t *testing.T) {
	httpClient := &testutil.MockHTTPClient{}
	auth := &testutil.MockAuthClient{}
	logger := &testutil.MockLogger{}
	cache := &testutil.MockCacheService{}
	deleted := &testutil.MockDeletedCharactersRepository{}

	esiSvc := eve.NewESIService(httpClient, auth, logger, cache, deleted)

	// Return an empty slice and an error, not nil, to avoid panic.
	deleted.On("FetchDeletedCharacters").Return([]string{}, fmt.Errorf("fetch error")).Once()

	// For character "9999"
	cache.On("Get", "https://esi.evetech.net/latest/characters/9999/?datasource=tranquility").
		Return([]byte(nil), false).Once()

	charResp := model.CharacterResponse{Name: "CharX"}
	charBytes, _ := json.Marshal(charResp)

	httpClient.On("DoRequest", "GET", "https://esi.evetech.net/latest/characters/9999/?datasource=tranquility", nil, mock.AnythingOfType("*json.RawMessage")).
		Run(func(args mock.Arguments) {
			target := args.Get(3).(*json.RawMessage)
			*target = json.RawMessage(charBytes)
		}).
		Return(nil).Once()

	deleted.On("SaveDeletedCharacters", []string{}).Return(nil).Once()
	cache.On("SaveCache").Return(nil).Once()

	names, err := esiSvc.ResolveCharacterNames([]string{"9999"})
	assert.NoError(t, err)
	assert.Equal(t, "CharX", names["9999"])

	httpClient.AssertExpectations(t)
	deleted.AssertExpectations(t)
	cache.AssertExpectations(t)
}

// GetUserInfo Tests
func TestGetUserInfo_NoToken(t *testing.T) {
	esiSvc := eve.NewESIService(nil, nil, nil, nil, nil)
	_, err := esiSvc.GetUserInfo(nil)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "no access token")
}

func TestGetUserInfo_HttpError(t *testing.T) {
	httpClient := &testutil.MockHTTPClient{}
	auth := &testutil.MockAuthClient{}
	esiSvc := eve.NewESIService(httpClient, auth, &testutil.MockLogger{}, &testutil.MockCacheService{}, &testutil.MockDeletedCharactersRepository{})

	token := &oauth2.Token{AccessToken: "abc"}

	httpClient.On("DoRequest", "GET", "https://login.eveonline.com/oauth/verify", nil, mock.Anything).
		Return(errors.New("http error")).Once()

	_, err := esiSvc.GetUserInfo(token)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "http error")
}

func TestGetUserInfo_ParseError(t *testing.T) {
	httpClient := &testutil.MockHTTPClient{}
	auth := &testutil.MockAuthClient{}
	esiSvc := eve.NewESIService(httpClient, auth, &testutil.MockLogger{}, &testutil.MockCacheService{}, &testutil.MockDeletedCharactersRepository{})

	token := &oauth2.Token{AccessToken: "abc"}

	httpClient.On("DoRequest", "GET", "https://login.eveonline.com/oauth/verify", nil, mock.Anything).
		Run(func(args mock.Arguments) {
			raw := args.Get(3).(*json.RawMessage)
			*raw = json.RawMessage("invalid json")
		}).
		Return(nil).Once()

	_, err := esiSvc.GetUserInfo(token)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "failed to decode user info")
}

func TestGetUserInfo_Success(t *testing.T) {
	httpClient := &testutil.MockHTTPClient{}
	auth := &testutil.MockAuthClient{}
	esiSvc := eve.NewESIService(httpClient, auth, &testutil.MockLogger{}, &testutil.MockCacheService{}, &testutil.MockDeletedCharactersRepository{})

	token := &oauth2.Token{AccessToken: "abc"}

	user := model.UserInfoResponse{CharacterID: 123, CharacterName: "Pilot"}
	userBytes, _ := json.Marshal(user)

	httpClient.On("DoRequest", "GET", "https://login.eveonline.com/oauth/verify", nil, mock.Anything).
		Run(func(args mock.Arguments) {
			raw := args.Get(3).(*json.RawMessage)
			*raw = json.RawMessage(userBytes)
		}).
		Return(nil).Once()

	u, err := esiSvc.GetUserInfo(token)
	assert.NoError(t, err)
	assert.Equal(t, "Pilot", u.CharacterName)
}

// GetCharacter tests
func TestGetCharacter_HttpError(t *testing.T) {
	httpClient := &testutil.MockHTTPClient{}
	esiSvc := eve.NewESIService(httpClient, nil, &testutil.MockLogger{}, &testutil.MockCacheService{}, &testutil.MockDeletedCharactersRepository{})

	httpClient.On("DoRequest", "GET", mock.Anything, nil, mock.Anything).
		Return(errors.New("char http error")).Once()

	_, err := esiSvc.GetCharacter("999")
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "char http error")
}

func TestGetCharacter_ParseError(t *testing.T) {
	httpClient := &testutil.MockHTTPClient{}
	esiSvc := eve.NewESIService(httpClient, nil, &testutil.MockLogger{}, &testutil.MockCacheService{}, &testutil.MockDeletedCharactersRepository{})

	httpClient.On("DoRequest", "GET", mock.Anything, nil, mock.Anything).
		Run(func(args mock.Arguments) {
			raw := args.Get(3).(*json.RawMessage)
			*raw = json.RawMessage("invalid")
		}).
		Return(nil).Once()

	_, err := esiSvc.GetCharacter("999")
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "failed to decode character response")
}

func TestGetCharacter_Success(t *testing.T) {
	httpClient := &testutil.MockHTTPClient{}
	esiSvc := eve.NewESIService(httpClient, nil, &testutil.MockLogger{}, &testutil.MockCacheService{}, &testutil.MockDeletedCharactersRepository{})

	char := model.CharacterResponse{Name: "CharC"}
	charBytes, _ := json.Marshal(char)

	httpClient.On("DoRequest", "GET", mock.Anything, nil, mock.Anything).
		Run(func(args mock.Arguments) {
			raw := args.Get(3).(*json.RawMessage)
			*raw = json.RawMessage(charBytes)
		}).
		Return(nil).Once()

	cResp, err := esiSvc.GetCharacter("777")
	assert.NoError(t, err)
	assert.Equal(t, "CharC", cResp.Name)
}

================
File: internal/services/eve/esi_service.go
================
// services/esi/esi_service.go
package eve

import (
	"errors"
	"fmt"
	"net/http"
	"slices"

	"golang.org/x/oauth2"

	flyErrors "github.com/guarzo/canifly/internal/errors"
	"github.com/guarzo/canifly/internal/model"
	"github.com/guarzo/canifly/internal/services/interfaces"
)

var _ interfaces.ESIService = (*esiService)(nil)

type esiService struct {
	apiClient    interfaces.EsiHttpClient
	auth         interfaces.AuthClient
	logger       interfaces.Logger
	deleted      interfaces.DeletedCharactersRepository
	cacheService interfaces.CacheService
}

func NewESIService(
	apiClient interfaces.EsiHttpClient,
	auth interfaces.AuthClient,
	logger interfaces.Logger,
	cache interfaces.CacheService,
	deleted interfaces.DeletedCharactersRepository) interfaces.ESIService {

	return &esiService{
		apiClient:    apiClient,
		auth:         auth,
		logger:       logger,
		cacheService: cache,
		deleted:      deleted,
	}
}

func (s *esiService) SaveEsiCache() error {
	return s.cacheService.SaveCache()
}

func (s *esiService) ResolveCharacterNames(charIds []string) (map[string]string, error) {
	charIdToName := make(map[string]string)
	deletedChars, err := s.deleted.FetchDeletedCharacters()
	if err != nil {
		s.logger.WithError(err).Info("resolve character names running without deleted characters info")
		deletedChars = []string{}
	}

	for _, id := range charIds {
		if slices.Contains(deletedChars, id) {
			continue
		}

		character, err := s.GetCharacter(id)
		if err != nil {
			s.logger.Warnf("failed to retrieve name for %s", id)
			var customErr *flyErrors.CustomError
			if errors.As(err, &customErr) && customErr.StatusCode == http.StatusNotFound {
				s.logger.Warnf("adding %s to deleted characters", id)
				deletedChars = append(deletedChars, id)
			}
		} else {
			charIdToName[id] = character.Name
		}
	}

	if saveErr := s.deleted.SaveDeletedCharacters(deletedChars); saveErr != nil {
		s.logger.Warnf("failed to save deleted characters %v", saveErr)
	}
	if err := s.SaveEsiCache(); err != nil {
		s.logger.WithError(err).Infof("failed to save esi cache after processing identity")
	}

	return charIdToName, nil
}

func (s *esiService) GetUserInfo(token *oauth2.Token) (*model.UserInfoResponse, error) {
	if token == nil || token.AccessToken == "" {
		return nil, fmt.Errorf("no access token provided")
	}

	var user model.UserInfoResponse
	if err := s.apiClient.GetJSONFromURL("https://login.eveonline.com/oauth/verify", token, false, &user); err != nil {
		return nil, fmt.Errorf("failed to decode user info: %w", err)
	}

	return &user, nil
}

func (s *esiService) GetCharacter(id string) (*model.CharacterResponse, error) {
	var character model.CharacterResponse
	endpoint := fmt.Sprintf("/latest/characters/%s/?datasource=tranquility", id)
	if err := s.apiClient.GetJSON(endpoint, nil, true, &character); err != nil {
		return nil, fmt.Errorf("failed to decode character response: %w", err)
	}
	return &character, nil
}

func (s *esiService) GetCharacterSkills(characterID int64, token *oauth2.Token) (*model.CharacterSkillsResponse, error) {
	var skills model.CharacterSkillsResponse
	endpoint := fmt.Sprintf("/latest/characters/%d/skills/?datasource=tranquility", characterID)
	if err := s.apiClient.GetJSON(endpoint, token, true, &skills); err != nil {
		return nil, fmt.Errorf("failed to decode character skills: %w", err)
	}
	return &skills, nil
}

func (s *esiService) GetCharacterSkillQueue(characterID int64, token *oauth2.Token) (*[]model.SkillQueue, error) {
	var queue []model.SkillQueue
	endpoint := fmt.Sprintf("/latest/characters/%d/skillqueue/?datasource=tranquility", characterID)
	if err := s.apiClient.GetJSON(endpoint, token, true, &queue); err != nil {
		return nil, fmt.Errorf("failed to decode eve queue: %w", err)
	}
	return &queue, nil
}

func (s *esiService) GetCharacterLocation(characterID int64, token *oauth2.Token) (int64, error) {
	var location model.CharacterLocation
	endpoint := fmt.Sprintf("/latest/characters/%d/location/?datasource=tranquility", characterID)
	s.logger.Debugf("Getting character location for %d", characterID)

	if err := s.apiClient.GetJSON(endpoint, token, true, &location); err != nil {
		return 0, fmt.Errorf("failed to decode character location: %w", err)
	}

	return location.SolarSystemID, nil
}

func (s *esiService) GetCorporation(corporationID int64, token *oauth2.Token) (*model.Corporation, error) {
	var corporation model.Corporation
	endpoint := fmt.Sprintf("/latest/corporations/%d/?datasource=tranquility", corporationID)

	if err := s.apiClient.GetJSON(endpoint, token, true, &corporation); err != nil {
		return nil, fmt.Errorf("failed to decode corporation: %w", err)
	}
	return &corporation, nil
}

func (s *esiService) GetAlliance(allianceID int64, token *oauth2.Token) (*model.Alliance, error) {
	var alliance model.Alliance
	endpoint := fmt.Sprintf("/latest/alliances/%d/?datasource=tranquility", allianceID)

	if err := s.apiClient.GetJSON(endpoint, token, true, &alliance); err != nil {
		return nil, fmt.Errorf("failed to decode alliance: %w", err)
	}
	return &alliance, nil
}

================
File: internal/services/eve/eve_profile_service_test.go
================
package eve_test

import (
	"errors"
	"testing"

	"github.com/guarzo/canifly/internal/model"
	"github.com/guarzo/canifly/internal/services/eve"
	"github.com/guarzo/canifly/internal/testutil"
	"github.com/stretchr/testify/assert"
)

// TestLoadCharacterSettings_ConfigError tests if an error from GetSettingsDir is returned directly.
func TestLoadCharacterSettings_ConfigError(t *testing.T) {
	logger := &testutil.MockLogger{}
	eveRepo := &testutil.MockEveProfilesRepository{}
	configSvc := &testutil.MockConfigService{}
	esiSvc := &testutil.MockESIService{}
	acctSvc := &testutil.MockAccountService{}

	configErr := errors.New("config error")
	configSvc.On("GetSettingsDir").Return("", configErr).Once()

	svc := eve.NewEveProfileservice(logger, eveRepo, acctSvc, esiSvc, configSvc)
	_, err := svc.LoadCharacterSettings()
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "config error")

	configSvc.AssertExpectations(t)
}

// TestLoadCharacterSettings_SubDirError tests if an error from GetSubDirectories is wrapped.
func TestLoadCharacterSettings_SubDirError(t *testing.T) {
	logger := &testutil.MockLogger{}
	eveRepo := &testutil.MockEveProfilesRepository{}
	configSvc := &testutil.MockConfigService{}
	esiSvc := &testutil.MockESIService{}
	acctSvc := &testutil.MockAccountService{}

	configSvc.On("GetSettingsDir").Return("/settingsdir", nil).Once()
	subDirErr := errors.New("subdir error")
	// Return empty slice for directories to avoid panic
	eveRepo.On("GetSubDirectories", "/settingsdir").Return([]string{}, subDirErr).Once()

	svc := eve.NewEveProfileservice(logger, eveRepo, acctSvc, esiSvc, configSvc)
	_, err := svc.LoadCharacterSettings()
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "failed to get subdirectories")

	configSvc.AssertExpectations(t)
	eveRepo.AssertExpectations(t)
}

// TestLoadCharacterSettings_Success tests a successful scenario with character and user files.
func TestLoadCharacterSettings_Success(t *testing.T) {
	logger := &testutil.MockLogger{}
	eveRepo := &testutil.MockEveProfilesRepository{}
	configSvc := &testutil.MockConfigService{}
	esiSvc := &testutil.MockESIService{}
	acctSvc := &testutil.MockAccountService{}

	configSvc.On("GetSettingsDir").Return("/settingsdir", nil).Once()
	eveRepo.On("GetSubDirectories", "/settingsdir").Return([]string{"profile1"}, nil).Once()

	rawFiles := []model.RawFileInfo{
		{FileName: "core_char_123.dat", CharOrUserID: "123", IsChar: true, Mtime: "2024-10-10T10:10:10Z"},
		{FileName: "core_user_456.dat", CharOrUserID: "456", IsChar: false, Mtime: "2024-10-10T10:11:11Z"},
	}
	eveRepo.On("ListSettingsFiles", "profile1", "/settingsdir").Return(rawFiles, nil).Once()

	// Return a map instead of nil
	esiSvc.On("ResolveCharacterNames", []string{"123"}).Return(map[string]string{"123": "Pilot"}, nil).Once()

	acctSvc.On("GetAccountNameByID", "456").Return("MyUser", true).Once()

	svc := eve.NewEveProfileservice(logger, eveRepo, acctSvc, esiSvc, configSvc)
	data, err := svc.LoadCharacterSettings()
	assert.NoError(t, err)
	assert.Len(t, data, 1)
	assert.Equal(t, "profile1", data[0].Profile)
	assert.Len(t, data[0].AvailableCharFiles, 1)
	assert.Equal(t, "Pilot", data[0].AvailableCharFiles[0].Name)
	assert.Len(t, data[0].AvailableUserFiles, 1)
	assert.Equal(t, "MyUser", data[0].AvailableUserFiles[0].Name)

	configSvc.AssertExpectations(t)
	eveRepo.AssertExpectations(t)
	esiSvc.AssertExpectations(t)
	acctSvc.AssertExpectations(t)
}

// TestLoadCharacterSettings_ResolveError tests error from ResolveCharacterNames.
func TestLoadCharacterSettings_ResolveError(t *testing.T) {
	logger := &testutil.MockLogger{}
	eveRepo := &testutil.MockEveProfilesRepository{}
	configSvc := &testutil.MockConfigService{}
	esiSvc := &testutil.MockESIService{}
	acctSvc := &testutil.MockAccountService{}

	configSvc.On("GetSettingsDir").Return("/settingsdir", nil).Once()
	eveRepo.On("GetSubDirectories", "/settingsdir").Return([]string{"profile1"}, nil).Once()

	rawFiles := []model.RawFileInfo{
		{FileName: "core_char_789.dat", CharOrUserID: "789", IsChar: true},
	}
	eveRepo.On("ListSettingsFiles", "profile1", "/settingsdir").Return(rawFiles, nil).Once()

	resolveErr := errors.New("resolve error")
	// Return empty map to avoid panic
	esiSvc.On("ResolveCharacterNames", []string{"789"}).Return(map[string]string{}, resolveErr).Once()

	svc := eve.NewEveProfileservice(logger, eveRepo, acctSvc, esiSvc, configSvc)
	_, err := svc.LoadCharacterSettings()
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "failed to resolve character names")

	configSvc.AssertExpectations(t)
	eveRepo.AssertExpectations(t)
	esiSvc.AssertExpectations(t)
}

// TestSyncDir_ConfigError tests error scenario in SyncDir
func TestSyncDir_ConfigError(t *testing.T) {
	logger := &testutil.MockLogger{}
	eveRepo := &testutil.MockEveProfilesRepository{}
	configSvc := &testutil.MockConfigService{}
	esiSvc := &testutil.MockESIService{}
	acctSvc := &testutil.MockAccountService{}

	configErr := errors.New("config err")
	configSvc.On("GetSettingsDir").Return("", configErr).Once()

	svc := eve.NewEveProfileservice(logger, eveRepo, acctSvc, esiSvc, configSvc)
	_, _, err := svc.SyncDir("subdir", "charId", "userId")
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "config err")

	configSvc.AssertExpectations(t)
}

// TestSyncDir_Success tests a successful scenario for SyncDir
func TestSyncDir_Success(t *testing.T) {
	logger := &testutil.MockLogger{}
	eveRepo := &testutil.MockEveProfilesRepository{}
	configSvc := &testutil.MockConfigService{}
	esiSvc := &testutil.MockESIService{}
	acctSvc := &testutil.MockAccountService{}

	configSvc.On("GetSettingsDir").Return("/settingsdir", nil).Once()
	eveRepo.On("SyncSubdirectory", "subdir", "userId", "charId", "/settingsdir").Return(2, 3, nil).Once()

	svc := eve.NewEveProfileservice(logger, eveRepo, acctSvc, esiSvc, configSvc)
	uCopied, cCopied, err := svc.SyncDir("subdir", "charId", "userId")
	assert.NoError(t, err)
	assert.Equal(t, 2, uCopied)
	assert.Equal(t, 3, cCopied)

	configSvc.AssertExpectations(t)
	eveRepo.AssertExpectations(t)
}

// TestSyncAllDir_ConfigError tests GetSettingsDir error in SyncAllDir
func TestSyncAllDir_ConfigError(t *testing.T) {
	logger := &testutil.MockLogger{}
	eveRepo := &testutil.MockEveProfilesRepository{}
	configSvc := &testutil.MockConfigService{}
	esiSvc := &testutil.MockESIService{}
	acctSvc := &testutil.MockAccountService{}

	configSvc.On("GetSettingsDir").Return("", errors.New("config err")).Once()

	svc := eve.NewEveProfileservice(logger, eveRepo, acctSvc, esiSvc, configSvc)
	_, _, err := svc.SyncAllDir("baseSubDir", "charId", "userId")
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "config err")

	configSvc.AssertExpectations(t)
}

// TestSyncAllDir_EmptySettingsDir tests empty SettingsDir scenario
func TestSyncAllDir_EmptySettingsDir(t *testing.T) {
	logger := &testutil.MockLogger{}
	eveRepo := &testutil.MockEveProfilesRepository{}
	configSvc := &testutil.MockConfigService{}
	esiSvc := &testutil.MockESIService{}
	acctSvc := &testutil.MockAccountService{}

	configSvc.On("GetSettingsDir").Return("", nil).Once()

	svc := eve.NewEveProfileservice(logger, eveRepo, acctSvc, esiSvc, configSvc)
	_, _, err := svc.SyncAllDir("baseSubDir", "charId", "userId")
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "SettingsDir not set")

	configSvc.AssertExpectations(t)
}

// TestSyncAllDir_Success tests a successful scenario
func TestSyncAllDir_Success(t *testing.T) {
	logger := &testutil.MockLogger{}
	eveRepo := &testutil.MockEveProfilesRepository{}
	configSvc := &testutil.MockConfigService{}
	esiSvc := &testutil.MockESIService{}
	acctSvc := &testutil.MockAccountService{}

	configSvc.On("GetSettingsDir").Return("/settingsdir", nil).Once()
	eveRepo.On("SyncAllSubdirectories", "baseSubDir", "userId", "charId", "/settingsdir").Return(10, 20, nil).Once()

	svc := eve.NewEveProfileservice(logger, eveRepo, acctSvc, esiSvc, configSvc)
	uCopied, cCopied, err := svc.SyncAllDir("baseSubDir", "charId", "userId")
	assert.NoError(t, err)
	assert.Equal(t, 10, uCopied)
	assert.Equal(t, 20, cCopied)

	configSvc.AssertExpectations(t)
	eveRepo.AssertExpectations(t)
}

// TestBackupDir_BackupError tests error from BackupDirectory
func TestBackupDir_BackupError(t *testing.T) {
	logger := &testutil.MockLogger{}
	eveRepo := &testutil.MockEveProfilesRepository{}
	configSvc := &testutil.MockConfigService{}
	esiSvc := &testutil.MockESIService{}
	acctSvc := &testutil.MockAccountService{}

	backupErr := errors.New("backup error")
	eveRepo.On("BackupDirectory", "/target", "/backup").Return(backupErr).Once()

	svc := eve.NewEveProfileservice(logger, eveRepo, acctSvc, esiSvc, configSvc)
	err := svc.BackupDir("/target", "/backup")
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "backup error")

	eveRepo.AssertExpectations(t)
}

// TestBackupDir_UpdateBackupErr tests scenario where UpdateBackupDir fails but does not fail the entire operation
func TestBackupDir_UpdateBackupErr(t *testing.T) {
	logger := &testutil.MockLogger{}
	eveRepo := &testutil.MockEveProfilesRepository{}
	configSvc := &testutil.MockConfigService{}
	esiSvc := &testutil.MockESIService{}
	acctSvc := &testutil.MockAccountService{}

	eveRepo.On("BackupDirectory", "/target", "/backup").Return(nil).Once()
	updateErr := errors.New("update error")
	configSvc.On("UpdateBackupDir", "/backup").Return(updateErr).Once()

	svc := eve.NewEveProfileservice(logger, eveRepo, acctSvc, esiSvc, configSvc)
	err := svc.BackupDir("/target", "/backup")
	assert.NoError(t, err) // should not fail despite update error

	eveRepo.AssertExpectations(t)
	configSvc.AssertExpectations(t)
}

================
File: internal/services/eve/eve_profile_service.go
================
package eve

import (
	"fmt"

	"github.com/guarzo/canifly/internal/model"
	"github.com/guarzo/canifly/internal/services/interfaces"
)

var _ interfaces.EveProfilesService = (*eveProfileService)(nil)

type eveProfileService struct {
	logger         interfaces.Logger
	eveRepo        interfaces.EveProfilesRepository
	configService  interfaces.ConfigService
	esiService     interfaces.ESIService
	accountService interfaces.AccountService
}

func NewEveProfileservice(
	logger interfaces.Logger,
	eveRepo interfaces.EveProfilesRepository, ac interfaces.AccountService,
	esi interfaces.ESIService, c interfaces.ConfigService,
) interfaces.EveProfilesService {
	return &eveProfileService{
		logger:         logger,
		eveRepo:        eveRepo,
		esiService:     esi,
		configService:  c,
		accountService: ac,
	}
}

func (e *eveProfileService) LoadCharacterSettings() ([]model.EveProfile, error) {
	settingsDir, err := e.configService.GetSettingsDir()
	if err != nil {
		return nil, err
	}

	subDirs, err := e.eveRepo.GetSubDirectories(settingsDir)
	if err != nil {
		return nil, fmt.Errorf("failed to get subdirectories: %w", err)
	}

	var settingsData []model.EveProfile
	allCharIDs := make(map[string]struct{})

	for _, sd := range subDirs {
		rawFiles, err := e.eveRepo.ListSettingsFiles(sd, settingsDir)
		if err != nil {
			e.logger.Warnf("Error fetching settings files for subDir %s: %v", sd, err)
			continue
		}

		var charFiles []model.CharFile
		var userFiles []model.UserFile

		for _, rf := range rawFiles {
			if rf.IsChar {
				// Just record charId for later ESI resolution
				allCharIDs[rf.CharOrUserID] = struct{}{}
				charFiles = append(charFiles, model.CharFile{
					File:   rf.FileName,
					CharId: rf.CharOrUserID,
					Name:   "CharID:" + rf.CharOrUserID, // Temporary name, will update after ESI lookup
					Mtime:  rf.Mtime,
				})
			} else {
				//
				friendlyName := rf.CharOrUserID
				if savedName, ok := e.accountService.GetAccountNameByID(rf.CharOrUserID); ok {
					friendlyName = savedName
				}
				userFiles = append(userFiles, model.UserFile{
					File:   rf.FileName,
					UserId: rf.CharOrUserID,
					Name:   friendlyName,
					Mtime:  rf.Mtime,
				})
			}
		}

		settingsData = append(settingsData, model.EveProfile{
			Profile:            sd,
			AvailableCharFiles: charFiles,
			AvailableUserFiles: userFiles,
		})
	}

	// Resolve character names via ESI
	var charIdList []string
	for id := range allCharIDs {
		charIdList = append(charIdList, id)
	}
	charIdToName, err := e.esiService.ResolveCharacterNames(charIdList)
	if err != nil {
		return nil, fmt.Errorf("failed to resolve character names: %w", err)
	}

	// Update character files with resolved names
	for si, sd := range settingsData {
		var filteredChars []model.CharFile
		for _, cf := range sd.AvailableCharFiles {
			if name, ok := charIdToName[cf.CharId]; ok && name != "" {
				cf.Name = name
				filteredChars = append(filteredChars, cf)
			}
		}
		settingsData[si].AvailableCharFiles = filteredChars
	}

	return settingsData, nil
}

func (e *eveProfileService) SyncDir(subDir, charId, userId string) (int, int, error) {
	settingsDir, err := e.configService.GetSettingsDir()
	if err != nil {
		return 0, 0, err
	}

	return e.eveRepo.SyncSubdirectory(subDir, userId, charId, settingsDir)
}

func (e *eveProfileService) SyncAllDir(baseSubDir, charId, userId string) (int, int, error) {
	settingsDir, err := e.configService.GetSettingsDir()
	if err != nil {
		return 0, 0, err
	}
	if settingsDir == "" {
		return 0, 0, fmt.Errorf("SettingsDir not set")
	}

	return e.eveRepo.SyncAllSubdirectories(baseSubDir, userId, charId, settingsDir)
}

// BackupDir backs up EVE settings_ directories and then
// also calls configService to zip up any .json files in its basePath.
func (e *eveProfileService) BackupDir(targetDir, backupDir string) error {
	// 1) Backup the EVE settings_ directories as before
	err := e.eveRepo.BackupDirectory(targetDir, backupDir)
	if err != nil {
		return err
	}

	// 2) Update configs backupDir (same as your existing code)
	err = e.configService.UpdateBackupDir(backupDir)
	if err != nil {
		e.logger.Infof("Backup succeeded, but updating config backupDir failed: %v", err)
	}

	// 3) NEW: Also zip up all .json files from configStores basePath
	err = e.configService.BackupJSONFiles(backupDir)
	if err != nil {
		// This error won't abort the entire backup; we just log it
		e.logger.Warnf("Zipping JSON files failed: %v", err)
	} else {
		e.logger.Infof("Successfully zipped all canifly .json files into %s", backupDir)
	}

	return nil
}

================
File: internal/services/eve/skill_service_test.go
================
package eve_test

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/guarzo/canifly/internal/model"
	"github.com/guarzo/canifly/internal/persist"
	"github.com/guarzo/canifly/internal/persist/eve"
	"github.com/guarzo/canifly/internal/testutil"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestSkillStore_SaveAndDeleteSkillPlan(t *testing.T) {
	logger := &testutil.MockLogger{}
	fs := persist.OSFileSystem{}
	basePath := t.TempDir()

	store := eve.NewSkillStore(logger, fs, basePath)

	// Ensure the plans directory exists
	require.NoError(t, store.LoadSkillPlans())

	skills := map[string]model.Skill{
		"Gunnery":  {Name: "Gunnery", Level: 5},
		"Missiles": {Name: "Missiles", Level: 3},
	}

	err := store.SaveSkillPlan("myplan", skills)
	assert.NoError(t, err, "Saving skill plan should succeed")

	planFile := filepath.Join(basePath, "plans", "myplan.txt")
	assert.FileExists(t, planFile, "Plan file should exist")

	// Now delete it
	err = store.DeleteSkillPlan("myplan")
	assert.NoError(t, err, "Deleting skill plan should succeed")
	assert.NoFileExists(t, planFile, "Plan file should be deleted")
}

func TestSkillStore_GetSkillPlanFile(t *testing.T) {
	logger := &testutil.MockLogger{}
	fs := persist.OSFileSystem{}
	basePath := t.TempDir()

	store := eve.NewSkillStore(logger, fs, basePath)

	// Ensure the plans directory is created
	require.NoError(t, store.LoadSkillPlans())

	skills := map[string]model.Skill{
		"Engineering": {Name: "Engineering", Level: 4},
	}
	err := store.SaveSkillPlan("engineering_plan", skills)
	require.NoError(t, err)

	data, err := store.GetSkillPlanFile("engineering_plan")
	assert.NoError(t, err)
	content := string(data)
	assert.Contains(t, content, "Engineering 4")
}

func TestSkillStore_GetSkillPlans(t *testing.T) {
	logger := &testutil.MockLogger{}
	fs := persist.OSFileSystem{}
	basePath := t.TempDir()

	store := eve.NewSkillStore(logger, fs, basePath)

	// Initially empty
	plans := store.GetSkillPlans()
	assert.Empty(t, plans)

	// Manually create the plans directory so we can save a plan
	plansDir := filepath.Join(basePath, "plans")
	require.NoError(t, os.MkdirAll(plansDir, 0755), "Failed to create plans directory")

	// Save a plan
	skills := map[string]model.Skill{"Drones": {Name: "Drones", Level: 2}}
	err := store.SaveSkillPlan("drones_plan", skills)
	require.NoError(t, err)

	// Now GetSkillPlans should return exactly one
	plans = store.GetSkillPlans()
	assert.Len(t, plans, 1, "Expected exactly one plan")
	assert.Equal(t, "drones_plan", plans["drones_plan"].Name)
	assert.Equal(t, 2, plans["drones_plan"].Skills["Drones"].Level)
}

// This test scenario checks that once an embedded plan is deleted, it is not re-copied on subsequent loads.
// It assumes a known embedded plan exists, e.g., "sample_plan.txt".
func TestSkillStore_DeleteEmbeddedPlanAndReload(t *testing.T) {
	// Skip if we don't have embedded data
	if os.Getenv("NO_EMBEDDED_TEST") == "1" {
		t.Skip("Skipping because no embedded files available")
	}

	logger := &testutil.MockLogger{}
	fs := persist.OSFileSystem{}
	basePath := t.TempDir()
	store := eve.NewSkillStore(logger, fs, basePath)

	// Initial load copies embedded plans to writable directory
	require.NoError(t, store.LoadSkillPlans())
	plans := store.GetSkillPlans()

	// Adjust this to match a known embedded plan name you have
	// For example, if you have "sample_plan.txt" in `static/plans`, use "sample_plan".
	embeddedPlanName := "sample_plan"

	// Ensure the embedded plan was loaded initially
	if _, exists := plans[embeddedPlanName]; !exists {
		t.Skipf("No embedded plan named %q found, skipping test", embeddedPlanName)
	}

	// Delete the embedded plan
	require.NoError(t, store.DeleteSkillPlan(embeddedPlanName))

	// Plans should no longer include the deleted embedded plan
	plans = store.GetSkillPlans()
	assert.NotContains(t, plans, embeddedPlanName, "Plan should be deleted")

	// Reload skill plans to simulate application restart
	require.NoError(t, store.LoadSkillPlans())
	plans = store.GetSkillPlans()

	// The deleted embedded plan should NOT reappear after reloading
	assert.NotContains(t, plans, embeddedPlanName, "Deleted embedded plan should not reappear")
}

// The following tests assume that `static/plans` and `static/invTypes.csv`
// contain some test data.

func TestSkillStore_LoadSkillPlans(t *testing.T) {
	if os.Getenv("NO_EMBEDDED_TEST") == "1" {
		t.Skip("Skipping test because no embedded files available")
	}

	logger := &testutil.MockLogger{}
	fs := persist.OSFileSystem{}
	basePath := t.TempDir()

	store := eve.NewSkillStore(logger, fs, basePath)
	err := store.LoadSkillPlans()
	assert.NoError(t, err)

	plans := store.GetSkillPlans()
	assert.NotEmpty(t, plans)
}

func TestSkillStore_LoadSkillTypes(t *testing.T) {
	if os.Getenv("NO_EMBEDDED_TEST") == "1" {
		t.Skip("Skipping test because no embedded files available")
	}

	logger := &testutil.MockLogger{}
	fs := persist.OSFileSystem{}
	basePath := t.TempDir()

	store := eve.NewSkillStore(logger, fs, basePath)
	err := store.LoadSkillTypes()
	assert.NoError(t, err)

	types := store.GetSkillTypes()
	assert.NotEmpty(t, types)
}

func TestSkillStore_GetSkillTypeByID(t *testing.T) {
	if os.Getenv("NO_EMBEDDED_TEST") == "1" {
		t.Skip("Skipping test because no embedded files available")
	}

	logger := &testutil.MockLogger{}
	fs := persist.OSFileSystem{}
	basePath := t.TempDir()

	store := eve.NewSkillStore(logger, fs, basePath)
	err := store.LoadSkillTypes()
	require.NoError(t, err)

	_, found := store.GetSkillTypeByID("999999")
	assert.False(t, found, "ID 999999 should not be found in skill types")
}

================
File: internal/services/eve/skill_service.go
================
package eve

import (
	"bufio"
	"github.com/guarzo/canifly/internal/model"
	"github.com/guarzo/canifly/internal/services/interfaces"
	"strconv"
	"strings"
	"time"
)

var _ interfaces.SkillService = (*skillService)(nil)

type skillService struct {
	logger    interfaces.Logger
	skillRepo interfaces.SkillRepository
}

// NewSkillService  returns a new SettingsService with a config
func NewSkillService(logger interfaces.Logger, skillRepo interfaces.SkillRepository) interfaces.SkillService {
	return &skillService{logger: logger, skillRepo: skillRepo}
}

var romanToInt = map[string]int{
	"I": 1, "II": 2, "III": 3, "IV": 4, "V": 5,
}

func (s *skillService) GetSkillPlanFile(planName string) ([]byte, error) {
	return s.skillRepo.GetSkillPlanFile(planName)
}

func (s *skillService) DeleteSkillPlan(name string) error {
	return s.skillRepo.DeleteSkillPlan(name)
}

func (s *skillService) ParseAndSaveSkillPlan(contents, name string) error {
	skills := s.parseSkillPlanContents(contents)
	return s.skillRepo.SaveSkillPlan(name, skills)
}

func (s *skillService) CheckIfDuplicatePlan(name string) bool {
	plans := s.skillRepo.GetSkillPlans()
	for _, plan := range plans {
		if plan.Name == name {
			return true
		}
	}
	return false
}

// parseSkillPlanContents takes the contents as a string and parses it into a map of skills.
func (s *skillService) parseSkillPlanContents(contents string) map[string]model.Skill {
	skills := make(map[string]model.Skill)
	scanner := bufio.NewScanner(strings.NewReader(contents))

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())

		if line == "" {
			continue // Skip empty lines
		}

		// Find the last whitespace to separate eve name from eve level
		lastSpaceIndex := strings.LastIndex(line, " ")
		if lastSpaceIndex == -1 {
			continue // Skip lines that don't have a space
		}

		// Separate eve name and level
		skillName := line[:lastSpaceIndex]
		skillLevelStr := line[lastSpaceIndex+1:]

		// Parse eve level, handling Roman numerals if necessary
		skillLevel, err := parseSkillLevel(skillLevelStr)
		if err != nil {
			s.logger.Warnf("Invalid eve level '%s'; skipping line.\n", skillLevelStr)
			continue // Skip lines with invalid levels
		}

		// Check if the eve already exists and add/update if necessary
		if currentSkill, exists := skills[skillName]; !exists || skillLevel > currentSkill.Level {
			skills[skillName] = model.Skill{Name: skillName, Level: skillLevel}
		}
	}

	return skills
}

// parseSkillLevel converts either a Roman numeral or integer string to an integer.
func parseSkillLevel(levelStr string) (int, error) {
	if val, ok := romanToInt[levelStr]; ok {
		return val, nil
	}
	return strconv.Atoi(levelStr) // Fall back to numeric conversion
}

func (s *skillService) GetPlanAndConversionData(
	accounts []model.Account,
	skillPlans map[string]model.SkillPlan,
	skillTypes map[string]model.SkillType,
) (map[string]model.SkillPlanWithStatus, map[string]string) {

	// Step 1: Initialize updatedSkillPlans and eveConversions
	updatedSkillPlans := s.initializeUpdatedPlans(skillPlans)
	eveConversions := s.initializeEveConversions(skillPlans, skillTypes)

	// Step 2: Process all accounts and characters
	typeIds := s.processAccountsAndCharacters(accounts, skillPlans, skillTypes, updatedSkillPlans)

	// Step 3: Convert skill IDs into names and update eveConversions
	s.updateEveConversionsWithSkillNames(typeIds, eveConversions)

	return updatedSkillPlans, eveConversions
}

func (s *skillService) initializeUpdatedPlans(skillPlans map[string]model.SkillPlan) map[string]model.SkillPlanWithStatus {
	updated := make(map[string]model.SkillPlanWithStatus)
	for planName, plan := range skillPlans {
		updated[planName] = model.SkillPlanWithStatus{
			Name:                plan.Name,
			Skills:              plan.Skills,
			QualifiedCharacters: []string{},
			PendingCharacters:   []string{},
			MissingSkills:       make(map[string]map[string]int32),
			Characters:          []model.CharacterSkillPlanStatus{},
		}
	}
	return updated
}

func (s *skillService) initializeEveConversions(
	skillPlans map[string]model.SkillPlan,
	skillTypes map[string]model.SkillType,
) map[string]string {
	conversions := make(map[string]string)
	for planName := range skillPlans {
		if planType, exists := skillTypes[planName]; exists {
			conversions[planName] = planType.TypeID
		}
	}
	return conversions
}

func (s *skillService) processAccountsAndCharacters(
	accounts []model.Account,
	skillPlans map[string]model.SkillPlan,
	skillTypes map[string]model.SkillType,
	updatedSkillPlans map[string]model.SkillPlanWithStatus,
) []int32 {

	var typeIds []int32
	for _, account := range accounts {
		for _, chData := range account.Characters {
			character := chData.Character

			// Extract character skill and queue info
			characterSkills := s.mapCharacterSkills(character, &typeIds)
			skillQueueLevels := s.mapSkillQueueLevels(character)

			s.ensureCharacterMaps(character)

			// Evaluate each plan for this character
			for planName, plan := range skillPlans {
				planResult := s.evaluatePlanForCharacter(plan, skillTypes, characterSkills, skillQueueLevels)

				planStatus := updatedSkillPlans[planName]
				s.updatePlanAndCharacterStatus(
					&planStatus,
					&character,
					planName,
					planResult,
				)
				updatedSkillPlans[planName] = planStatus
			}
		}
	}
	return typeIds
}

func (s *skillService) mapCharacterSkills(character model.Character, typeIds *[]int32) map[int32]int32 {
	skillsMap := make(map[int32]int32)
	for _, skill := range character.Skills {
		skillsMap[skill.SkillID] = skill.TrainedSkillLevel
		*typeIds = append(*typeIds, skill.SkillID)
	}
	return skillsMap
}

func (s *skillService) mapSkillQueueLevels(character model.Character) map[int32]struct {
	level      int32
	finishDate *time.Time
} {
	queueMap := make(map[int32]struct {
		level      int32
		finishDate *time.Time
	})
	for _, queuedSkill := range character.SkillQueue {
		current, exists := queueMap[queuedSkill.SkillID]
		if !exists || queuedSkill.FinishedLevel > current.level {
			queueMap[queuedSkill.SkillID] = struct {
				level      int32
				finishDate *time.Time
			}{level: queuedSkill.FinishedLevel, finishDate: queuedSkill.FinishDate}
		}
	}
	return queueMap
}

func (s *skillService) ensureCharacterMaps(character model.Character) {
	if character.QualifiedPlans == nil {
		character.QualifiedPlans = make(map[string]bool)
	}
	if character.PendingPlans == nil {
		character.PendingPlans = make(map[string]bool)
	}
	if character.MissingSkills == nil {
		character.MissingSkills = make(map[string]map[string]int32)
	}
	if character.PendingFinishDates == nil {
		character.PendingFinishDates = make(map[string]*time.Time)
	}
}

type planEvaluationResult struct {
	Qualifies        bool
	Pending          bool
	MissingSkills    map[string]int32
	LatestFinishDate *time.Time
}

func (s *skillService) evaluatePlanForCharacter(
	plan model.SkillPlan,
	skillTypes map[string]model.SkillType,
	characterSkills map[int32]int32,
	skillQueueLevels map[int32]struct {
		level      int32
		finishDate *time.Time
	},
) planEvaluationResult {

	result := planEvaluationResult{
		Qualifies:     true,
		MissingSkills: make(map[string]int32),
	}

	for skillName, requiredSkill := range plan.Skills {
		skillType, exists := skillTypes[skillName]
		if !exists {
			s.logger.Errorf("Error: Skill '%s' does not exist in eve types", skillName)
			result.Qualifies = false
			continue
		}

		skillID, err := strconv.Atoi(skillType.TypeID)
		if err != nil {
			s.logger.Errorf("Error: Converting eve type ID '%s' for eve '%s': %v", skillType.TypeID, skillName, err)
			result.Qualifies = false
			continue
		}

		requiredLevel := int32(requiredSkill.Level)
		characterLevel, hasSkill := characterSkills[int32(skillID)]
		queued, inQueue := skillQueueLevels[int32(skillID)]

		switch {
		case hasSkill && characterLevel >= requiredLevel:
			// Already qualified for this skill
		case inQueue && queued.level >= requiredLevel:
			// Pending this skill
			result.Pending = true
			if result.LatestFinishDate == nil || (queued.finishDate != nil && queued.finishDate.After(*result.LatestFinishDate)) {
				result.LatestFinishDate = queued.finishDate
			}
		default:
			// Missing this skill
			result.Qualifies = false
			result.MissingSkills[skillName] = requiredLevel
		}
	}

	return result
}
func (s *skillService) updatePlanAndCharacterStatus(
	plan *model.SkillPlanWithStatus,
	character *model.Character,
	planName string,
	res planEvaluationResult,
) {
	if character.QualifiedPlans == nil {
		character.QualifiedPlans = make(map[string]bool)
	}
	if character.PendingPlans == nil {
		character.PendingPlans = make(map[string]bool)
	}
	if character.MissingSkills == nil {
		character.MissingSkills = make(map[string]map[string]int32)
	}
	if character.PendingFinishDates == nil {
		character.PendingFinishDates = make(map[string]*time.Time)
	}

	characterSkillStatus := model.CharacterSkillPlanStatus{
		CharacterName:     character.CharacterName,
		Status:            getStatus(res.Qualifies, res.Pending),
		MissingSkills:     res.MissingSkills,
		PendingFinishDate: res.LatestFinishDate,
	}

	if res.Qualifies && !res.Pending {
		plan.QualifiedCharacters = append(plan.QualifiedCharacters, character.CharacterName)
		character.QualifiedPlans[planName] = true
	}

	if res.Pending {
		plan.PendingCharacters = append(plan.PendingCharacters, character.CharacterName)
		character.PendingPlans[planName] = true
		character.PendingFinishDates[planName] = res.LatestFinishDate
	}

	if len(res.MissingSkills) > 0 {
		plan.MissingSkills[character.CharacterName] = res.MissingSkills
		character.MissingSkills[planName] = res.MissingSkills
	}

	plan.Characters = append(plan.Characters, characterSkillStatus)
}

func (s *skillService) updateEveConversionsWithSkillNames(typeIds []int32, eveConversions map[string]string) {
	for _, skillId := range typeIds {
		name := s.GetSkillName(skillId)
		if name != "" {
			eveConversions[strconv.FormatInt(int64(skillId), 10)] = name
		}
	}
}

func getStatus(qualifies bool, pending bool) string {
	if qualifies && !pending {
		return "Qualified"
	} else if pending {
		return "Pending"
	}
	return "Not Qualified"
}

func (s *skillService) GetSkillPlans() map[string]model.SkillPlan {
	return s.skillRepo.GetSkillPlans()
}

func (s *skillService) GetSkillTypes() map[string]model.SkillType {
	return s.skillRepo.GetSkillTypes()
}

func (s *skillService) GetSkillTypeByID(id string) (model.SkillType, bool) {
	return s.skillRepo.GetSkillTypeByID(id)
}

func (s *skillService) GetSkillName(skillID int32) string {
	skill, ok := s.skillRepo.GetSkillTypeByID(strconv.FormatInt(int64(skillID), 10))
	if !ok {
		s.logger.Warnf("Skill ID %d not found", skillID)
		return ""
	}
	return skill.TypeName
}

================
File: internal/services/interfaces/account.go
================
// services/interfaces/account.go
package interfaces

import (
	"net/http"
	"time"

	"github.com/gorilla/sessions"

	"golang.org/x/oauth2"

	"github.com/guarzo/canifly/internal/model"
)

type AccountService interface {
	FindOrCreateAccount(state string, char *model.UserInfoResponse, token *oauth2.Token) error
	UpdateAccountName(accountID int64, accountName string) error
	ToggleAccountStatus(accountID int64) error
	ToggleAccountVisibility(accountID int64) error
	RemoveAccountByName(accountName string) error
	RefreshAccountData(characterService CharacterService) (*model.AccountData, error)
	DeleteAllAccounts() error
	FetchAccounts() ([]model.Account, error)
	SaveAccounts(accounts []model.Account) error
	GetAccountNameByID(id string) (string, bool)
}
type AccountDataRepository interface {
	// FetchAccountData retrieves the entire account domain data (Accounts, UserAccount map, and Associations).
	FetchAccountData() (model.AccountData, error)

	// SaveAccountData saves the entire account domain data structure.
	SaveAccountData(data model.AccountData) error

	// DeleteAccountData removes the persisted account data file, if any.
	DeleteAccountData() error

	// FetchAccounts returns only the Accounts slice from the account data.
	// This is a convenience method that internally fetches AccountData and returns AccountData.Accounts.
	FetchAccounts() ([]model.Account, error)

	// SaveAccounts updates the Accounts slice in the account data, leaving UserAccount and Associations unchanged.
	SaveAccounts(accounts []model.Account) error

	// DeleteAccounts clears out the Accounts slice (but not necessarily UserAccount or Associations).
	DeleteAccounts() error
}

type AssociationService interface {
	UpdateAssociationsAfterNewCharacter(account *model.Account, charID int64) error
	AssociateCharacter(userId, charId string) error
	UnassociateCharacter(userId, charId string) error
}

type CacheService interface {
	Get(key string) ([]byte, bool)
	Set(key string, value []byte, expiration time.Duration)
	LoadCache() error
	SaveCache() error
}

type CacheRepository interface {
	Get(key string) ([]byte, bool)
	Set(key string, value []byte, expiration time.Duration)
	LoadApiCache() error
	SaveApiCache() error
}

type CharacterService interface {
	ProcessIdentity(charIdentity *model.CharacterIdentity) (*model.CharacterIdentity, error)
	DoesCharacterExist(characterID int64) (bool, *model.CharacterIdentity, error)
	UpdateCharacterFields(characterID int64, updates map[string]interface{}) error
	RemoveCharacter(characterID int64) error
}

// AuthClient defines methods related to authentication and token management.
type AuthClient interface {
	RefreshToken(refreshToken string) (*oauth2.Token, error)
	GetAuthURL(state string) string
	ExchangeCode(code string) (*oauth2.Token, error)
}

type EsiHttpClient interface {
	GetJSON(endpoint string, token *oauth2.Token, useCache bool, target interface{}) error
	GetJSONFromURL(url string, token *oauth2.Token, useCache bool, target interface{}) error
}

type DeletedCharactersRepository interface {
	FetchDeletedCharacters() ([]string, error)
	SaveDeletedCharacters([]string) error
}

type LoginService interface {
	ResolveAccountAndStatusByState(state string) (string, bool, bool)
	GenerateAndStoreInitialState(value string) (string, error)
	UpdateStateStatusAfterCallBack(state string) error
	ClearState(state string)
}

type LoginRepository interface {
	Set(state string, authStatus *model.AuthStatus)
	Get(state string) (*model.AuthStatus, bool)
	Delete(state string)
}

type SessionService interface {
	Get(r *http.Request, name string) (*sessions.Session, error)
}

type SessionRepo interface {
	Get()
}

================
File: internal/services/interfaces/config.go
================
// services/interfaces/config.go
package interfaces

import (
	"github.com/guarzo/canifly/internal/model"
)

type DashboardService interface {
	RefreshAccountsAndState() (model.AppState, error)
	RefreshDataInBackground() error
	GetCurrentAppState() model.AppState
}

type Logger interface {
	Debug(args ...interface{})
	Debugf(format string, args ...interface{})
	Info(args ...interface{})
	Infof(format string, args ...interface{})
	Warn(args ...interface{})
	Warnf(format string, args ...interface{})
	Error(args ...interface{})
	Errorf(format string, args ...interface{})
	Fatal(args ...interface{})
	Fatalf(format string, args ...interface{})
	WithError(err error) Logger
	WithFields(fields map[string]interface{}) Logger
	WithField(key string, value interface{}) Logger
}
type AppStateRepository interface {
	// GetAppState returns the current in-memory AppState.
	GetAppState() model.AppState

	// SetAppState replaces the current AppState in memory.
	SetAppState(appState model.AppState)

	// SetAppStateLogin updates the LoggedIn field in AppState and persists the change.
	SetAppStateLogin(isLoggedIn bool) error

	// ClearAppState resets the AppState to an empty struct.
	ClearAppState()

	// SaveAppStateSnapshot writes the current AppState to disk.
	SaveAppStateSnapshot(appState model.AppState) error
}

type AppStateService interface {
	GetAppState() model.AppState
	SetAppStateLogin(isLoggedIn bool) error
	UpdateAndSaveAppState(data model.AppState) error
	ClearAppState()
}

type ConfigRepository interface {
	// FetchConfigData loads the entire ConfigData structure.
	FetchConfigData() (*model.ConfigData, error)

	// SaveConfigData persists the entire ConfigData structure.
	SaveConfigData(*model.ConfigData) error

	// FetchUserSelections retrieves the UserSelections from the config data.
	FetchUserSelections() (model.DropDownSelections, error)

	// SaveUserSelections updates UserSelections in the config data.
	SaveUserSelections(selections model.DropDownSelections) error

	// FetchRoles retrieves the Roles slice from the config data.
	FetchRoles() ([]string, error)

	// SaveRoles updates the Roles slice in the config data.
	SaveRoles(roles []string) error

	GetDefaultSettingsDir() (string, error)
	BackupJSONFiles(backupDir string) error
}

type ConfigService interface {
	UpdateSettingsDir(dir string) error
	GetSettingsDir() (string, error)
	EnsureSettingsDir() error
	SaveUserSelections(model.DropDownSelections) error
	FetchUserSelections() (model.DropDownSelections, error)
	UpdateRoles(newRole string) error
	GetRoles() ([]string, error)
	UpdateBackupDir(dir string) error
	BackupJSONFiles(backupDir string) error
	FetchConfigData() (*model.ConfigData, error)
	SaveRoles(roles []string) error
}

================
File: internal/services/interfaces/eve.go
================
// services/interfaces/eve.go
package interfaces

import (
	"github.com/guarzo/canifly/internal/model"
	"golang.org/x/oauth2"
)

type SkillService interface {
	GetSkillPlans() map[string]model.SkillPlan
	GetSkillName(id int32) string
	GetSkillTypes() map[string]model.SkillType
	CheckIfDuplicatePlan(name string) bool
	ParseAndSaveSkillPlan(contents, name string) error
	GetSkillPlanFile(name string) ([]byte, error)
	DeleteSkillPlan(name string) error
	GetSkillTypeByID(id string) (model.SkillType, bool)
	GetPlanAndConversionData(accounts []model.Account, skillPlans map[string]model.SkillPlan, skillTypes map[string]model.SkillType) (map[string]model.SkillPlanWithStatus, map[string]string)
}

type SkillRepository interface {
	GetSkillPlans() map[string]model.SkillPlan
	GetSkillPlanFile(name string) ([]byte, error)
	GetSkillTypes() map[string]model.SkillType
	SaveSkillPlan(planName string, skills map[string]model.Skill) error
	DeleteSkillPlan(planName string) error
	GetSkillTypeByID(id string) (model.SkillType, bool)
}

type EveProfilesService interface {
	LoadCharacterSettings() ([]model.EveProfile, error)
	BackupDir(targetDir, backupDir string) error

	SyncDir(subDir, charId, userId string) (int, int, error)
	SyncAllDir(baseSubDir, charId, userId string) (int, int, error)
}

type EveProfilesRepository interface {
	// ListSettingsFiles returns raw file info for character and user files in a given subdirectory of the settings directory.
	ListSettingsFiles(subDir, settingsDir string) ([]model.RawFileInfo, error)

	// BackupDirectory creates a tar.gz backup of all directories under targetDir that start with "settings_".
	BackupDirectory(targetDir, backupDir string) error

	// GetSubDirectories returns subdirectories in settingsDir that start with "settings_".
	GetSubDirectories(settingsDir string) ([]string, error)

	// SyncSubdirectory copies user and char file contents from one subdirectory to another to ensure all have consistent files.
	SyncSubdirectory(subDir, userId, charId, settingsDir string) (int, int, error)

	// SyncAllSubdirectories applies SyncSubdirectory logic to all subdirectories of settingsDir, using baseSubDir as the source.
	SyncAllSubdirectories(baseSubDir, userId, charId, settingsDir string) (int, int, error)
}

type SystemRepository interface {
	GetSystemName(systemID int64) string
	LoadSystems() error
}

type ESIService interface {
	GetUserInfo(token *oauth2.Token) (*model.UserInfoResponse, error)
	GetCharacter(id string) (*model.CharacterResponse, error)
	GetCharacterSkills(characterID int64, token *oauth2.Token) (*model.CharacterSkillsResponse, error)
	GetCharacterSkillQueue(characterID int64, token *oauth2.Token) (*[]model.SkillQueue, error)
	GetCharacterLocation(characterID int64, token *oauth2.Token) (int64, error)
	ResolveCharacterNames(charIds []string) (map[string]string, error)
	SaveEsiCache() error
	GetCorporation(id int64, token *oauth2.Token) (*model.Corporation, error)
	GetAlliance(id int64, token *oauth2.Token) (*model.Alliance, error)
}

================
File: internal/testutil/mock_interfaces.go
================
package testutil

import (
	"net/http"
	"time"

	"github.com/gorilla/sessions"
	"golang.org/x/oauth2"

	"github.com/stretchr/testify/mock"

	flyHttp "github.com/guarzo/canifly/internal/http"
	"github.com/guarzo/canifly/internal/model"
	"github.com/guarzo/canifly/internal/services/interfaces"
)

// MockAccountDataRepository mocks interfaces.AccountDataRepository
type MockAccountDataRepository struct {
	mock.Mock
}

func (m *MockAccountDataRepository) FetchAccountData() (model.AccountData, error) {
	args := m.Called()
	return args.Get(0).(model.AccountData), args.Error(1)
}

func (m *MockAccountDataRepository) SaveAccountData(data model.AccountData) error {
	args := m.Called(data)
	return args.Error(0)
}

func (m *MockAccountDataRepository) DeleteAccountData() error {
	args := m.Called()
	return args.Error(0)
}

func (m *MockAccountDataRepository) FetchAccounts() ([]model.Account, error) {
	args := m.Called()
	return args.Get(0).([]model.Account), args.Error(1)
}

func (m *MockAccountDataRepository) SaveAccounts(accounts []model.Account) error {
	args := m.Called(accounts)
	return args.Error(0)
}

func (m *MockAccountDataRepository) DeleteAccounts() error {
	args := m.Called()
	return args.Error(0)
}

// MockAssociationService mocks interfaces.AssociationService
type MockAssociationService struct {
	mock.Mock
}

func (m *MockAssociationService) UpdateAssociationsAfterNewCharacter(account *model.Account, charID int64) error {
	args := m.Called(account, charID)
	return args.Error(0)
}

func (m *MockAssociationService) AssociateCharacter(userId, charId string) error {
	args := m.Called(userId, charId)
	return args.Error(0)
}

func (m *MockAssociationService) UnassociateCharacter(userId, charId string) error {
	args := m.Called(userId, charId)
	return args.Error(0)
}

// MockESIService mocks interfaces.ESIService
type MockESIService struct {
	mock.Mock
}

func (m *MockESIService) GetUserInfo(token *oauth2.Token) (*model.UserInfoResponse, error) {
	args := m.Called(token)
	return args.Get(0).(*model.UserInfoResponse), args.Error(1)
}

func (m *MockESIService) GetCharacter(id string) (*model.CharacterResponse, error) {
	args := m.Called(id)
	return args.Get(0).(*model.CharacterResponse), args.Error(1)
}

func (m *MockESIService) GetCharacterSkills(characterID int64, token *oauth2.Token) (*model.CharacterSkillsResponse, error) {
	args := m.Called(characterID, token)
	return args.Get(0).(*model.CharacterSkillsResponse), args.Error(1)
}

func (m *MockESIService) GetCharacterSkillQueue(characterID int64, token *oauth2.Token) (*[]model.SkillQueue, error) {
	args := m.Called(characterID, token)
	return args.Get(0).(*[]model.SkillQueue), args.Error(1)
}

func (m *MockESIService) GetCharacterLocation(characterID int64, token *oauth2.Token) (int64, error) {
	args := m.Called(characterID, token)
	return args.Get(0).(int64), args.Error(1)
}

func (m *MockESIService) ResolveCharacterNames(charIds []string) (map[string]string, error) {
	args := m.Called(charIds)
	return args.Get(0).(map[string]string), args.Error(1)
}

func (m *MockESIService) SaveEsiCache() error {
	args := m.Called()
	return args.Error(0)
}

func (m *MockESIService) GetCorporation(id int64, token *oauth2.Token) (*model.Corporation, error) {
	args := m.Called(id, token)
	return args.Get(0).(*model.Corporation), args.Error(1)
}

func (m *MockESIService) GetAlliance(id int64, token *oauth2.Token) (*model.Alliance, error) {
	args := m.Called(id, token)
	return args.Get(0).(*model.Alliance), args.Error(1)
}

// MockCharacterService mocks interfaces.CharacterService
type MockCharacterService struct {
	mock.Mock
}

func (m *MockCharacterService) ProcessIdentity(charIdentity *model.CharacterIdentity) (*model.CharacterIdentity, error) {
	args := m.Called(charIdentity)
	return args.Get(0).(*model.CharacterIdentity), args.Error(1)
}

func (m *MockCharacterService) DoesCharacterExist(characterID int64) (bool, *model.CharacterIdentity, error) {
	args := m.Called(characterID)
	return args.Bool(0), args.Get(1).(*model.CharacterIdentity), args.Error(2)
}

func (m *MockCharacterService) UpdateCharacterFields(characterID int64, updates map[string]interface{}) error {
	args := m.Called(characterID, updates)
	return args.Error(0)
}

func (m *MockCharacterService) RemoveCharacter(characterID int64) error {
	args := m.Called(characterID)
	return args.Error(0)
}

// MockSkillService mocks interfaces.SkillService
type MockSkillService struct {
	mock.Mock
}

func (m *MockSkillService) CheckIfDuplicatePlan(name string) bool {
	args := m.Called(name)
	return args.Bool(1)
}

func (m *MockSkillService) GetSkillPlans() map[string]model.SkillPlan {
	args := m.Called()
	return args.Get(0).(map[string]model.SkillPlan)
}

func (m *MockSkillService) GetSkillName(id int32) string {
	args := m.Called(id)
	return args.String(0)
}

func (m *MockSkillService) GetSkillTypes() map[string]model.SkillType {
	args := m.Called()
	return args.Get(0).(map[string]model.SkillType)
}

func (m *MockSkillService) ParseAndSaveSkillPlan(contents, name string) error {
	args := m.Called(contents, name)
	return args.Error(0)
}

func (m *MockSkillService) GetSkillPlanFile(name string) ([]byte, error) {
	args := m.Called(name)
	return args.Get(0).([]byte), args.Error(1)
}

func (m *MockSkillService) DeleteSkillPlan(name string) error {
	args := m.Called(name)
	return args.Error(0)
}

func (m *MockSkillService) GetSkillTypeByID(id string) (model.SkillType, bool) {
	args := m.Called(id)
	return args.Get(0).(model.SkillType), args.Bool(1)
}

func (m *MockSkillService) GetPlanAndConversionData(
	accounts []model.Account,
	skillPlans map[string]model.SkillPlan,
	skillTypes map[string]model.SkillType,
) (map[string]model.SkillPlanWithStatus, map[string]string) {
	args := m.Called(accounts, skillPlans, skillTypes)
	// args.Get(0) should be a map[string]model.SkillPlanWithStatus
	// args.Get(1) should be a map[string]string
	return args.Get(0).(map[string]model.SkillPlanWithStatus), args.Get(1).(map[string]string)
}

// MockAccountService mocks interfaces.AccountService
type MockAccountService struct {
	mock.Mock
}

func (m *MockAccountService) ToggleAccountVisibility(accountID int64) error {
	return nil
}

func (m *MockAccountService) FindOrCreateAccount(state string, char *model.UserInfoResponse, token *oauth2.Token) error {
	args := m.Called(state, char, token)
	return args.Error(0)
}

func (m *MockAccountService) UpdateAccountName(accountID int64, accountName string) error {
	args := m.Called(accountID, accountName)
	return args.Error(0)
}

func (m *MockAccountService) ToggleAccountStatus(accountID int64) error {
	args := m.Called(accountID)
	return args.Error(0)
}

func (m *MockAccountService) RemoveAccountByName(accountName string) error {
	args := m.Called(accountName)
	return args.Error(0)
}

func (m *MockAccountService) RefreshAccountData(characterService interfaces.CharacterService) (*model.AccountData, error) {
	args := m.Called(characterService)
	return args.Get(0).(*model.AccountData), args.Error(1)
}

func (m *MockAccountService) DeleteAllAccounts() error {
	args := m.Called()
	return args.Error(0)
}

func (m *MockAccountService) FetchAccounts() ([]model.Account, error) {
	args := m.Called()
	return args.Get(0).([]model.Account), args.Error(1)
}

func (m *MockAccountService) SaveAccounts(accounts []model.Account) error {
	args := m.Called(accounts)
	return args.Error(0)
}

func (m *MockAccountService) GetAccountNameByID(id string) (string, bool) {
	args := m.Called(id)
	return args.String(0), args.Bool(1)
}

// MockConfigService mocks interfaces.ConfigService
type MockConfigService struct {
	mock.Mock
}

func (m *MockConfigService) SaveRoles(roles []string) error {
	return nil
}

func (m *MockConfigService) BackupJSONFiles(backupDir string) error {
	return nil
}

func (m *MockConfigService) UpdateSettingsDir(dir string) error {
	args := m.Called(dir)
	return args.Error(0)
}

func (m *MockConfigService) UpdateBackupDir(dir string) error {
	args := m.Called(dir)
	return args.Error(0)
}

func (m *MockConfigService) GetSettingsDir() (string, error) {
	args := m.Called()
	return args.String(0), args.Error(1)
}

func (m *MockConfigService) FetchUserSelections() (model.DropDownSelections, error) {
	args := m.Called()
	return args.Get(0).(model.DropDownSelections), args.Error(1)
}

func (m *MockConfigService) SaveUserSelections(selections model.DropDownSelections) error {
	args := m.Called(selections)
	return args.Error(0)
}

func (m *MockConfigService) EnsureSettingsDir() error {
	args := m.Called()
	return args.Error(0)
}

func (m *MockConfigService) UpdateRoles(newRole string) error {
	args := m.Called(newRole)
	return args.Error(0)
}

func (m *MockConfigService) GetRoles() ([]string, error) {
	args := m.Called()
	return args.Get(0).([]string), args.Error(1)
}

func (m *MockConfigService) FetchConfigData() (*model.ConfigData, error) {
	args := m.Called()
	return args.Get(0).(*model.ConfigData), args.Error(1)
}

// MockEveProfilesService mocks interfaces.EveProfilesService
type MockEveProfilesService struct {
	mock.Mock
}

func (m *MockEveProfilesService) LoadCharacterSettings() ([]model.EveProfile, error) {
	args := m.Called()
	return args.Get(0).([]model.EveProfile), args.Error(1)
}

func (m *MockEveProfilesService) BackupDir(targetDir, backupDir string) error {
	args := m.Called(targetDir, backupDir)
	return args.Error(0)
}

func (m *MockEveProfilesService) SyncDir(subDir, charId, userId string) (int, int, error) {
	args := m.Called(subDir, charId, userId)
	return args.Int(0), args.Int(1), args.Error(2)
}

func (m *MockEveProfilesService) SyncAllDir(baseSubDir, charId, userId string) (int, int, error) {
	args := m.Called(baseSubDir, charId, userId)
	return args.Int(0), args.Int(1), args.Error(2)
}

// MockAppStateService mocks interfaces.AppStateService
type MockAppStateService struct {
	mock.Mock
}

func (m *MockAppStateService) UpdateAndSaveAppState(state model.AppState) error {
	args := m.Called(state)
	return args.Error(0)
}

func (m *MockAppStateService) GetAppState() model.AppState {
	args := m.Called()
	return args.Get(0).(model.AppState)
}

func (m *MockAppStateService) SetAppStateLogin(isLoggedIn bool) error {
	args := m.Called(isLoggedIn)
	return args.Error(0)
}

func (m *MockAppStateService) ClearAppState() {
	m.Called()
}

// MockLogger mocks interfaces.Logger
type MockLogger struct{}

func (m *MockLogger) Debug(args ...interface{})                                  {}
func (m *MockLogger) Debugf(format string, args ...interface{})                  {}
func (m *MockLogger) Info(args ...interface{})                                   {}
func (m *MockLogger) Infof(format string, args ...interface{})                   {}
func (m *MockLogger) Warn(args ...interface{})                                   {}
func (m *MockLogger) Warnf(format string, args ...interface{})                   {}
func (m *MockLogger) Error(args ...interface{})                                  {}
func (m *MockLogger) Errorf(format string, args ...interface{})                  {}
func (m *MockLogger) Fatal(args ...interface{})                                  {}
func (m *MockLogger) Fatalf(format string, args ...interface{})                  {}
func (m *MockLogger) WithError(err error) interfaces.Logger                      { return m }
func (m *MockLogger) WithField(key string, value interface{}) interfaces.Logger  { return m }
func (m *MockLogger) WithFields(fields map[string]interface{}) interfaces.Logger { return m }

// MockConfigRepository mocks interfaces.ConfigRepository
type MockConfigRepository struct {
	mock.Mock
}

func (m *MockConfigRepository) BackupJSONFiles(backupDir string) error {
	return nil
}

func (m *MockConfigRepository) FetchConfigData() (*model.ConfigData, error) {
	args := m.Called()
	return args.Get(0).(*model.ConfigData), args.Error(1)
}

func (m *MockConfigRepository) SaveConfigData(configData *model.ConfigData) error {
	args := m.Called(configData)
	return args.Error(0)
}

func (m *MockConfigRepository) FetchUserSelections() (model.DropDownSelections, error) {
	args := m.Called()
	return args.Get(0).(model.DropDownSelections), args.Error(1)
}

func (m *MockConfigRepository) SaveUserSelections(selections model.DropDownSelections) error {
	args := m.Called(selections)
	return args.Error(0)
}

func (m *MockConfigRepository) FetchRoles() ([]string, error) {
	args := m.Called()
	return args.Get(0).([]string), args.Error(1)
}

func (m *MockConfigRepository) SaveRoles(roles []string) error {
	args := m.Called(roles)
	return args.Error(0)
}

func (m *MockConfigRepository) GetDefaultSettingsDir() (string, error) {
	args := m.Called()
	return args.String(0), args.Error(1)
}

// Mock for SystemRepository
type MockSystemRepository struct {
	mock.Mock
}

func (m *MockSystemRepository) GetSystemName(systemID int64) string {
	args := m.Called(systemID)
	return args.String(0)
}

func (m *MockSystemRepository) LoadSystems() error {
	args := m.Called()
	return args.Error(0)
}

type MockHTTPClient struct {
	mock.Mock
}

func (m *MockHTTPClient) DoRequest(method, endpoint string, body interface{}, target interface{}) error {
	args := m.Called(method, endpoint, body, target)
	return args.Error(0)
}

type MockAuthClient struct {
	mock.Mock
}

func (m *MockAuthClient) RefreshToken(refreshToken string) (*oauth2.Token, error) {
	args := m.Called(refreshToken)
	return args.Get(0).(*oauth2.Token), args.Error(1)
}

func (m *MockAuthClient) GetAuthURL(state string) string {
	args := m.Called(state)
	return args.String(0)
}

func (m *MockAuthClient) ExchangeCode(code string) (*oauth2.Token, error) {
	args := m.Called(code)
	return args.Get(0).(*oauth2.Token), args.Error(1)
}

type MockDeletedCharactersRepository struct {
	mock.Mock
}

func (m *MockDeletedCharactersRepository) FetchDeletedCharacters() ([]string, error) {
	args := m.Called()
	return args.Get(0).([]string), args.Error(1)
}

func (m *MockDeletedCharactersRepository) SaveDeletedCharacters(chars []string) error {
	args := m.Called(chars)
	return args.Error(0)
}

type MockCacheService struct {
	mock.Mock
}

func (m *MockCacheService) Get(key string) ([]byte, bool) {
	args := m.Called(key)
	return args.Get(0).([]byte), args.Bool(1)
}

func (m *MockCacheService) Set(key string, value []byte, expiration time.Duration) {
	m.Called(key, value, expiration)
}

func (m *MockCacheService) LoadCache() error {
	args := m.Called()
	return args.Error(0)
}

func (m *MockCacheService) SaveCache() error {
	args := m.Called()
	return args.Error(0)
}

// MockEveProfilesRepository is a mock implementation of the EveProfilesRepository interface.
type MockEveProfilesRepository struct {
	mock.Mock
}

func (m *MockEveProfilesRepository) ListSettingsFiles(subDir, settingsDir string) ([]model.RawFileInfo, error) {
	args := m.Called(subDir, settingsDir)
	return args.Get(0).([]model.RawFileInfo), args.Error(1)
}

func (m *MockEveProfilesRepository) BackupDirectory(targetDir, backupDir string) error {
	args := m.Called(targetDir, backupDir)
	return args.Error(0)
}

func (m *MockEveProfilesRepository) GetSubDirectories(settingsDir string) ([]string, error) {
	args := m.Called(settingsDir)
	return args.Get(0).([]string), args.Error(1)
}

func (m *MockEveProfilesRepository) SyncSubdirectory(subDir, userId, charId, settingsDir string) (int, int, error) {
	args := m.Called(subDir, userId, charId, settingsDir)
	return args.Int(0), args.Int(1), args.Error(2)
}

func (m *MockEveProfilesRepository) SyncAllSubdirectories(baseSubDir, userId, charId, settingsDir string) (int, int, error) {
	args := m.Called(baseSubDir, userId, charId, settingsDir)
	return args.Int(0), args.Int(1), args.Error(2)
}

type MockSkillRepository struct {
	mock.Mock
}

func (m *MockSkillRepository) GetSkillPlans() map[string]model.SkillPlan {
	args := m.Called()
	return args.Get(0).(map[string]model.SkillPlan)
}

func (m *MockSkillRepository) GetSkillPlanFile(name string) ([]byte, error) {
	args := m.Called(name)
	return args.Get(0).([]byte), args.Error(1)
}

func (m *MockSkillRepository) GetSkillTypes() map[string]model.SkillType {
	args := m.Called()
	return args.Get(0).(map[string]model.SkillType)
}

func (m *MockSkillRepository) SaveSkillPlan(planName string, skills map[string]model.Skill) error {
	args := m.Called(planName, skills)
	return args.Error(0)
}

func (m *MockSkillRepository) DeleteSkillPlan(planName string) error {
	args := m.Called(planName)
	return args.Error(0)
}

func (m *MockSkillRepository) GetSkillTypeByID(id string) (model.SkillType, bool) {
	args := m.Called(id)
	return args.Get(0).(model.SkillType), args.Bool(1)
}

// MockSessionService simulates the behavior of SessionService.
// Now it returns a real *sessions.Session instead of a mock session.
type MockSessionService struct {
	Store    *sessions.CookieStore
	Err      error
	LoggedIn bool
}

func (m *MockSessionService) Get(r *http.Request, name string) (*sessions.Session, error) {
	if m.Err != nil {
		return nil, m.Err
	}

	if m.Store == nil {
		m.Store = sessions.NewCookieStore([]byte("secret"))
	}

	// Get the session once
	session, _ := m.Store.Get(r, name)

	// If we want the user to be logged in, set the value here
	if m.LoggedIn {
		session.Values[flyHttp.LoggedIn] = true
	}

	// Return the modified session
	return session, nil
}

// MockDashboardService is a testify mock for DashboardService
type MockDashboardService struct {
	mock.Mock
}

func (m *MockDashboardService) RefreshAccountsAndState() (model.AppState, error) {
	args := m.Called()
	return args.Get(0).(model.AppState), args.Error(1)
}

func (m *MockDashboardService) RefreshDataInBackground() error {
	args := m.Called()
	return args.Error(0)
}

func (m *MockDashboardService) GetCurrentAppState() model.AppState {
	args := m.Called()
	return args.Get(0).(model.AppState)
}

================
File: internal/testutil/stack_logger.go
================
package testutil

import (
	"fmt"
	"runtime"
)

// CaptureCallStack returns a formatted string of the call stack, skipping the specified number of frames.
// skip determines how many stack frames to skip (useful if you call this from within a helper function).
func CaptureCallStack(skip int) string {
	const size = 32
	var pcs [size]uintptr
	n := runtime.Callers(skip, pcs[:])
	frames := runtime.CallersFrames(pcs[:n])

	var callStack string
	for {
		frame, more := frames.Next()
		callStack += fmt.Sprintf("%s\n\t%s:%d\n", frame.Function, frame.File, frame.Line)
		if !more {
			break
		}
	}
	return callStack
}

================
File: renderer/public/vite.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

================
File: renderer/src/api/apiRequest.jsx
================
// src/api/apiRequest.js
import { toast } from 'react-toastify';
import { log, error as cerr } from '../utils/logger.jsx';
import { backEndURL } from '../Config.jsx';

export async function apiRequest(
    url,
    fetchOptions,
    {
        onSuccess,
        onError,
        successMessage,
        errorMessage,
        disableErrorToast = false, // 1) Add a new parameter with default false
    } = {}
) {
    try {
        const response = await fetch(backEndURL + url, fetchOptions);

        let result;
        const contentType = response.headers.get('Content-Type');
        const isJSON = contentType && contentType.includes('application/json');
        if (isJSON) {
            result = await response.json();
            log(result);
        } else {
            result = await response.text();
        }

        if (response.ok) {
            // If the request succeeded:
            if (successMessage) {
                toast.success(successMessage);
            }
            if (onSuccess) {
                onSuccess(result);
            }
            return result;
        } else {
            // If the request failed (4xx or 5xx status codes):
            const errorMsg =
                result?.error || errorMessage || 'An unexpected error occurred.';


            if (response.status !== 401) {
                console.log(result)
                return null
            }

            // 2) Only show the toast if disableErrorToast is false
            if (!disableErrorToast) {
                toast.error(errorMsg);
            }

            if (onError) {
                onError(errorMsg);
            }

            // Return null or throw error, depending on your preferred flow
            return null;
        }
    } catch (error) {
        // 3) Handle network errors or exceptions
        cerr('API request error:', error);

        // Again, only show the toast if disableErrorToast is false
        if (!disableErrorToast) {
            toast.error(errorMessage || 'An error occurred during the request.');
        }

        if (onError) {
            onError(error.message);
        }

        return null;
    }
}

================
File: renderer/src/api/apiRequest.test.jsx
================
// src/api/apiRequest.test.jsx
import { vi } from 'vitest';
import { apiRequest } from './apiRequest';
import { toast } from 'react-toastify';

vi.mock('react-toastify', () => ({
    toast: {
        success: vi.fn(),
        error: vi.fn(),
    }
}));

describe('apiRequest', () => {
    const originalLog = console.log;
    const originalError = console.error;

    beforeAll(() => {
        // Mock console.log and console.error to suppress logs
        console.log = vi.fn();
        console.error = vi.fn();
    });

    afterAll(() => {
        // Restore original console methods after tests
        console.log = originalLog;
        console.error = originalError;
    });

    let onSuccess, onError;

    beforeEach(() => {
        onSuccess = vi.fn();
        onError = vi.fn();
        vi.clearAllMocks();
        global.fetch = vi.fn();
    });

    test('handles successful JSON response with successMessage and onSuccess', async () => {
        const mockData = { foo: 'bar' };
        global.fetch.mockResolvedValue({
            ok: true,
            headers: { get: () => 'application/json' },
            json: vi.fn().mockResolvedValue(mockData),
        });

        const result = await apiRequest('http://test-url', {}, {
            onSuccess,
            successMessage: 'Success!',
        });

        expect(fetch).toHaveBeenCalledWith('http://test-url', {});
        expect(toast.success).toHaveBeenCalledWith('Success!');
        expect(onSuccess).toHaveBeenCalledWith(mockData);
        expect(result).toEqual(mockData);

        // Should NOT call error toast or onError
        expect(toast.error).not.toHaveBeenCalled();
        expect(onError).not.toHaveBeenCalled();
    });

    test('handles successful text response', async () => {
        const mockText = 'Some plain text';
        global.fetch.mockResolvedValue({
            ok: true,
            headers: { get: () => 'text/plain' },
            text: vi.fn().mockResolvedValue(mockText),
        });

        const result = await apiRequest('http://test-url', {}, {
            onSuccess,
            successMessage: 'It worked!'
        });

        expect(toast.success).toHaveBeenCalledWith('It worked!');
        expect(onSuccess).toHaveBeenCalledWith(mockText);
        expect(result).toEqual(mockText);
        expect(toast.error).not.toHaveBeenCalled();
        expect(onError).not.toHaveBeenCalled();
    });

    // This test specifically for 401 errors (since your code only calls onError if status === 401)
    test('handles 401 JSON error response with given errorMessage and onError', async () => {
        const mockError = { error: 'Unauthorized' };
        global.fetch.mockResolvedValue({
            ok: false,
            status: 401, // <--- important!
            headers: { get: () => 'application/json' },
            json: vi.fn().mockResolvedValue(mockError),
        });

        await apiRequest('http://test-url', {}, {
            onError,
            errorMessage: 'Custom error message for 401'
        });

        // Check that the code calls toast.error with "Unauthorized"
        expect(toast.error).toHaveBeenCalledWith('Unauthorized');
        // Check that onError is called with the same message
        expect(onError).toHaveBeenCalledWith('Unauthorized');

        // Should NOT call toast.success or onSuccess
        expect(toast.success).not.toHaveBeenCalled();
    });

    // New test to confirm non-401 errors do NOT trigger onError or toast
    // because your code returns early if (status !== 401).
    test('ignores non-401 error response (e.g. 403)', async () => {
        const mockError = { error: 'Forbidden' };
        global.fetch.mockResolvedValue({
            ok: false,
            status: 403, // <--- non-401
            headers: { get: () => 'application/json' },
            json: vi.fn().mockResolvedValue(mockError),
        });

        await apiRequest('http://test-url', {}, {
            onError,
            errorMessage: 'Should not appear for 403'
        });

        // Expect no toasts or onError since code returns early
        expect(toast.error).not.toHaveBeenCalled();
        expect(onError).not.toHaveBeenCalled();
    });

    test('handles error non-JSON response with fallback errorMessage on 401', async () => {
        global.fetch.mockResolvedValue({
            ok: false,
            status: 401, // 401 triggers onError
            headers: { get: () => 'text/html' },
            text: vi.fn().mockResolvedValue('Some non-JSON error'),
        });

        await apiRequest('http://test-url', {}, {
            onError,
            errorMessage: 'A fallback error for 401'
        });

        // onError is called with 'A fallback error for 401'
        // because "result?.error" is undefined
        expect(onError).toHaveBeenCalledWith('A fallback error for 401');
        expect(toast.error).toHaveBeenCalledWith('A fallback error for 401');
    });

    test('handles network error', async () => {
        global.fetch.mockRejectedValue(new Error('Network failed'));

        await apiRequest('http://test-url', {}, {
            onError,
            errorMessage: 'Request failed'
        });

        // The catch block calls onError with the thrown error message
        expect(onError).toHaveBeenCalledWith('Network failed');
        // No success toast
        expect(toast.success).not.toHaveBeenCalled();
    });

    // Test ensures no error toast is shown when disableErrorToast = true (401 scenario)
    test('does not call toast.error when disableErrorToast=true', async () => {
        global.fetch.mockResolvedValue({
            ok: false,
            status: 401,
            headers: { get: () => 'application/json' },
            json: vi.fn().mockResolvedValue({ error: 'Unauthorized' }),
        });

        await apiRequest('http://test-url', {}, {
            onError,
            errorMessage: 'Some error',
            disableErrorToast: true, // <--- This is the key
        });

        // Verify that toast.error was NOT called
        expect(toast.error).not.toHaveBeenCalled();

        // We DO still call onError callback
        expect(onError).toHaveBeenCalledWith('Unauthorized');
    });
});

================
File: renderer/src/api/apiService.jsx
================
// src/api/apiService.jsx

import { apiRequest } from './apiRequest';
import { normalizeAppData } from '../utils/dataNormalizer';
import {isDev} from '../Config';

export async function getAppData() {
    const response = await apiRequest(`/api/app-data`, {
        credentials: 'include'
    }, {
        errorMessage: isDev ? 'Failed to load app data.' : undefined
    });
    return response ? normalizeAppData(response) : null;
}

export async function getAppDataNoCache() {
    const response = await apiRequest(`/api/app-data-no-cache`, {
        credentials: 'include'
    }, {
        errorMessage: 'Failed to load data.'
    });
    return response ? normalizeAppData(response) : null;
}

export async function logout() {
    return apiRequest('/api/logout', {
        method: 'POST',
        credentials: 'include'
    }, {
        errorMessage: 'Failed to log out.'
    });
}

export async function toggleAccountStatus(accountID) {
    return apiRequest('/api/toggle-account-status', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ accountID })
    }, {
        errorMessage: 'Failed to toggle account status.'
    });
}

export async function toggleAccountVisibility(accountID) {
    return apiRequest('/api/toggle-account-visibility', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ accountID })
    }, {
        errorMessage: 'Failed to toggle account visibility.'
    });
}


export async function updateCharacter(characterID, updates) {
    return apiRequest('/api/update-character', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ characterID, updates }),
        credentials: 'include'
    }, {
        errorMessage: 'Failed to update character.'
    });
}

export async function removeCharacter(characterID) {
    return apiRequest('/api/remove-character', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ characterID }),
        credentials: 'include'
    }, {
        errorMessage: 'Failed to remove character.'
    });
}

export async function updateAccountName(accountID, newName) {
    return apiRequest('/api/update-account-name', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ accountID, accountName: newName }),
        credentials: 'include'
    }, {
        errorMessage: 'Failed to update account name.'
    });
}

export async function removeAccount(accountName) {
    return apiRequest('/api/remove-account', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ accountName }),
        credentials: 'include'
    }, {
        successMessage: 'Account removed successfully!',
        errorMessage: 'Failed to remove account.'
    });
}

export async function addCharacter(account) {
    return await apiRequest(
        '/api/add-character',
        {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ account }),
            credentials: 'include'
        },
    );
}



export async function saveSkillPlan(planName, planContents) {
    return apiRequest('/api/save-skill-plan', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name: planName, contents: planContents }),
        credentials: 'include'
    }, {
        successMessage: 'Skill Plan Saved!',
        errorMessage: 'Failed to save skill plan.'
    });
}


export async function saveUserSelections(newSelections) {
    return apiRequest(`/api/save-user-selections`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify(newSelections),
    }, {
        errorMessage: 'Failed to save user selections.',
    });
}

export async function syncSubdirectory(profile, userId, charId) {
    return apiRequest(`/api/sync-subdirectory`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ subDir: profile, userId, charId })
    }, {
        errorMessage: 'Sync operation failed.'
    });
}

export async function syncAllSubdirectories(profile, userId, charId) {
    return apiRequest(`/api/sync-all-subdirectories`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ subDir: profile, userId, charId })
    }, {
        errorMessage: 'Sync-All operation failed.'
    });
}

export async function chooseSettingsDir(directory) {
    return apiRequest(`/api/choose-settings-dir`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ directory }),
    }, {
        errorMessage: 'Failed to choose settings directory.'
    });
}

export async function backupDirectory(targetDir, backupDir) {
    return apiRequest(`/api/backup-directory`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ targetDir, backupDir }),
    }, {
        errorMessage: 'Backup operation failed.'
    });
}

export async function resetToDefaultDirectory() {
    return apiRequest(`/api/reset-to-default-directory`, {
        method: 'POST',
        credentials: 'include',
    }, {
        errorMessage: 'Failed to reset directory.'
    });
}

export async function associateCharacter(userId, charId, userName, charName) {
    return apiRequest(`/api/associate-character`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ userId, charId, userName, charName })
    }, {
        errorMessage: 'Association operation failed.'
    });
}

export async function unassociateCharacter(userId, charId, userName, charName) {
    return apiRequest(`/api/unassociate-character`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        credentials: 'include',
        body: JSON.stringify({ userId, charId, userName, charName })
    }, {
        errorMessage: 'Unassociation operation failed.'
    });
}

export async function deleteSkillPlan(planName) {
    return apiRequest(`/api/delete-skill-plan?planName=${encodeURIComponent(planName)}`, {
        method: 'DELETE',
        credentials: 'include',
    }, {
        errorMessage: 'Failed to delete skill plan.'
    });
}

export async function initiateLogin(account) {
    // Removed isDev parameter; we can handle isDev in the component if needed
    return apiRequest(`/api/login`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ account }),
        credentials: 'include',
    }, {
        errorMessage: 'Failed to initiate login.'
    });
}


export async function finalizelogin(state) {
    return apiRequest(`/api/finalize-login?state=${state}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
    }, {
        disableErrorToast: true,
    });
}

================
File: renderer/src/api/apiService.test.jsx
================
// src/api/apiService.test.js
import { vi } from 'vitest';
import {
    getAppData,
    getAppDataNoCache,
    logout,
    toggleAccountStatus,
    updateCharacter,
    removeCharacter,
    updateAccountName,
    removeAccount,
    addCharacter,
    saveSkillPlan,
    saveUserSelections,
    syncSubdirectory,
    syncAllSubdirectories,
    chooseSettingsDir,
    backupDirectory,
    resetToDefaultDirectory,
    associateCharacter,
    unassociateCharacter,
    deleteSkillPlan,
    initiateLogin
} from './apiService';
import { apiRequest } from './apiRequest';
import { normalizeAppData } from '../utils/dataNormalizer';

vi.mock('./apiRequest', () => ({
    apiRequest: vi.fn()
}));
vi.mock('../utils/dataNormalizer', () => ({
    normalizeAppData: vi.fn()
}));

describe('apiService', () => {
    const backEndURL = 'http://backend.test';

    beforeEach(() => {
        vi.clearAllMocks();
    });

    describe('getAppData', () => {
        test('returns normalized data on success', async () => {
            const mockData = { foo: 'bar' };
            const normalizedData = { foo: 'normalized' };
            apiRequest.mockResolvedValue(mockData);
            normalizeAppData.mockReturnValue(normalizedData);

            const result = await getAppData();
            // Depending on isDev, errorMessage may be present or not. Let's assume isDev is true for testing.
            expect(apiRequest).toHaveBeenCalledWith(`/api/app-data`, { credentials: 'include' }, { errorMessage: 'Failed to load app data.' });
            expect(normalizeAppData).toHaveBeenCalledWith(mockData);
            expect(result).toBe(normalizedData);
        });

        test('returns null if no response', async () => {
            apiRequest.mockResolvedValue(null);
            const result = await getAppData();
            expect(result).toBeNull();
        });
    });

    describe('getAppDataNoCache', () => {
        test('returns normalized data on success', async () => {
            const mockData = { baz: 'qux' };
            const normalizedData = { baz: 'normalized' };
            apiRequest.mockResolvedValue(mockData);
            normalizeAppData.mockReturnValue(normalizedData);

            const result = await getAppDataNoCache();
            expect(apiRequest).toHaveBeenCalledWith(`/api/app-data-no-cache`, { credentials: 'include' }, { errorMessage: 'Failed to load data.' });
            expect(normalizeAppData).toHaveBeenCalledWith(mockData);
            expect(result).toBe(normalizedData);
        });

        test('returns null if no response', async () => {
            apiRequest.mockResolvedValue(null);
            const result = await getAppDataNoCache();
            expect(result).toBeNull();
        });
    });

    describe('logout', () => {
        test('calls apiRequest with correct parameters', async () => {
            apiRequest.mockResolvedValue('success');
            const result = await logout();
            expect(apiRequest).toHaveBeenCalledWith('/api/logout', {
                method: 'POST',
                credentials: 'include'
            }, {
                errorMessage: 'Failed to log out.'
            });
            expect(result).toBe('success');
        });
    });

    describe('toggleAccountStatus', () => {
        test('calls apiRequest correctly', async () => {
            apiRequest.mockResolvedValue('toggled');
            const result = await toggleAccountStatus(123);
            expect(apiRequest).toHaveBeenCalledWith('/api/toggle-account-status', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'include',
                body: JSON.stringify({ accountID: 123 })
            }, {
                errorMessage: 'Failed to toggle account status.'
            });
            expect(result).toBe('toggled');
        });
    });

    describe('updateCharacter', () => {
        test('calls apiRequest correctly', async () => {
            apiRequest.mockResolvedValue('updated');
            const updates = { Role: 'Pvp' };
            const result = await updateCharacter(456, updates);
            expect(apiRequest).toHaveBeenCalledWith('/api/update-character', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ characterID: 456, updates }),
                credentials: 'include'
            }, {
                errorMessage: 'Failed to update character.'
            });
            expect(result).toBe('updated');
        });
    });

    describe('removeCharacter', () => {
        test('calls apiRequest correctly', async () => {
            apiRequest.mockResolvedValue('removed');
            const result = await removeCharacter(789);
            expect(apiRequest).toHaveBeenCalledWith('/api/remove-character', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ characterID: 789 }),
                credentials: 'include'
            }, {
                errorMessage: 'Failed to remove character.'
            });
            expect(result).toBe('removed');
        });
    });

    describe('updateAccountName', () => {
        test('calls apiRequest correctly', async () => {
            apiRequest.mockResolvedValue('name updated');
            const result = await updateAccountName(42, 'NewName');
            expect(apiRequest).toHaveBeenCalledWith('/api/update-account-name', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ accountID: 42, accountName: 'NewName' }),
                credentials: 'include'
            }, {
                errorMessage: 'Failed to update account name.'
            });
            expect(result).toBe('name updated');
        });
    });

    // In apiService.test.js, update the removeAccount test:
    describe('removeAccount', () => {
        test('calls apiRequest correctly', async () => {
            apiRequest.mockResolvedValue('account removed');
            const result = await removeAccount('TestAccount');
            expect(apiRequest).toHaveBeenCalledWith('/api/remove-account', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ accountName: 'TestAccount' }),
                credentials: 'include'
            }, {
                // Include successMessage since the code now has it
                successMessage: 'Account removed successfully!',
                errorMessage: 'Failed to remove account.'
            });
            expect(result).toBe('account removed');
        });
    });

// In apiService.test.js, update the saveSkillPlan test:
    describe('saveSkillPlan', () => {
        test('calls apiRequest correctly', async () => {
            apiRequest.mockResolvedValue('saved');
            const result = await saveSkillPlan('MyPlan', { skill: 'Level5' });
            expect(apiRequest).toHaveBeenCalledWith('/api/save-skill-plan', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: 'MyPlan', contents: { skill: 'Level5' } }),
                credentials: 'include'
            }, {
                // Include successMessage here as well
                successMessage: 'Skill Plan Saved!',
                errorMessage: 'Failed to save skill plan.'
            });
            expect(result).toBe('saved');
        });
    });


    describe('saveUserSelections', () => {
        test('calls apiRequest correctly', async () => {
            apiRequest.mockResolvedValue('selections saved');
            const newSelections = { theme: 'dark' };
            const result = await saveUserSelections(newSelections);
            expect(apiRequest).toHaveBeenCalledWith(`/api/save-user-selections`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'include',
                body: JSON.stringify(newSelections),
            }, {
                errorMessage: 'Failed to save user selections.',
            });
            expect(result).toBe('selections saved');
        });
    });

    describe('syncSubdirectory', () => {
        test('calls apiRequest correctly', async () => {
            apiRequest.mockResolvedValue('synced');
            const result = await syncSubdirectory('profile1', 'user123', 'char456');
            expect(apiRequest).toHaveBeenCalledWith(`/api/sync-subdirectory`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'include',
                body: JSON.stringify({ profile: 'profile1', userId: 'user123', charId: 'char456' })
            }, {
                errorMessage: 'Sync operation failed.'
            });
            expect(result).toBe('synced');
        });
    });

    describe('syncAllSubdirectories', () => {
        test('calls apiRequest correctly', async () => {
            apiRequest.mockResolvedValue('all synced');
            const result = await syncAllSubdirectories('profile1', 'user123', 'char456');
            expect(apiRequest).toHaveBeenCalledWith(`/api/sync-all-subdirectories`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'include',
                body: JSON.stringify({ profile: 'profile1', userId: 'user123', charId: 'char456' })
            }, {
                errorMessage: 'Sync-All operation failed.'
            });
            expect(result).toBe('all synced');
        });
    });

    describe('chooseSettingsDir', () => {
        test('calls apiRequest correctly', async () => {
            apiRequest.mockResolvedValue('chosen');
            const result = await chooseSettingsDir('/path/to/dir');
            expect(apiRequest).toHaveBeenCalledWith(`/api/choose-settings-dir`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'include',
                body: JSON.stringify({ directory: '/path/to/dir' }),
            }, {
                errorMessage: 'Failed to choose settings directory.'
            });
            expect(result).toBe('chosen');
        });
    });

    describe('backupDirectory', () => {
        test('calls apiRequest correctly', async () => {
            apiRequest.mockResolvedValue('backed up');
            const result = await backupDirectory('/target/dir', '/backup/dir');
            expect(apiRequest).toHaveBeenCalledWith(`/api/backup-directory`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'include',
                body: JSON.stringify({ targetDir: '/target/dir', backupDir: '/backup/dir' }),
            }, {
                errorMessage: 'Backup operation failed.'
            });
            expect(result).toBe('backed up');
        });
    });

    describe('resetToDefaultDirectory', () => {
        test('calls apiRequest correctly', async () => {
            apiRequest.mockResolvedValue('reset');
            const result = await resetToDefaultDirectory();
            expect(apiRequest).toHaveBeenCalledWith(`/api/reset-to-default-directory`, {
                method: 'POST',
                credentials: 'include',
            }, {
                errorMessage: 'Failed to reset directory.'
            });
            expect(result).toBe('reset');
        });
    });

    describe('associateCharacter', () => {
        test('calls apiRequest correctly', async () => {
            apiRequest.mockResolvedValue('associated');
            const result = await associateCharacter('user1', 'char1', 'UserName', 'CharName');
            expect(apiRequest).toHaveBeenCalledWith(`/api/associate-character`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'include',
                body: JSON.stringify({ userId: 'user1', charId: 'char1', userName: 'UserName', charName: 'CharName' })
            }, {
                errorMessage: 'Association operation failed.'
            });
            expect(result).toBe('associated');
        });
    });

    describe('unassociateCharacter', () => {
        test('calls apiRequest correctly', async () => {
            apiRequest.mockResolvedValue('unassociated');
            const result = await unassociateCharacter('user1', 'char1', 'UserName', 'CharName');
            expect(apiRequest).toHaveBeenCalledWith(`/api/unassociate-character`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                credentials: 'include',
                body: JSON.stringify({ userId: 'user1', charId: 'char1', userName: 'UserName', charName: 'CharName' })
            }, {
                errorMessage: 'Unassociation operation failed.'
            });
            expect(result).toBe('unassociated');
        });
    });

    describe('deleteSkillPlan', () => {
        test('calls apiRequest correctly', async () => {
            apiRequest.mockResolvedValue('deleted');
            const result = await deleteSkillPlan('MyPlan');
            expect(apiRequest).toHaveBeenCalledWith(`/api/delete-skill-plan?planName=MyPlan`, {
                method: 'DELETE',
                credentials: 'include',
            }, {
                errorMessage: 'Failed to delete skill plan.'
            });
            expect(result).toBe('deleted');
        });
    });

    describe('initiateLogin', () => {
        test('calls apiRequest correctly', async () => {
            apiRequest.mockResolvedValue('login started');
            const account = { Name: 'LoginAccount' };
            const result = await initiateLogin(account);
            expect(apiRequest).toHaveBeenCalledWith(`/api/login`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ account }),
                credentials: 'include',
            }, {
                errorMessage: 'Failed to initiate login.'
            });
            expect(result).toBe('login started');
        });
    });
});

================
File: renderer/src/assets/react.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>

================
File: renderer/src/components/common/AccountPromptModal.jsx
================
import { useState, useEffect, useRef } from 'react';
import PropTypes from 'prop-types';
import { IconButton, Select, MenuItem, TextField } from '@mui/material';
import { Check as CheckIcon } from '@mui/icons-material';

const AccountPromptModal = ({ isOpen, onClose, onSubmit, title, existingAccounts }) => {
    const [account, setAccount] = useState('');
    const [isAddingAccount, setIsAddingAccount] = useState(false);
    const [newAccount, setNewAccount] = useState('');

    const selectRef = useRef(null);
    const textFieldRef = useRef(null);

    useEffect(() => {
        if (!isOpen) {
            setAccount('');
            setIsAddingAccount(false);
            setNewAccount('');
        } else {
            // Modal just opened
            // Focus the appropriate element
            if (existingAccounts && existingAccounts.length > 0 && !isAddingAccount) {
                // Focus the select component
                if (selectRef.current) {
                    selectRef.current.focus();
                }
            } else {
                // Focus the text field for adding a new account
                if (textFieldRef.current) {
                    textFieldRef.current.querySelector('input')?.focus();
                }
            }
        }
    }, [isOpen, existingAccounts, isAddingAccount]);

    const handleAccountChange = (event) => {
        const selectedValue = event.target.value;
        if (selectedValue === 'add_new_account') {
            setIsAddingAccount(true);
            setAccount('');
            // Focus the text field when switching to add new account
            setTimeout(() => {
                if (textFieldRef.current) {
                    textFieldRef.current.querySelector('input')?.focus();
                }
            }, 0);
        } else {
            setIsAddingAccount(false);
            setAccount(selectedValue);
        }
    };

    const handleAddAccount = () => {
        if (newAccount.trim() !== '') {
            const trimmed = newAccount.trim();
            setAccount(trimmed);
            setIsAddingAccount(false);
            setNewAccount('');
        }
    };

    const handleSubmit = () => {
        const finalAccount = isAddingAccount ? newAccount.trim() : account;
        if (!finalAccount) return;
        onSubmit(finalAccount);
        setAccount('');
        setIsAddingAccount(false);
        setNewAccount('');
    };

    if (!isOpen) return null;

    const hasExistingAccounts = existingAccounts && existingAccounts.length > 0;

    return (
        <div className="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-50">
            <div className="bg-gray-800 text-teal-200 p-6 rounded shadow-md w-80">
                <h2 className="mb-4 text-lg font-semibold">{title || 'Enter Account Name'}</h2>

                {!isAddingAccount && hasExistingAccounts && (
                    <div className="mb-4">
                        <Select
                            value={account || ''}
                            onChange={handleAccountChange}
                            displayEmpty
                            fullWidth
                            inputRef={selectRef}
                            sx={{
                                backgroundColor: 'background.paper',
                                borderRadius: 1,
                                '& .MuiSelect-select': {
                                    padding: '10px 14px',
                                },
                            }}
                        >
                            <MenuItem value="" disabled>
                                Select Account
                            </MenuItem>
                            {existingAccounts.map((acc) => (
                                <MenuItem key={acc} value={acc}>
                                    {acc}
                                </MenuItem>
                            ))}
                            <MenuItem value="add_new_account">Add New Account</MenuItem>
                        </Select>
                    </div>
                )}

                {(!hasExistingAccounts || isAddingAccount) && (
                    <div className="mb-4 flex items-center space-x-2" ref={textFieldRef}>
                        <TextField
                            size="small"
                            value={isAddingAccount ? newAccount : account}
                            onChange={(e) =>
                                isAddingAccount ? setNewAccount(e.target.value) : setAccount(e.target.value)
                            }
                            placeholder="Enter account name"
                            fullWidth
                            sx={{
                                '& .MuiInputBase-root': {
                                    padding: '2px',
                                },
                            }}
                        />
                        {isAddingAccount && (
                            <IconButton onClick={handleAddAccount} size="small" color="primary">
                                <CheckIcon fontSize="small" />
                            </IconButton>
                        )}
                    </div>
                )}

                <div className="flex justify-end space-x-3">
                    <button
                        onClick={onClose}
                        className="py-2 px-4 bg-gray-600 text-white rounded hover:bg-gray-700"
                    >
                        Cancel
                    </button>
                    <button
                        onClick={handleSubmit}
                        className="py-2 px-4 bg-teal-600 text-white rounded hover:bg-teal-700"
                    >
                        Submit
                    </button>
                </div>
            </div>
        </div>
    );
};

AccountPromptModal.propTypes = {
    isOpen: PropTypes.bool.isRequired,
    onClose: PropTypes.func.isRequired,
    onSubmit: PropTypes.func.isRequired,
    title: PropTypes.string,
    existingAccounts: PropTypes.arrayOf(PropTypes.string),
};

export default AccountPromptModal;

================
File: renderer/src/components/common/CharacterDetailModal.jsx
================
import React from 'react';
import PropTypes from 'prop-types';
import {
    Dialog,
    DialogTitle,
    DialogContent,
    DialogActions,
    IconButton,
    Tooltip,
} from '@mui/material';
import CloseIcon from '@mui/icons-material/Close';
import OpenInNewIcon from '@mui/icons-material/OpenInNew';
import { calculateDaysFromToday } from "../../utils/formatter.jsx";


const CharacterDetailModal = ({
                                  open,
                                  onClose,
                                  character,
                                  skillConversions,
                              }) => {
    if (!character || !character.Character) {
        return null;
    }

    const charId = character.Character.CharacterID;
    const charName = character.Character.CharacterName;
    const portraitUrl = `https://images.evetech.net/characters/${charId}/portrait`;
    const totalSp = character?.Character?.CharacterSkillsResponse?.total_sp;
    const formattedSP = totalSp ? totalSp.toLocaleString() : '0';
    const zKillUrl = `https://zkillboard.com/character/${charId}/`;

    const mctTooltip = character.MCT
        ? `Training: ${character.Training || 'Unknown'}`
        : 'Skill queue paused';

    // Use the entire skill queue
    const skillQueueItems = character.Character.SkillQueue || [];

    return (
        <Dialog open={open} onClose={onClose} maxWidth="sm" fullWidth>
            {/* Modal Title Bar */}
            <div className="flex justify-between items-center px-4 py-2 bg-gray-700">
                <DialogTitle className="text-teal-200 p-0">
                    {charName}
                </DialogTitle>
                <IconButton aria-label="close" onClick={onClose} sx={{ color: '#99f6e4' }}>
                    <CloseIcon />
                </IconButton>
            </div>

            <DialogContent className="bg-gray-800 text-teal-100">
                {/* Character Header Info */}
                <div className="flex flex-col sm:flex-row sm:space-x-4 mt-4">
                    <img
                        src={portraitUrl}
                        alt={`${charName} portrait`}
                        className="w-32 h-32 rounded-md shadow-md border border-teal-600"
                    />
                    <div className="mt-2 sm:mt-0 flex-1">
                        <div className="flex items-center space-x-2">
                            <Tooltip title="Open zKillboard">
                                <IconButton
                                    aria-label="Open zKillboard"
                                    size="small"
                                    onClick={() => {
                                        if (window.electronAPI && window.electronAPI.openExternal) {
                                            window.electronAPI.openExternal(zKillUrl);
                                        } else {
                                            window.open(zKillUrl, '_blank', 'noopener,noreferrer');
                                        }
                                    }}
                                    sx={{ color: '#99f6e4', '&:hover': { color: '#ffffff' } }}
                                >
                                    <OpenInNewIcon fontSize="inherit" />
                                </IconButton>
                            </Tooltip>

                            <Tooltip title={mctTooltip}>
                                <div
                                    data-testid="mct-indicator"
                                    className={`w-3 h-3 rounded-full ${character.MCT ? 'bg-green-400' : 'bg-gray-400'}`}
                                ></div>
                            </Tooltip>
                        </div>
                        <div className="flex flex-col mt-2 space-y-1">
                            {character.Role && (
                                <div className="text-sm">
                                    <span className="text-teal-400 font-medium">Role:</span> {character.Role}
                                </div>
                            )}
                            <div className="text-sm">
                                <span className="text-teal-400 font-medium">Location:</span> {character.Character.LocationName || 'Unknown'}
                            </div>
                            <div className="text-sm">
                                <span className="text-teal-400 font-medium">Total SP:</span> {formattedSP}
                            </div>
                            {character.CorporationName && (
                                <div className="text-sm">
                                    <span className="text-teal-400 font-medium">Corporation:</span>
                                    <span className="text-gray-300 italic"> {character.CorporationName} </span>
                                </div>
                            )}
                            {character.AllianceName && (
                                <div className="text-sm">
                                    <span className="text-teal-400 font-medium">Alliance:</span>
                                    <span className="text-gray-300 italic"> {character.AllianceName} </span>
                                </div>
                            )}
                        </div>
                    </div>
                </div>

                {/* Skill Queue Section */}
                <h3 className="text-teal-200 font-semibold text-md mt-6 mb-2">
                    Skill Queue
                </h3>
                {skillQueueItems.length === 0 ? (
                    <div className="text-gray-300 text-sm">No skill queue data available.</div>
                ) : (
                    <div className="overflow-x-auto max-h-64 overflow-y-auto border border-gray-700 rounded">
                        <table className="min-w-full text-sm">
                            <thead className="bg-gray-700 text-teal-300">
                            <tr>
                                <th className="px-2 py-1 text-left">Skill</th>
                                <th className="px-2 py-1 text-left">Level</th>
                                <th className="px-2 py-1 text-left">Completion</th>
                            </tr>
                            </thead>
                            <tbody>
                            {skillQueueItems.map((item, index) => {
                                const finishDate = item.finish_date ? calculateDaysFromToday(item.finish_date) : 'N/A';

                                // Convert skill_id to skill name
                                const skillName = skillConversions[item.skill_id] || `Skill #${item.skill_id}`;

                                return (
                                    <tr key={index} className="border-b border-gray-600 text-gray-200">
                                        <td className="px-2 py-1">{skillName}</td>
                                        <td className="px-2 py-1">{item.finished_level}</td>
                                        <td className="px-2 py-1">{finishDate}</td>
                                    </tr>
                                );
                            })}
                            </tbody>
                        </table>
                    </div>
                )}
            </DialogContent>

            <DialogActions className="bg-gray-800">
                <button
                    onClick={onClose}
                    className="px-3 py-1 bg-teal-600 hover:bg-teal-500 text-white rounded text-sm"
                >
                    Close
                </button>
            </DialogActions>
        </Dialog>
    );
};

CharacterDetailModal.propTypes = {
    open: PropTypes.bool.isRequired,
    onClose: PropTypes.func.isRequired,
    character: PropTypes.object.isRequired,
    skillConversions: PropTypes.object.isRequired,
};

export default CharacterDetailModal;

================
File: renderer/src/components/common/CustomConfirmDialog.jsx
================
// CustomConfirmDialog.jsx
import React from 'react';
import PropTypes from 'prop-types';
import {
    Dialog,
    DialogTitle,
    DialogContent,
    DialogActions,
    Button,
    Typography,
    useTheme,
    Divider
} from '@mui/material';
import CheckIcon from '@mui/icons-material/Check';
import CloseIcon from '@mui/icons-material/Close';

const CustomConfirmDialog = ({
                                 open,
                                 title,
                                 message,
                                 onConfirm,
                                 onCancel
                             }) => {
    const theme = useTheme();

    return (
        <Dialog
            open={open}
            onClose={onCancel}
            PaperProps={{
                sx: {
                    borderRadius: 2,
                    boxShadow: theme.shadows[5],
                    backgroundColor: theme.palette.background.paper
                }
            }}
        >
            <DialogTitle
                sx={{
                    backgroundColor: theme.palette.primary.main,
                    color: theme.palette.primary.contrastText,
                    padding: theme.spacing(2),
                    fontWeight: 600,
                }}
            >
                {title}
            </DialogTitle>

            <Divider />

            <DialogContent sx={{ padding: theme.spacing(3) }}>
                <Typography variant="body1">{message}</Typography>
            </DialogContent>

            <Divider />

            <DialogActions sx={{ padding: theme.spacing(2) }}>
                <Button
                    onClick={onCancel}
                    color="inherit"
                    startIcon={<CloseIcon />}
                    variant="outlined"
                    sx={{ mr: 1 }}
                >
                    Cancel
                </Button>
                <Button
                    onClick={onConfirm}
                    color="primary"
                    startIcon={<CheckIcon />}
                    variant="contained"
                >
                    Confirm
                </Button>
            </DialogActions>
        </Dialog>
    );
};

CustomConfirmDialog.propTypes = {
    open: PropTypes.bool.isRequired,
    title: PropTypes.string.isRequired,
    message: PropTypes.string.isRequired,
    onConfirm: PropTypes.func.isRequired,
    onCancel: PropTypes.func.isRequired,
};

export default CustomConfirmDialog;

================
File: renderer/src/components/common/ErrorBoundary.jsx
================
// src/components/ErrorBoundary.jsx

import React from 'react';
import { error as cerr } from '../../utils/logger.jsx'

class ErrorBoundary extends React.Component {
    constructor(props) {
        super(props);
        this.state = { hasError: false };
    }

    static getDerivedStateFromError(error) {
        // Update state to show fallback UI
        return { hasError: true };
    }

    componentDidCatch(error, info) {
        // Log error details
        cerr("ErrorBoundary caught an error:", error, info);
    }

    render() {
        if (this.state.hasError) {
            return <h2>Something went wrong. Please try again later.</h2>;
        }

        return this.props.children;
    }
}

export default ErrorBoundary;

================
File: renderer/src/components/common/Footer.jsx
================
import footerImg from '../../assets/images/footer-logo.jpg';


const Footer = () => {
    return (
        <footer
            className="fixed bottom-0 left-0 w-full bg-gradient-to-r from-gray-900 to-gray-800 text-teal-200 py-4 shadow-inner border-t-4 border-teal-500 z-50"
            style={{ WebkitAppRegion: 'drag' }}
        >
            <div className="container mx-auto px-4 flex flex-col items-center justify-center">
                <img
                    src={footerImg}
                    alt="Logo"
                    className="h-8 w-8 mb-2 rounded-full border-2 border-teal-500"
                />
                <span className="text-sm">
                    &copy; {new Date().getFullYear()} Can I Fly? All rights reserved.
                </span>
            </div>
        </footer>
    );
};

export default Footer;

================
File: renderer/src/components/common/Header.jsx
================
import { useState } from 'react';
import PropTypes from 'prop-types';
import { useLocation, Link } from 'react-router-dom';
import {
    AppBar,
    Toolbar,
    IconButton,
    Typography,
    Box,
    Drawer,
    List,
    ListItem,
    ListItemIcon,
    ListItemText,
    ListItemButton,
    Tooltip,
    CircularProgress,
    Divider
} from '@mui/material';
import {
    Menu as MenuIcon,
    AddCircleOutline,
    ExitToApp,
    Close,
    Dashboard as CharacterOverviewIcon,
    ListAlt as SkillPlansIcon,
    Sync as SyncIcon,
    AccountTree as MappingIcon,
    Cached as RefreshIcon
} from '@mui/icons-material';
import { styled } from '@mui/material/styles';
import AccountPromptModal from './AccountPromptModal.jsx';
import nav_img1 from '../../assets/images/nav-logo.png';
import nav_img2 from '../../assets/images/nav-logo2.webp';

const StyledAppBar = styled(AppBar)(() => ({
    backgroundImage: 'linear-gradient(to right, #1f2937, #1f2937)',
    color: '#14b8a6',
    boxShadow: 'inset 0 -4px 0 0 #14b8a6',
    borderBottom: '4px solid #14b8a6',
}));

const StyledDrawer = styled(Drawer)(() => ({
    '& .MuiPaper-root': {
        background: 'linear-gradient(to bottom, #1f2937, #111827)',
        overflow: 'hidden',
        color: '#5eead4',
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'space-between',
        width: 250 // Ensure the drawer has a fixed width
    }
}));

const Header = ({ loggedIn, handleLogout, openSkillPlanModal, existingAccounts, onSilentRefresh, onAddCharacter, isRefreshing }) => {
    const location = useLocation();
    const [drawerOpen, setDrawerOpen] = useState(false);
    const [modalOpen, setModalOpen] = useState(false);
    // State to toggle between two images each time the nav is opened
    const [useAlternateImage, setUseAlternateImage] = useState(false);

    const handleCloseWindow = () => {
        if (window.electronAPI && window.electronAPI.closeWindow) {
            window.electronAPI.closeWindow();
        } else {
            console.error('Electron API not available');
        }
    };

    const toggleDrawer = (open) => () => {
        setDrawerOpen(open);
        if (open === true) {
            setUseAlternateImage((prev) => !prev);
        }
    };

    const navigationLinks = [
        { text: 'Overview', icon: <CharacterOverviewIcon />, path: '/' },
        { text: 'Skill Plans', icon: <SkillPlansIcon />, path: '/skill-plans' },
        { text: 'Mapping', icon: <MappingIcon />, path: '/mapping' },
        { text: 'Sync', icon: <SyncIcon />, path: '/sync' },
    ];

    const handleAddCharacterClick = () => {
        setModalOpen(true);
    };

    const handleCloseModal = () => {
        setModalOpen(false);
    };

    const handleAddCharacterSubmit = async (account) => {
        await onAddCharacter(account);
        setModalOpen(false);
    };

    const handleRefreshClick = async () => {
        if (!onSilentRefresh) return;
        await onSilentRefresh();
    };

    const chosenImage = useAlternateImage ? nav_img2 : nav_img1;

    return (
        <>
            <StyledAppBar position="fixed">
                <Toolbar style={{ WebkitAppRegion: 'drag', display: 'flex', alignItems: 'center' }}>
                    {loggedIn && (
                        <>
                            <IconButton
                                edge="start"
                                color="inherit"
                                aria-label="menu"
                                onClick={toggleDrawer(true)}
                                style={{ WebkitAppRegion: 'no-drag' }}
                            >
                                <MenuIcon />
                            </IconButton>
                            <Tooltip title="Add Character">
                                <IconButton onClick={handleAddCharacterClick} style={{ WebkitAppRegion: 'no-drag' }}>
                                    <AddCircleOutline sx={{ color: '#22c55e' }} />
                                </IconButton>
                            </Tooltip>
                            <Tooltip title="Add Skill Plan">
                                <IconButton onClick={openSkillPlanModal} style={{ WebkitAppRegion: 'no-drag' }}>
                                    <SkillPlansIcon sx={{ color: '#f59e0b' }} />
                                </IconButton>
                            </Tooltip>
                        </>
                    )}

                    <Box sx={{ flex: 1, display: 'flex', justifyContent: 'center' }}>
                        <Typography
                            variant="h6"
                            sx={{ color: '#14b8a6', textAlign: 'center' }}
                        >
                            Can I Fly?
                        </Typography>
                    </Box>

                    <Box sx={{ display: 'flex', alignItems: 'center', WebkitAppRegion: 'no-drag' }}>
                        {loggedIn && (
                            <>
                                <Tooltip title="Refresh Data">
                                    <IconButton onClick={handleRefreshClick}>
                                        {isRefreshing ? (
                                            <CircularProgress size={24} sx={{ color: '#9ca3af' }} />
                                        ) : (
                                            <RefreshIcon sx={{ color: '#9ca3af' }} />
                                        )}
                                    </IconButton>
                                </Tooltip>
                                <Tooltip title="Logout">
                                    <IconButton onClick={handleLogout}>
                                        <ExitToApp sx={{ color: '#ef4444' }} />
                                    </IconButton>
                                </Tooltip>
                            </>
                        )}
                        <Tooltip title="Close">
                            <IconButton onClick={handleCloseWindow}>
                                <Close sx={{ color: '#9ca3af' }} />
                            </IconButton>
                        </Tooltip>
                    </Box>
                </Toolbar>
            </StyledAppBar>

            <StyledDrawer anchor="left" open={drawerOpen} onClose={toggleDrawer(false)} disableScrollLock>
                <div
                    role="presentation"
                    onClick={toggleDrawer(false)}
                    onKeyDown={toggleDrawer(false)}
                    style={{ flex: 1, display: 'flex', flexDirection: 'column', justifyContent: 'space-between' }}
                >
                    <List sx={{ flex: 1 }}>
                        {navigationLinks.map((item, index) => (
                            <div key={item.text}>
                                <ListItem disablePadding>
                                    <ListItemButton
                                        component={Link}
                                        to={item.path}
                                        selected={location.pathname === item.path}
                                        sx={{
                                            '&:hover': {
                                                backgroundColor: '#0f172a',
                                                '& .MuiListItemText-primary': {
                                                    color: '#a7f3d0',
                                                },
                                                '& .MuiListItemIcon-root': {
                                                    color: '#a7f3d0',
                                                },
                                            },
                                            '&.Mui-selected': {
                                                backgroundColor: '#134e4a',
                                                '&:hover': {
                                                    backgroundColor: '#145a54',
                                                    '& .MuiListItemText-primary': {
                                                        color: '#a7f3d0',
                                                    },
                                                    '& .MuiListItemIcon-root': {
                                                        color: '#a7f3d0',
                                                    },
                                                },
                                            },
                                        }}
                                    >
                                        <ListItemIcon sx={{ color: '#5eead4' }}>{item.icon}</ListItemIcon>
                                        <ListItemText
                                            primary={item.text}
                                            primaryTypographyProps={{ sx: { color: '#5eead4' } }}
                                        />
                                    </ListItemButton>
                                </ListItem>

                                {index === 1 && (
                                    <Divider
                                        sx={{
                                            backgroundColor: '#14b8a6',
                                            marginY: '4px',
                                            opacity: 0.5
                                        }}
                                    />
                                )}
                            </div>
                        ))}
                    </List>
                    {/* Image at the bottom of the nav drawer */}
                    <Box sx={{ p: 2, textAlign: 'center' }}>
                        <img
                            src={chosenImage}
                            alt="Nav Logo"
                            style={{
                                maxWidth: '220px',
                                height: 'auto',
                                display: 'block',
                                margin: '0 auto'
                            }}
                        />
                    </Box>
                </div>
            </StyledDrawer>

            <AccountPromptModal
                isOpen={modalOpen}
                onClose={handleCloseModal}
                onSubmit={handleAddCharacterSubmit}
                existingAccounts={existingAccounts}
                title="Add Character - Enter Account Name"
            />
        </>
    );
};

Header.propTypes = {
    loggedIn: PropTypes.bool.isRequired,
    handleLogout: PropTypes.func.isRequired,
    openSkillPlanModal: PropTypes.func.isRequired,
    existingAccounts: PropTypes.array.isRequired,
    onSilentRefresh: PropTypes.func,
    onAddCharacter: PropTypes.func.isRequired,
    isRefreshing: PropTypes.bool.isRequired
};

export default Header;

================
File: renderer/src/components/common/SubPageHeader.jsx
================
import React, { useState } from 'react';
import PropTypes from 'prop-types';
import { Typography, Box, Tooltip, IconButton } from '@mui/material';
import { Help as HelpFilledIcon, HelpOutline as HelpIcon } from '@mui/icons-material';

/**
 * A reusable page header that displays a title, optional instructions, and a toggle button
 * to show/hide those instructions.
 *
 * @param {string} title - The title text for the page
 * @param {string} instructions - The instructions text to display beneath the title when shown
 * @param {string} storageKey - A unique key to store the instructions visibility state in localStorage
 */
const SubPageHeader = ({ title, instructions, storageKey }) => {
    const [showInstructions, setShowInstructions] = useState(() => {
        const stored = localStorage.getItem(storageKey);
        return stored === null ? true : JSON.parse(stored);
    });

    const toggleInstructions = () => {
        const newValue = !showInstructions;
        setShowInstructions(newValue);
        localStorage.setItem(storageKey, JSON.stringify(newValue));
    };

    return (
        <Box className="max-w-7xl mx-auto mb-6">
            <Box className="bg-gradient-to-r from-gray-900 to-gray-800 p-4 rounded-md shadow-md relative">
                <Box display="flex" alignItems="center">
                    <Typography variant="h4" sx={{ color: '#14b8a6', fontWeight: 'bold', marginBottom: '0.5rem', flex: 1 }}>
                        {title}
                    </Typography>
                    {instructions && (
                        <Tooltip title={showInstructions ? "Hide instructions" : "Show instructions"}>
                            <IconButton
                                onClick={toggleInstructions}
                                sx={{ color: '#99f6e4' }}
                                size="small"
                            >
                                {showInstructions ? <HelpFilledIcon fontSize="small" /> : <HelpIcon fontSize="small" />}
                            </IconButton>
                        </Tooltip>
                    )}
                </Box>
                {instructions && showInstructions && (
                    <Typography variant="body2" sx={{ color: '#99f6e4', marginTop: '0.5rem' }}>
                        {instructions}
                    </Typography>
                )}
            </Box>
        </Box>
    );
};

SubPageHeader.propTypes = {
    title: PropTypes.string.isRequired,
    instructions: PropTypes.string,
    storageKey: PropTypes.string.isRequired,
};

export default SubPageHeader;

================
File: renderer/src/components/dashboard/AccountCard.jsx
================
import React, { useState } from 'react';
import PropTypes from 'prop-types';
import {
    IconButton,
    Menu,
    MenuItem,
    Tooltip,
} from '@mui/material';
import {
    MoreVert as MoreVertIcon,
    Visibility as VisibilityIcon,
    VisibilityOff as VisibilityOffIcon,
} from '@mui/icons-material';
import CharacterItem from './CharacterItem.jsx';

const AccountCard = ({
                         account,
                         onToggleAccountStatus,
                         onToggleAccountVisibility,
                         onUpdateAccountName,
                         onUpdateCharacter,
                         onRemoveCharacter,
                         onRemoveAccount,
                         roles,
                         skillConversions,
                     }) => {
    const [isEditingName, setIsEditingName] = useState(false);
    const [accountName, setAccountName] = useState(account.Name);

    const [anchorEl, setAnchorEl] = useState(null);
    const menuOpen = Boolean(anchorEl);

    const handleNameChange = (e) => setAccountName(e.target.value);

    const handleNameBlur = () => {
        if (accountName !== account.Name) {
            onUpdateAccountName(account.ID, accountName);
        }
        setIsEditingName(false);
    };

    const handleNameKeyDown = (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            e.target.blur();
        }
    };

    const startEditingName = () => {
        setIsEditingName(true);
    };

    const handleMenuClick = (event) => setAnchorEl(event.currentTarget);
    const handleMenuClose = () => setAnchorEl(null);

    const handleRemoveAccountClick = () => {
        handleMenuClose();
        onRemoveAccount(account.Name);
    };

    // IMPORTANT:
    // Make sure we pass the account.ID to the onToggleAccountVisibility callback.
    // If we just passed onToggleAccountVisibility, it wouldn't have the account ID.
    const handleVisibilityClick = () => {
        onToggleAccountVisibility(account.ID);
    };

    return (
        <div className="p-4 rounded-md shadow-md bg-gray-800 text-teal-200 max-w-sm">
            {/* Account Header */}
            <div className="flex justify-between items-center mb-4">
                {isEditingName ? (
                    <input
                        className="bg-transparent border-b border-teal-400 text-sm font-bold focus:outline-none"
                        value={accountName}
                        onChange={handleNameChange}
                        onBlur={handleNameBlur}
                        onKeyDown={handleNameKeyDown}
                        autoFocus
                    />
                ) : (
                    <span
                        className="text-sm font-bold cursor-pointer"
                        onClick={startEditingName}
                    >
            {account.Name}
          </span>
                )}

                <div className="flex items-center space-x-2">
                    <Tooltip title="Toggle Account Status (Alpha/Omega)">
                        <button
                            onClick={() => onToggleAccountStatus(account.ID)}
                            className="text-xl font-bold text-white"
                        >
                            {account.Status === 'Alpha' ? '' : ''}
                        </button>
                    </Tooltip>

                    {/* NEW: Icon-based visibility toggle */}
                    <Tooltip
                        title={account.Visible ? 'Hide Account' : 'Show Account'}
                    >
                        <IconButton
                            onClick={handleVisibilityClick}
                            // You can style color differently depending on whether it's visible or not
                            sx={{ color: account.Visible ? '#10b981' : '#6b7280' }}
                        >
                            {account.Visible ? <VisibilityIcon /> : <VisibilityOffIcon />}
                        </IconButton>
                    </Tooltip>

                    {/* Existing More Options menu */}
                    <IconButton
                        onClick={handleMenuClick}
                        size="small"
                        sx={{ color: '#9ca3af' }}
                        aria-label="more options"
                    >
                        <MoreVertIcon fontSize="inherit" />
                    </IconButton>

                    <Menu
                        anchorEl={anchorEl}
                        open={menuOpen}
                        onClose={handleMenuClose}
                        PaperProps={{
                            style: {
                                backgroundColor: '#1f2937',
                                color: '#14b8a6',
                            },
                        }}
                        anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
                        transformOrigin={{ vertical: 'top', horizontal: 'right' }}
                    >
                        <MenuItem onClick={handleRemoveAccountClick}>
                            Remove Account
                        </MenuItem>
                    </Menu>
                </div>
            </div>

            {/* Characters in Account */}
            <div className="space-y-2">
                {account.Characters.map((character) => (
                    <CharacterItem
                        key={character.Character.CharacterID}
                        character={character}
                        onUpdateCharacter={onUpdateCharacter}
                        onRemoveCharacter={onRemoveCharacter}
                        roles={roles}
                        skillConversions={skillConversions}
                    />
                ))}
            </div>
        </div>
    );
};

AccountCard.propTypes = {
    account: PropTypes.object.isRequired,
    onToggleAccountStatus: PropTypes.func.isRequired,
    onToggleAccountVisibility: PropTypes.func.isRequired,
    onUpdateAccountName: PropTypes.func.isRequired,
    onUpdateCharacter: PropTypes.func.isRequired,
    onRemoveCharacter: PropTypes.func.isRequired,
    onRemoveAccount: PropTypes.func.isRequired,
    roles: PropTypes.array.isRequired,
    skillConversions: PropTypes.object.isRequired,
};

export default AccountCard;

================
File: renderer/src/components/dashboard/AccountCard.test.jsx
================
import React from 'react';
import { render, screen } from '@testing-library/react';
import AccountCard from './AccountCard';

test('renders account name and status', () => {
    const mockAccount = {
        Name: 'TestAccount',
        Status: 'Omega',
        Characters: [
            {
                MCT: false,
                Role: 'Pvp',
                Training: 'Minmatar Dreadnought',
                Character: {
                    CharacterName: 'TestCharacter',
                    CharacterID: 123456, // A unique ID
                    CharacterSkillsResponse: { total_sp: 5000000 },
                    LocationName: 'Jita'
                }
            }
        ]
    };

    const mockConversions = {}

    render(
        <AccountCard
            account={mockAccount}
            onToggleAccountStatus={() => {}}
            onUpdateAccountName={() => {}}
            onUpdateCharacter={() => {}}
            onRemoveCharacter={() => {}}
            onRemoveAccount={() => {}}
            roles={[]}
            skillConversions={mockConversions}
        />
    );

    // Check account name
    expect(screen.getByText('TestAccount')).toBeInTheDocument();

    // Check character name inside account
    expect(screen.getByText('TestCharacter')).toBeInTheDocument();
});

================
File: renderer/src/components/dashboard/CharacterItem.jsx
================
import React, { useState, useEffect } from 'react';
import PropTypes from 'prop-types';
import { IconButton, Select, MenuItem, TextField, Tooltip } from '@mui/material';
import { Delete, Check as CheckIcon } from '@mui/icons-material';
import OpenInNewIcon from '@mui/icons-material/OpenInNew';
import CharacterDetailModal from "../common/CharacterDetailModal.jsx";
import { formatSP } from "../../utils/formatter.jsx";


const CharacterItem = ({
                           character,
                           onUpdateCharacter,
                           onRemoveCharacter = () => {},
                           roles,
                           hideRemoveIcon = false,
                           skillConversions,
                       }) => {
    const [role, setRole] = useState(character.Role || '');
    const [isAddingRole, setIsAddingRole] = useState(false);
    const [newRole, setNewRole] = useState('');

    const totalSp = character?.Character?.CharacterSkillsResponse?.total_sp;
    const formattedSP = totalSp ? formatSP(totalSp): '0';

    const [detailOpen, setDetailOpen] = useState(false);

    useEffect(() => {
        setRole(character.Role || '');
    }, [character.Role]);

    const rolesOptions = React.useMemo(() => {
        const combinedRoles = [...roles];
        if (role && !roles.includes(role) && role !== 'add_new_role') {
            combinedRoles.push(role);
        }
        return combinedRoles;
    }, [roles, role]);

    const handleRoleChange = (event) => {
        const selectedRole = event.target.value;
        if (selectedRole === 'add_new_role') {
            setIsAddingRole(true);
        } else {
            setRole(selectedRole);
            if (onUpdateCharacter && character.Character && character.Character.CharacterID) {
                onUpdateCharacter(character.Character.CharacterID, { Role: selectedRole });
            }
        }
    };

    const handleAddRole = () => {
        if (newRole.trim() !== '') {
            const trimmedRole = newRole.trim();
            setRole(trimmedRole);
            if (onUpdateCharacter && character.Character && character.Character.CharacterID) {
                onUpdateCharacter(character.Character.CharacterID, { Role: trimmedRole });
            }
            setIsAddingRole(false);
            setNewRole('');
        }
    };

    const zKillUrl = `https://zkillboard.com/character/${character.Character.CharacterID}/`;

    // MCT tooltip text
    const mctTooltip = character.MCT
        ? `Training: ${character?.Training || 'Unknown'}`
        : 'Skill queue paused';

    return (
        <div className="p-2 rounded-md shadow-sm bg-gray-700">
            <CharacterDetailModal
                open={detailOpen}
                onClose={() => setDetailOpen(false)}
                character={character}
                skillConversions={skillConversions}
            />
            <div className="flex justify-between items-center">
                <div className="flex items-center space-x-2">
                    <span className="font-semibold text-sm text-teal-200 cursor-pointer underline"
                        onClick={() => setDetailOpen(true)} >
                        {character.Character.CharacterName}
                    </span>
                    <Tooltip title="Total Skillpoints">
                        <span className="text-xs text-teal-400">
                            {formattedSP}
                        </span>
                    </Tooltip>
                    <Tooltip title="Open zKillboard">
                        <IconButton
                            aria-label="Open zKillboard"
                            size="small"
                            onClick={() => {
                                if (window.electronAPI && window.electronAPI.openExternal) {
                                    window.electronAPI.openExternal(zKillUrl);
                                } else {
                                    window.open(zKillUrl, '_blank', 'noopener,noreferrer');
                                }
                            }}
                            sx={{ color: '#99f6e4', '&:hover': { color: '#ffffff' } }}
                        >
                            <OpenInNewIcon fontSize="inherit" />
                        </IconButton>
                    </Tooltip>
                </div>

                <Tooltip title={mctTooltip}>
                    <div
                        data-testid="mct-indicator"
                        className={`w-3 h-3 rounded-full ${character.MCT ? 'bg-green-400' : 'bg-gray-400'}`}
                    ></div>
                </Tooltip>
            </div>

            {/* Second row */}
            <div className="mt-1 flex items-center justify-between">
                <div className="flex items-center space-x-2">
                    {/* Role */}
                    <div className="flex items-center">
                        <span className="text-xs text-teal-400 mr-1">Role:</span>
                        {isAddingRole ? (
                            <div className="flex items-center space-x-1">
                                <TextField
                                    size="small"
                                    value={newRole}
                                    onChange={(e) => setNewRole(e.target.value)}
                                    placeholder="Enter new role"
                                    sx={{ maxWidth: '100px' }}
                                    inputProps={{ style: { fontSize: '0.75rem' } }}
                                />
                                <IconButton aria-label="Confirm new role" onClick={handleAddRole} size="small">
                                    <CheckIcon fontSize="small" />
                                </IconButton>
                            </div>
                        ) : (
                            <Select
                                value={role}
                                onChange={handleRoleChange}
                                displayEmpty
                                size="small"
                                className="text-xs"
                                inputProps={{ 'aria-label': 'Role selection' }}
                                sx={{ fontSize: '0.75rem', maxWidth: '100px' }}
                            >
                                <MenuItem value="" disabled>
                                    Select Role
                                </MenuItem>
                                {rolesOptions.map((r) => (
                                    <MenuItem key={r} value={r} sx={{ fontSize: '0.75rem' }}>
                                        {r}
                                    </MenuItem>
                                ))}
                                <MenuItem value="add_new_role" sx={{ fontSize: '0.75rem' }}>Add New Role</MenuItem>
                            </Select>
                        )}
                    </div>
                    {/* Location */}
                    <div className="text-xs text-teal-400">
                        {character.Character.LocationName || 'Unknown'}
                    </div>
                </div>
                {/* Trash Can Icon */}
                {!hideRemoveIcon && (
                    <Tooltip title="Remove Character">
                        <IconButton
                            aria-label="Remove Character"
                            size="small"
                            onClick={() => onRemoveCharacter(character.Character.CharacterID)}
                            className="text-red-500"
                        >
                            <Delete fontSize="small" />
                        </IconButton>
                    </Tooltip>
                )}
            </div>
        </div>
    );
};

CharacterItem.propTypes = {
    character: PropTypes.object.isRequired,
    onUpdateCharacter: PropTypes.func.isRequired,
    onRemoveCharacter: PropTypes.func,
    roles: PropTypes.array.isRequired,
    hideRemoveIcon: PropTypes.bool,
    skillConversions: PropTypes.object.isRequired,
};

export default CharacterItem;

================
File: renderer/src/components/dashboard/CharacterItem.test.jsx
================
import React from 'react';
import { render, screen, act, fireEvent } from '@testing-library/react';
import CharacterItem from './CharacterItem';
import '@testing-library/jest-dom';
import userEvent from '@testing-library/user-event';

beforeEach(() => {
    window.electronAPI = { openExternal: vi.fn() };
});

afterEach(() => {
    delete window.electronAPI;
});

describe('CharacterItem', () => {
    const mockCharacter = {
        MCT: true,
        Role: 'Pvp',
        Training: 'Minmatar Dreadnought',
        Character: {
            CharacterName: 'TestCharacter',
            CharacterID: 123456,
            CharacterSkillsResponse: { total_sp: 5000000 },
            LocationName: 'Jita'
        }
    };

    const mockSkillConversions = {}

    const roles = ['Pvp', 'Logistics', 'Scout'];
    let mockOnUpdateCharacter;
    let mockOnRemoveCharacter;

    beforeEach(() => {
        mockOnUpdateCharacter = vi.fn();
        mockOnRemoveCharacter = vi.fn();
    });

    test('renders character name, total sp, and location', () => {
        render(
            <CharacterItem
                character={mockCharacter}
                onUpdateCharacter={mockOnUpdateCharacter}
                onRemoveCharacter={mockOnRemoveCharacter}
                roles={roles}
                skillConversions={mockSkillConversions}
            />
        );

        expect(screen.getByText('TestCharacter')).toBeInTheDocument();
        expect(screen.getByText('5M SP')).toBeInTheDocument();
        expect(screen.getByText('Jita')).toBeInTheDocument();
    });

    test('displays MCT tooltip', async () => {
        render(
            <CharacterItem
                character={mockCharacter}
                onUpdateCharacter={mockOnUpdateCharacter}
                onRemoveCharacter={mockOnRemoveCharacter}
                roles={roles}
                skillConversions={mockSkillConversions}
            />
        );

        const mctIndicator = screen.getByTestId('mct-indicator');

        // Wrap the hover action in act
        await act(async () => {
            await userEvent.hover(mctIndicator);
        });

        const tooltipText = await screen.findByText('Training: Minmatar Dreadnought');
        expect(tooltipText).toBeInTheDocument();
    });

    test('no remove icon if hideRemoveIcon is true', () => {
        render(
            <CharacterItem
                character={mockCharacter}
                onUpdateCharacter={mockOnUpdateCharacter}
                onRemoveCharacter={mockOnRemoveCharacter}
                roles={roles}
                hideRemoveIcon={true}
                skillConversions={mockSkillConversions}
            />
        );

        const removeBtn = screen.queryByLabelText('Remove Character');
        expect(removeBtn).not.toBeInTheDocument();
    });


});

================
File: renderer/src/components/dashboard/EditableAccountName.jsx
================
// EditableAccountName.jsx
import React, { useState } from 'react';
import PropTypes from 'prop-types';

const EditableAccountName = ({ accountID, accountName, onNameUpdate }) => {
    const [name, setName] = useState(accountName);
    const [isEditing, setIsEditing] = useState(false);

    const handleNameChange = (e) => {
        setName(e.target.value);
    };

    const handleBlur = () => {
        if (name !== accountName) {
            onNameUpdate(accountID, name);
        }
        setIsEditing(false);
    };

    const handleKeyDown = (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            handleBlur();
        }
    };

    return isEditing ? (
        <input
            type="text"
            value={name}
            onChange={handleNameChange}
            onBlur={handleBlur}
            onKeyDown={handleKeyDown}
            autoFocus
        />
    ) : (
        <span onClick={() => setIsEditing(true)}>{accountName}</span>
    );
};

EditableAccountName.propTypes = {
    accountID: PropTypes.number.isRequired,
    accountName: PropTypes.string.isRequired,
    onNameUpdate: PropTypes.func.isRequired,
};

export default EditableAccountName;

================
File: renderer/src/components/dashboard/GroupCard.jsx
================
// src/components/dashboard/GroupCard.jsx
import React from 'react';
import PropTypes from 'prop-types';
import CharacterItem from './CharacterItem.jsx';

const GroupCard = ({ groupName, characters, onUpdateCharacter, roles, skillConversions }) => {
    return (
        <div className="p-4 rounded-md shadow-md bg-gray-800 text-teal-200 max-w-sm">
            {/* Group Header */}
            <div className="flex justify-between items-center mb-4">
                <span className="text-sm font-bold">
                    {groupName}
                </span>
            </div>

            {/* Characters in this group */}
            <div className="space-y-2">
                {characters.map((character) => (
                    <CharacterItem
                        key={character.Character.CharacterID}
                        character={character}
                        onUpdateCharacter={onUpdateCharacter}
                        roles={roles}
                        hideRemoveIcon={true}
                        skillConversions={skillConversions}
                    />
                ))}
            </div>
        </div>
    );
};

GroupCard.propTypes = {
    groupName: PropTypes.string.isRequired,
    characters: PropTypes.array.isRequired,
    onUpdateCharacter: PropTypes.func.isRequired,
    roles: PropTypes.array.isRequired,
    skillConversions: PropTypes.object.isRequired,
};

export default GroupCard;

================
File: renderer/src/components/dashboard/GroupCard.test.jsx
================
// src/components/dashboard/GroupCard.test.jsx
import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import { vi } from 'vitest'; // Import vi from vitest
import GroupCard from './GroupCard';

describe('GroupCard', () => {
    const mockCharacters = [
        {
            MCT: false,
            Role: 'Pvp',
            Character: {
                CharacterName: 'CharacterOne',
                CharacterID: 1111,
                CharacterSkillsResponse: { total_sp: 2000000 },
                LocationName: 'Jita'
            }
        },
        {
            MCT: true,
            Role: 'Logistics',
            Character: {
                CharacterName: 'CharacterTwo',
                CharacterID: 2222,
                CharacterSkillsResponse: { total_sp: 4000000 },
                LocationName: 'Amarr'
            }
        }
    ];

    const roles = ['Pvp', 'Logistics'];
    const mockOnUpdateCharacter = vi.fn(); // Use vi.fn() instead of jest.fn()
    const mockConversions = {}

    test('renders the group name and its characters', () => {
        render(
            <GroupCard
                groupName="My Group"
                characters={mockCharacters}
                onUpdateCharacter={mockOnUpdateCharacter}
                roles={roles}
                skillConversions={mockConversions}
            />
        );

        // Check that the group name is displayed
        expect(screen.getByText('My Group')).toBeInTheDocument();

        // Check that each character name is displayed
        expect(screen.getByText('CharacterOne')).toBeInTheDocument();
        expect(screen.getByText('CharacterTwo')).toBeInTheDocument();

        // Confirm no remove buttons due to hideRemoveIcon = true
        expect(screen.queryByLabelText('Remove Character')).not.toBeInTheDocument();
    });
});

================
File: renderer/src/components/landing/LoginButton.jsx
================
// src/components/landing/LoginButton.jsx
import { useState } from 'react';
import { toast } from 'react-toastify';
import AccountPromptModal from '../common/AccountPromptModal.jsx';
import PropTypes from 'prop-types';
import eveSsoImage from '../../assets/images/eve-sso.jpg';
import { initiateLogin } from '../../api/apiService';
import { error as cError } from '../../utils/logger';
import { isDev } from '../../Config';

const LoginButton = ({ onModalOpenChange, logInCallBack }) => {
    const [modalOpen, setModalOpen] = useState(false);

    const handleOpenModal = () => {
        setModalOpen(true);
        onModalOpenChange(true);
    };

    const handleCloseModal = () => {
        setModalOpen(false);
        onModalOpenChange(false);
    };

    const handleLoginSubmit = async (account) => {
        try {
            const data = await initiateLogin(account);
            console.log('Login response data:', data);
            // Data should have {redirectURL, state} on success
            if (data && data.redirectURL && data.state) {
                logInCallBack(data.state);
                if (isDev) {
                    // In development, just redirect within Electron's internal browser
                    window.location.href = data.redirectURL;
                } else {
                    // In production, open system browser
                    window.electronAPI.openExternal(data.redirectURL);
                    toast.info("Please complete the login in your browser");
                }
            } else {
                toast.error("No redirect URL received from server.");
            }
        } catch (error) {
            cError('Error initiating login:', error);
            // Toast is handled by apiRequest if needed
        } finally {
            setModalOpen(false);
            onModalOpenChange(false);
        }
    };

    return (
        <>
            <button
                onClick={handleOpenModal}
                aria-label="Login with Eve SSO"
                className="inline-flex items-center py-3 px-6 rounded-md transition duration-300 hover:bg-teal-700 bg-teal-600 dark:bg-teal-500 dark:hover:bg-teal-600"
            >
                <img
                    src={eveSsoImage}
                    alt="Login with Eve SSO"
                    className="h-16 w-auto object-contain"
                />
            </button>
            <AccountPromptModal
                isOpen={modalOpen}
                onClose={handleCloseModal}
                onSubmit={handleLoginSubmit}
                title="Account Name"
            />
        </>
    );
};

LoginButton.propTypes = {
    onModalOpenChange: PropTypes.func.isRequired,
    logInCallBack: PropTypes.func.isRequired,
};

export default LoginButton;

================
File: renderer/src/components/mapping/MapAccountCard.jsx
================
// MapAccountCard.jsx
import React from 'react';
import PropTypes from 'prop-types';
import { Card, Typography, List, ListItem, ListItemText, IconButton, useTheme, Box } from '@mui/material';
import DeleteIcon from '@mui/icons-material/Delete';
import { formatDate } from '../../utils/formatter.jsx';

const AccountCard = ({ mapping, associations, handleUnassociate, handleDrop, mtimeToColor }) => {
    const theme = useTheme();
    const userId = mapping.userId;
    const userName = mapping.name || `Account ${userId}`;
    const associatedChars = associations.filter(assoc => assoc.userId === userId);

    const accountMtime = mapping.mtime || new Date().toISOString();
    const borderColor = mtimeToColor[accountMtime] || theme.palette.primary.main;

    return (
        <Card
            onDragOver={(e) => e.preventDefault()}
            onDrop={(e) => handleDrop(e, userId, userName)}
            sx={{
                marginBottom: 2,
                borderLeft: `4px solid ${borderColor}`,
                backgroundColor: theme.palette.background.paper,
                borderRadius: 2,
                paddingLeft: 2,
                cursor: 'pointer',
                boxShadow: 3, // Added shadow to the account card
                transition: 'background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out',
                '&:hover': {
                    backgroundColor: theme.palette.action.hover,
                    boxShadow: 4, // Increased shadow on hover
                },
            }}
        >
            <Typography variant="h6" color="text.primary" gutterBottom>
                {userName}
            </Typography>
            <Typography variant="body2" color="text.secondary" gutterBottom>
                {formatDate(accountMtime)}
            </Typography>
            <List>
                {associatedChars.map(assoc => (
                    <ListItem
                        key={`assoc-${assoc.charId}`}
                        secondaryAction={
                            <IconButton
                                edge="end"
                                aria-label={`Unassociate ${assoc.charName}`}
                                onClick={() => handleUnassociate(userId, assoc.charId, assoc.charName, userName)}
                                sx={{
                                    color: theme.palette.error.main, // Use error color for delete actions
                                }}
                            >
                                <DeleteIcon />
                            </IconButton>
                        }
                        sx={{
                            borderRadius: 1,
                            marginBottom: 1,
                            backgroundColor: theme.palette.background.default,
                            boxShadow: 1, // Subtle shadow around each associated character
                        }}
                    >
                        <ListItemText
                            primary={`${assoc.charName}`}
                            primaryTypographyProps={{ color: 'text.primary' }}
                        />
                    </ListItem>
                ))}
            </List>
        </Card>
    );
};

AccountCard.propTypes = {
    mapping: PropTypes.shape({
        userId: PropTypes.string.isRequired,
        name: PropTypes.string,
        mtime: PropTypes.string,
    }).isRequired,
    associations: PropTypes.arrayOf(
        PropTypes.shape({
            userId: PropTypes.string.isRequired,
            charId: PropTypes.string.isRequired,
            charName: PropTypes.string.isRequired,
            mtime: PropTypes.string,
        })
    ).isRequired,
    handleUnassociate: PropTypes.func.isRequired,
    handleDrop: PropTypes.func.isRequired,
    mtimeToColor: PropTypes.objectOf(PropTypes.string).isRequired,
};

export default AccountCard;

================
File: renderer/src/components/mapping/MapAccountCard.test.jsx
================
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { vi } from 'vitest';
import MapAccountCard from './MapAccountCard';
import '@testing-library/jest-dom';

vi.mock('../../utils/formatter.jsx', () => ({
    formatDate: (isoString) => 'Oct 5, 14:30', // Mocked fixed date formatting
}));

describe('MapAccountCard', () => {
    const mockHandleUnassociate = vi.fn();
    const mockHandleDrop = vi.fn();

    const mockMtimeToColor = {
        '2023-10-05T14:30:00Z': '#4caf50',
    };

    const mapping = {
        userId: 'user123',
        name: 'TestUser',
        mtime: '2023-10-05T14:30:00Z'
    };

    const associations = [
        { userId: 'user123', charId: 'char1', charName: 'Char One', mtime: '2023-10-05T12:00:00Z' },
        { userId: 'user123', charId: 'char2', charName: 'Char Two', mtime: '2023-10-05T13:00:00Z' },
    ];

    beforeEach(() => {
        mockHandleUnassociate.mockClear();
        mockHandleDrop.mockClear();
    });

    it('renders account name and formatted date', () => {
        render(
            <MapAccountCard
                mapping={mapping}
                associations={[]}
                handleUnassociate={mockHandleUnassociate}
                handleDrop={mockHandleDrop}
                mtimeToColor={mockMtimeToColor}
            />
        );

        // Check name
        expect(screen.getByText('TestUser')).toBeInTheDocument();
        // Since we mocked formatDate, it should show "Oct 5, 14:30"
        expect(screen.getByText('Oct 5, 14:30')).toBeInTheDocument();
    });

    it('displays associated characters and calls handleUnassociate on delete', () => {
        render(
            <MapAccountCard
                mapping={mapping}
                associations={associations}
                handleUnassociate={mockHandleUnassociate}
                handleDrop={mockHandleDrop}
                mtimeToColor={mockMtimeToColor}
            />
        );

        // Both characters should be listed
        expect(screen.getByText('Char One')).toBeInTheDocument();
        expect(screen.getByText('Char Two')).toBeInTheDocument();

        // Click the unassociate button for "Char One"
        const unassociateBtn = screen.getByRole('button', { name: 'Unassociate Char One' });
        fireEvent.click(unassociateBtn);

        expect(mockHandleUnassociate).toHaveBeenCalledWith('user123', 'char1', 'Char One', 'TestUser');
    });

});

================
File: renderer/src/components/mapping/MapCharacterCard.jsx
================
// CharacterCard.jsx
import React from 'react';
import PropTypes from 'prop-types';
import { Card, Typography, CardContent, useTheme } from '@mui/material';
import { formatDate } from '../../utils/formatter.jsx';

const CharacterCard = ({ char, handleDragStart, mtimeToColor }) => {
    const theme = useTheme();

    const borderColor = mtimeToColor[char.mtime] || theme.palette.secondary.main;

    // Format the date without the year and use 24-hour time
    const formattedDate = formatDate(char.mtime);

    return (
        <Card
            draggable
            onDragStart={(e) => handleDragStart(e, char.charId)}
            sx={{
                borderLeft: `4px solid ${borderColor}`,
                backgroundColor: theme.palette.background.paper,
                borderRadius: 2,
                cursor: 'grab',
                boxShadow: 3, // Added shadow
                transition: 'transform 0.2s ease-in-out',
                '&:hover': {
                    backgroundColor: theme.palette.action.hover,
                    transform: 'scale(1.02)',
                },
            }}
        >
            <CardContent>
                <Typography variant="h6" color="text.primary">
                    {char.name}
                </Typography>
                {/* Removed ID display */}
                <Typography variant="caption" color="text.secondary">
                    {formattedDate}
                </Typography>
            </CardContent>
        </Card>
    );
};

CharacterCard.propTypes = {
    char: PropTypes.shape({
        name: PropTypes.string.isRequired,
        charId: PropTypes.string.isRequired,
        mtime: PropTypes.string.isRequired,
    }).isRequired,
    handleDragStart: PropTypes.func.isRequired,
    mtimeToColor: PropTypes.objectOf(PropTypes.string).isRequired,
};

export default CharacterCard;

================
File: renderer/src/components/mapping/MapCharacterCard.test.jsx
================
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { vi } from 'vitest';
import CharacterCard from './MapCharacterCard';
import '@testing-library/jest-dom';

vi.mock('../../utils/formatter.jsx', () => ({
    formatDate: (isoString) => 'Oct 5, 14:30', // Mock a fixed date output
}));

describe('CharacterCard', () => {
    const mockHandleDragStart = vi.fn();
    const mockMtimeToColor = {
        '2023-10-05T14:30:00Z': '#4caf50',
    };

    const char = {
        name: 'Test Character',
        charId: 'char123',
        mtime: '2023-10-05T14:30:00Z'
    };

    beforeEach(() => {
        mockHandleDragStart.mockClear();
    });

    it('renders character name and formatted date', () => {
        render(
            <CharacterCard
                char={char}
                handleDragStart={mockHandleDragStart}
                mtimeToColor={mockMtimeToColor}
            />
        );

        expect(screen.getByText('Test Character')).toBeInTheDocument();
        expect(screen.getByText('Oct 5, 14:30')).toBeInTheDocument();
    });

    it('calls handleDragStart on drag start with charId', () => {
        render(
            <CharacterCard
                char={char}
                handleDragStart={mockHandleDragStart}
                mtimeToColor={mockMtimeToColor}
            />
        );

        const card = screen.getByText('Test Character').closest('div[draggable="true"]');
        fireEvent.dragStart(card);

        expect(mockHandleDragStart).toHaveBeenCalledWith(expect.any(Object), 'char123');
    });
});

================
File: renderer/src/components/skillplan/AddSkillPlanModal.jsx
================
import { useState } from 'react';
import PropTypes from 'prop-types';
import {
    Dialog,
    DialogTitle,
    DialogContent,
    DialogActions,
    TextField,
    Button,
    Typography
} from '@mui/material';

const AddSkillPlanModal = ({ onClose, onSave }) => {
    const [planName, setPlanName] = useState('');
    const [planContents, setPlanContents] = useState('');

    const handleSubmit = (e) => {
        e.preventDefault();
        onSave(planName.trim(), planContents.trim());
    };

    return (
        <Dialog open onClose={onClose} maxWidth="sm" fullWidth>
            <form onSubmit={handleSubmit}>
                <DialogTitle
                    className="bg-gradient-to-r from-gray-900 to-gray-800 text-teal-200 border-b border-gray-700"
                    sx={{ paddingY: '0.75rem' }}
                >
                    <Typography variant="h6" sx={{ fontWeight: 'bold' }}>
                        Add Skill Plan
                    </Typography>
                </DialogTitle>
                <DialogContent className="bg-gray-800">
                    <div className="space-y-4">
                        <TextField
                            label="Skill Plan Name"
                            placeholder="e.g. Battleship Mastery"
                            value={planName}
                            onChange={(e) => setPlanName(e.target.value)}
                            fullWidth
                            required
                            variant="filled"
                            InputProps={{
                                className: 'text-teal-200 bg-gray-700 rounded-md px-3 py-2',
                            }}
                            InputLabelProps={{
                                className: 'text-gray-300',
                            }}
                        />
                        <TextField
                            label="Skill Plan Contents"
                            placeholder="Enter skills and levels, e.g. 'Gunnery 5\nLarge Hybrid Turret 4'"
                            value={planContents}
                            onChange={(e) => setPlanContents(e.target.value)}
                            fullWidth
                            required
                            multiline
                            rows={5}
                            variant="filled"
                            InputProps={{
                                className: 'text-teal-200 bg-gray-700 rounded-md px-3 py-2',
                            }}
                            InputLabelProps={{
                                className: 'text-gray-300',
                            }}
                        />
                    </div>
                </DialogContent>
                <DialogActions className="bg-gray-800 border-t border-gray-700 flex items-center justify-end space-x-2 py-2 px-3">
                    <Button
                        onClick={onClose}
                        className="text-gray-200 hover:text-white normal-case"
                        sx={{ textTransform: 'none' }}
                    >
                        Cancel
                    </Button>
                    <Button
                        type="submit"
                        variant="contained"
                        sx={{
                            textTransform: 'none',
                            backgroundColor: '#14b8a6',
                            '&:hover': {
                                backgroundColor: '#0d9488',
                            },
                            color: '#ffffff',
                            fontWeight: 'bold'
                        }}
                    >
                        Save
                    </Button>
                </DialogActions>
            </form>
        </Dialog>
    );
};

AddSkillPlanModal.propTypes = {
    onClose: PropTypes.func.isRequired,
    onSave: PropTypes.func.isRequired,
};

export default AddSkillPlanModal;

================
File: renderer/src/components/skillplan/CharacterTable.jsx
================
// src/components/CharacterTable.jsx
import React, { useMemo, useState } from 'react';
import PropTypes from 'prop-types';
import {
    Table,
    TableBody,
    TableCell,
    TableContainer,
    TableHead,
    TableRow,
    Collapse,
    IconButton,
    Box,
    Tooltip
} from '@mui/material';
import {
    KeyboardArrowDown,
    KeyboardArrowUp
} from '@mui/icons-material';
import {
    CheckCircle,
    AccessTime,
    Error as ErrorIcon,
    ArrowUpward,
    ArrowDownward
} from '@mui/icons-material';
import { calculateDaysFromToday, formatNumberWithCommas } from '../../utils/formatter.jsx';
import CharacterDetailModal from '../common/CharacterDetailModal.jsx';

const generatePlanStatus = (planName, characterDetails) => {
    const qualified = characterDetails.QualifiedPlans?.[planName];
    const pending = characterDetails.PendingPlans?.[planName];
    const pendingFinishDate = characterDetails.PendingFinishDates?.[planName];
    const missingSkillsForPlan = characterDetails.MissingSkills?.[planName] || {};
    const missingCount = Object.keys(missingSkillsForPlan).length;

    let status = {
        statusIcon: null,
        statusText: ''
    };

    if (qualified) {
        status = {
            statusIcon: <CheckCircle style={{ color: 'green' }} fontSize="small" />,
            statusText: 'Qualified'
        };
    } else if (pending) {
        const daysRemaining = calculateDaysFromToday(pendingFinishDate);
        status = {
            statusIcon: <AccessTime style={{ color: 'orange' }} fontSize="small" />,
            statusText: `Pending ${daysRemaining ? `(${daysRemaining})` : ''}`
        };
    } else if (missingCount > 0) {
        status = {
            statusIcon: <ErrorIcon style={{ color: 'red' }} fontSize="small" />,
            statusText: `${missingCount} skills missing`
        };
    }

    return status;
};

const CharacterRow = ({ row, conversions }) => {
    const [open, setOpen] = useState(false);
    const [detailOpen, setDetailOpen] = useState(false);

    return (
        <React.Fragment>
            <CharacterDetailModal
                open={detailOpen}
                onClose={() => setDetailOpen(false)}
                character={row.fullCharacter}
                skillConversions={conversions}
            />
            <TableRow
                className="hover:bg-gray-700 transition-colors duration-200"
                sx={{
                    borderBottom:
                        row.plans.length === 0 ? '1px solid rgba(255,255,255,0.1)' : 'none'
                }}
            >
                <TableCell sx={{ width: '40px', paddingX: '0.5rem' }}>
                    {row.plans.length > 0 && (
                        <Tooltip title={open ? 'Collapse' : 'Expand'} arrow>
                            <IconButton
                                size="small"
                                onClick={() => setOpen(!open)}
                                sx={{ color: '#99f6e4', '&:hover': { color: '#ffffff' } }}
                            >
                                {open ? <KeyboardArrowUp /> : <KeyboardArrowDown />}
                            </IconButton>
                        </Tooltip>
                    )}
                </TableCell>
                <TableCell className="text-teal-200 font-semibold whitespace-nowrap px-2 py-2">
                    <img
                        src={`https://images.evetech.net/characters/${row.id}/portrait?size=32`}
                        alt={`${row.CharacterName}'s portrait`}
                        style={{
                            width: '24px',
                            height: '24px',
                            borderRadius: '50%',
                            verticalAlign: 'middle',
                            display: 'inline-block',
                            marginRight: '0.5rem'
                        }}
                    />
                    <span
                        style={{ verticalAlign: 'middle' }}
                        className="font-semibold text-sm text-teal-200 cursor-pointer underline"
                        onClick={() => setDetailOpen(true)}
                    >
                        {row.CharacterName}
                    </span>
                </TableCell>
                <TableCell className="whitespace-nowrap text-teal-100 px-2 py-2">
                    {row.TotalSP}
                </TableCell>
            </TableRow>
            {row.plans.length > 0 && (
                <TableRow>
                    <TableCell style={{ paddingBottom: 0, paddingTop: 0 }} colSpan={3}>
                        <Collapse in={open} timeout="auto" unmountOnExit>
                            <Box margin={1}>
                                <Table
                                    size="small"
                                    className="bg-gray-700 rounded-md overflow-hidden"
                                >
                                    <TableBody>
                                        {row.plans.map((plan) => (
                                            <TableRow
                                                key={plan.id}
                                                className="hover:bg-gray-600 transition-colors duration-200"
                                            >
                                                <TableCell className="pl-8 text-gray-300 flex items-center border-b border-gray-600 py-2">
                                                    {plan.statusIcon}
                                                    <span className="ml-2">
                                                         {plan.planName}
                                                    </span>
                                                </TableCell>
                                                <TableCell className="text-gray-300 border-b border-gray-600 py-2">
                                                    {plan.statusText}
                                                </TableCell>
                                                <TableCell className="border-b border-gray-600 py-2" />
                                            </TableRow>
                                        ))}
                                    </TableBody>
                                </Table>
                            </Box>
                        </Collapse>
                    </TableCell>
                </TableRow>
            )}
        </React.Fragment>
    );
};

CharacterRow.propTypes = {
    row: PropTypes.object.isRequired,
    conversions: PropTypes.object.isRequired
};

const CharacterTable = ({ characters, skillPlans, conversions }) => {
    // sortBy can be "name" or "sp"
    const [sortBy, setSortBy] = useState('sp');
    const [sortDirection, setSortDirection] = useState('asc');

    const handleSort = (column) => {
        // If we're already sorting by that column, flip direction
        // Otherwise, switch to that column with ascending direction
        if (sortBy === column) {
            setSortDirection((prev) => (prev === 'asc' ? 'desc' : 'asc'));
        } else {
            setSortBy(column);
            setSortDirection('asc');
        }
    };

    // Prepare the raw data
    const characterData = useMemo(() => {
        return characters.map((character) => {
            const characterDetails = character.Character || {};
            const totalSP = characterDetails.CharacterSkillsResponse?.total_sp || 0;
            const TotalSPFormatted = formatNumberWithCommas(totalSP);

            const plans = Object.keys(skillPlans).map((planName) => {
                const status = generatePlanStatus(planName, characterDetails);
                return {
                    id: `${characterDetails.CharacterID}-${planName}`,
                    planName,
                    statusIcon: status.statusIcon,
                    statusText: status.statusText
                };
            });

            return {
                id: characterDetails.CharacterID,
                CharacterName: characterDetails.CharacterName || '',
                rawSP: totalSP,
                TotalSP: TotalSPFormatted,
                plans,
                fullCharacter: character
            };
        });
    }, [characters, skillPlans]);

    // Sort the data based on sortBy & sortDirection
    const sortedData = useMemo(() => {
        const sorted = [...characterData];

        sorted.sort((a, b) => {
            if (sortBy === 'name') {
                // Compare by CharacterName (string)
                const nameA = a.CharacterName.toLowerCase();
                const nameB = b.CharacterName.toLowerCase();
                return nameA.localeCompare(nameB);
            } else {
                // sortBy === 'sp'
                // Compare by rawSP (numeric)
                return a.rawSP - b.rawSP;
            }
        });

        if (sortDirection === 'desc') {
            sorted.reverse();
        }

        return sorted;
    }, [characterData, sortBy, sortDirection]);

    return (
        <div className="mb-8 w-full">
            <TableContainer className="rounded-md border border-gray-700 overflow-hidden">
                <Table>
                    <TableHead>
                        <TableRow className="bg-gradient-to-r from-gray-900 to-gray-800">
                            {/* Expand/Collapse Column */}
                            <TableCell sx={{ width: '40px', paddingX: '0.5rem' }} />

                            {/* Character Name Column */}
                            <TableCell
                                onClick={() => handleSort('name')}
                                className="text-teal-200 font-bold uppercase py-2 px-2 text-sm cursor-pointer select-none"
                            >
                                Character Name
                                {sortBy === 'name' && (
                                    sortDirection === 'asc' ? (
                                        <ArrowUpward
                                            fontSize="small"
                                            style={{ marginLeft: 4, verticalAlign: 'middle' }}
                                        />
                                    ) : (
                                        <ArrowDownward
                                            fontSize="small"
                                            style={{ marginLeft: 4, verticalAlign: 'middle' }}
                                        />
                                    )
                                )}
                            </TableCell>

                            {/* Skill Points Column */}
                            <TableCell
                                onClick={() => handleSort('sp')}
                                className="text-teal-200 font-bold uppercase py-2 px-2 text-sm cursor-pointer select-none"
                            >
                                Total Skill Points
                                {sortBy === 'sp' && (
                                    sortDirection === 'asc' ? (
                                        <ArrowUpward
                                            fontSize="small"
                                            style={{ marginLeft: 4, verticalAlign: 'middle' }}
                                        />
                                    ) : (
                                        <ArrowDownward
                                            fontSize="small"
                                            style={{ marginLeft: 4, verticalAlign: 'middle' }}
                                        />
                                    )
                                )}
                            </TableCell>
                        </TableRow>
                    </TableHead>
                    <TableBody>
                        {sortedData.map((row) => (
                            <CharacterRow key={row.id} row={row} conversions={conversions} />
                        ))}
                    </TableBody>
                </Table>
            </TableContainer>
        </div>
    );
};

CharacterTable.propTypes = {
    characters: PropTypes.array.isRequired,
    skillPlans: PropTypes.object.isRequired,
    conversions: PropTypes.object.isRequired
};

export default CharacterTable;

================
File: renderer/src/components/skillplan/CharacterTable.test.jsx
================
// src/components/dashboard/CharacterTable.test.jsx
import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import userEvent from '@testing-library/user-event';
import { vi } from 'vitest';  // If you're using Vitest
import CharacterTable from './CharacterTable';

// Mock utility functions if needed
vi.mock('../../utils/formatter.jsx', () => ({
    calculateDaysFromToday: vi.fn(() => 5), // Returns a fixed number of days for simplicity
    formatNumberWithCommas: vi.fn((num) => num.toLocaleString()),
}));

describe('CharacterTable', () => {
    const mockCharacters = [
        {
            Character: {
                CharacterID: 1234,
                CharacterName: 'Test Character',
                CharacterSkillsResponse: {
                    total_sp: 1000000
                },
                QualifiedPlans: { "Plan A": true },
                PendingPlans: {},
                PendingFinishDates: {},
                MissingSkills: {}
            }
        }
    ];

    const mockSkillPlans = {
        "Plan A": {},
        "Plan B": {}
    };

    const mockConversions = {}

    test('renders character name and total skill points', () => {
        render(<CharacterTable characters={mockCharacters} skillPlans={mockSkillPlans} conversions={mockConversions} />);

        // Check if character name is present
        expect(screen.getByText('Test Character')).toBeInTheDocument();

        // Check if total skill points are formatted and displayed
        expect(screen.getByText('1,000,000')).toBeInTheDocument();

        // Both plans should create rows, but initially hidden under collapse
        // The expand/collapse icon should be visible since we have plans
        const toggleButton = screen.getByRole('button', { name: /expand/i });
        expect(toggleButton).toBeInTheDocument();
    });

    test('expands and collapses character plans', async () => {
        render(<CharacterTable characters={mockCharacters} skillPlans={mockSkillPlans} conversions={mockConversions} />);
        const user = userEvent.setup();

        // Initially, the plans are collapsed, and we only see the main row
        expect(screen.queryByText(' Plan A')).not.toBeInTheDocument();
        expect(screen.queryByText(' Plan B')).not.toBeInTheDocument();

        // Click the expand button
        const toggleButton = screen.getByRole('button', { name: /expand/i });
        await user.click(toggleButton);

        // Now we should see the plan rows
        expect(screen.getByText(' Plan A')).toBeInTheDocument();
        expect(screen.getByText(' Plan B')).toBeInTheDocument();

        // Click again to collapse
        await user.click(toggleButton);
        expect(screen.queryByText(' Plan A')).not.toBeInTheDocument();
        expect(screen.queryByText(' Plan B')).not.toBeInTheDocument();
    });
});

================
File: renderer/src/components/skillplan/SkillPlanTable.jsx
================
// SkillPlanTable.jsx
import React, { useMemo } from 'react';
import PropTypes from 'prop-types';
import {
    Table,
    TableBody,
    TableCell,
    TableContainer,
    TableHead,
    TableRow,
    Collapse,
    IconButton,
    Box,
    Tooltip
} from '@mui/material';
import {
    KeyboardArrowDown,
    KeyboardArrowUp,
    ContentCopy,
    Delete,
    CheckCircle,
    AccessTime,
    Error as ErrorIcon,
} from '@mui/icons-material';

import { calculateDaysFromToday } from "../../utils/formatter.jsx";

const SkillPlanRow = ({ row, conversions, contents, onCopySkillPlan, onDeleteSkillPlan }) => {
    const [open, setOpen] = React.useState(false);

    // Lookup typeID from conversions map
    const typeID = conversions[row.planName];
    const planIconUrl = typeID ? `https://images.evetech.net/types/${typeID}/icon` : null;

    return (
        <React.Fragment>
            <TableRow className="hover:bg-gray-700 transition-colors duration-200">
                <TableCell sx={{ width: '40px', paddingX: '0.5rem' }}>
                    {row.children.length > 0 && (
                        <Tooltip title={open ? "Collapse" : "Expand"} arrow>
                            <IconButton
                                size="small"
                                onClick={() => setOpen(!open)}
                                sx={{ color: '#99f6e4', '&:hover': { color: '#ffffff' } }}
                            >
                                {open ? <KeyboardArrowUp /> : <KeyboardArrowDown />}
                            </IconButton>
                        </Tooltip>
                    )}
                </TableCell>
                <TableCell className="text-teal-200 font-semibold whitespace-nowrap px-2 py-2">
                    {planIconUrl && (
                        <img
                            src={planIconUrl}
                            alt={`${row.planName} icon`}
                            style={{
                                width: '24px',
                                height: '24px',
                                borderRadius: '50%',
                                verticalAlign: 'middle',
                                display: 'inline-block',
                                marginRight: '0.5rem',
                            }}
                        />
                    )}
                    {row.planName}
                </TableCell>
                <TableCell className="whitespace-nowrap px-2 py-2">
                    <Tooltip title="Copy Skill Plan" arrow>
                        <IconButton
                            size="small"
                            onClick={() => onCopySkillPlan(row.planName, row.contents)}
                            sx={{ color: '#14b8a6', '&:hover': { color: '#ffffff' }, mr: 1 }}
                        >
                            <ContentCopy fontSize="small" />
                        </IconButton>
                    </Tooltip>
                    <Tooltip title="Delete Skill Plan" arrow>
                        <IconButton
                            size="small"
                            onClick={() => onDeleteSkillPlan(row.planName)}
                            sx={{ color: '#ef4444', '&:hover': { color: '#ffffff' } }}
                        >
                            <Delete fontSize="small" />
                        </IconButton>
                    </Tooltip>
                </TableCell>
            </TableRow>
            {row.children.length > 0 && (
                <TableRow>
                    <TableCell style={{ paddingBottom: 0, paddingTop: 0 }} colSpan={3}>
                        <Collapse in={open} timeout="auto" unmountOnExit>
                            <Box margin={1}>
                                <Table size="small" className="bg-gray-700 rounded-md overflow-hidden">
                                    <TableBody>
                                        {row.children.map((child) => (
                                            <TableRow
                                                key={child.id}
                                                className="hover:bg-gray-600 transition-colors duration-200"
                                            >
                                                <TableCell className="pl-8 text-gray-300 flex items-center border-b border-gray-600 py-2">
                                                    {child.statusIcon}
                                                    <span className="ml-2"> {child.characterName}</span>
                                                </TableCell>
                                                <TableCell className="text-gray-300 border-b border-gray-600 py-2">
                                                    {child.statusText}
                                                </TableCell>
                                                <TableCell className="border-b border-gray-600 py-2" />
                                            </TableRow>
                                        ))}
                                    </TableBody>
                                </Table>
                            </Box>
                        </Collapse>
                    </TableCell>
                </TableRow>
            )}
        </React.Fragment>
    );
};

SkillPlanRow.propTypes = {
    row: PropTypes.object.isRequired,
    conversions: PropTypes.object.isRequired,
    onCopySkillPlan: PropTypes.func.isRequired,
    onDeleteSkillPlan: PropTypes.func.isRequired,
};

const SkillPlanTable = ({ skillPlans, characters, conversions, onCopySkillPlan, onDeleteSkillPlan }) => {
    const skillPlanData = useMemo(() => {
        return Object.values(skillPlans).map((skillPlan) => {
            const qualifiedCharacters = skillPlan.QualifiedCharacters || [];
            const pendingCharacters = skillPlan.PendingCharacters || [];
            const missingCharacters = skillPlan.MissingCharacters || [];

            const children = [
                ...qualifiedCharacters.map((characterName) => ({
                    id: `${skillPlan.Name}-${characterName}`,
                    characterName,
                    statusIcon: <CheckCircle style={{ color: 'green' }} fontSize="small" />,
                    statusText: 'Qualified',
                })),
                ...pendingCharacters.map((characterName) => {
                    const character = characters.find(
                        (c) => c.Character?.CharacterName === characterName
                    );
                    const characterData = character?.Character || null;
                    const pendingFinishDate =
                        characterData?.PendingFinishDates?.[skillPlan.Name] || '';
                    const daysRemaining = calculateDaysFromToday(pendingFinishDate);
                    return {
                        id: `${skillPlan.Name}-${characterName}`,
                        characterName,
                        statusIcon: <AccessTime style={{ color: 'orange' }} fontSize="small" />,
                        statusText: `Pending ${daysRemaining ? `(${daysRemaining})` : ''}`,
                    };
                }),
                ...missingCharacters.map((characterName) => ({
                    id: `${skillPlan.Name}-${characterName}`,
                    characterName,
                    statusIcon: <ErrorIcon style={{ color: 'red' }} fontSize="small" />,
                    statusText: 'Missing',
                })),
            ];

            return {
                id: skillPlan.Name,
                planName: skillPlan.Name,
                contents: skillPlan.Skills,
                children,
            };
        });
    }, [skillPlans, characters]);

    return (
        <div className="mb-8 w-full">
            <TableContainer className="rounded-md border border-gray-700 overflow-hidden">
                <Table>
                    <TableHead>
                        <TableRow className="bg-gradient-to-r from-gray-900 to-gray-800">
                            <TableCell sx={{ width: '40px', paddingX: '0.5rem' }} />
                            <TableCell className="text-teal-200 font-bold uppercase py-2 px-2 text-sm">
                                Skill Plan
                            </TableCell>
                            <TableCell className="text-teal-200 font-bold uppercase py-2 px-2 text-sm">
                                Actions
                            </TableCell>
                        </TableRow>
                    </TableHead>
                    <TableBody>
                        {skillPlanData.map((row) => (
                            <SkillPlanRow key={row.id} row={row} conversions={conversions} contents={row.contents} onCopySkillPlan={onCopySkillPlan} onDeleteSkillPlan={onDeleteSkillPlan} />
                        ))}
                    </TableBody>
                </Table>
            </TableContainer>
        </div>
    );
};

SkillPlanTable.propTypes = {
    skillPlans: PropTypes.object.isRequired,
    characters: PropTypes.array.isRequired,
    conversions: PropTypes.object.isRequired,
    onCopySkillPlan: PropTypes.func.isRequired,
    onDeleteSkillPlan: PropTypes.func.isRequired,
};

export default SkillPlanTable;

================
File: renderer/src/components/skillplan/SkillPlanTable.test.jsx
================
// src/components/dashboard/SkillPlanTable.test.jsx
import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import userEvent from '@testing-library/user-event';
import { vi } from 'vitest'; // If using Vitest
import SkillPlanTable from './SkillPlanTable';

// Mocking the utility function
vi.mock('../../utils/formatter.jsx', () => ({
    calculateDaysFromToday: vi.fn(() => 3), // Always return 3 for simplicity
}));

describe('SkillPlanTable', () => {
    let user;

    beforeAll(() => {
        user = userEvent.setup();
    });

    beforeEach(() => {
        // Mock window functions
        window.copySkillPlan = vi.fn();
        window.deleteSkillPlan = vi.fn();
    });

    afterEach(() => {
        vi.resetAllMocks();
    });

    const mockSkillPlans = {
        "Plan A": {
            Name: "Plan A",
            QualifiedCharacters: ["CharacterOne"],
            PendingCharacters: ["CharacterTwo"],
            MissingCharacters: ["CharacterThree"],
            Skills: ["ABC"]
        },
        "Plan B": {
            Name: "Plan B",
            QualifiedCharacters: [],
            PendingCharacters: [],
            MissingCharacters: []
        }
    };

    const mockCharacters = [
        {
            Character: {
                CharacterName: "CharacterOne",
                PendingFinishDates: { "Plan A": "2025-12-31" }
            }
        },
        {
            Character: {
                CharacterName: "CharacterTwo",
                PendingFinishDates: { "Plan A": "2025-12-31" }
            }
        },
        {
            Character: {
                CharacterName: "CharacterThree",
                PendingFinishDates: {}
            }
        }
    ];

    const mockConversions =  {}
    const mockOnCopy = vi.fn();

    const mockOnDelete = vi.fn()


    test('renders skill plans and allows expansion', async () => {
        render(<SkillPlanTable skillPlans={mockSkillPlans} characters={mockCharacters}
                               conversions={mockConversions} onDeleteSkillPlan={mockOnDelete} onCopySkillPlan={mockOnCopy}/>);

        // Check if both plan names are rendered
        expect(screen.getByText('Plan A')).toBeInTheDocument();
        expect(screen.getByText('Plan B')).toBeInTheDocument();

        // Initially, children are collapsed
        expect(screen.queryByText(' CharacterOne')).not.toBeInTheDocument();

        // Expand Plan A
        const expandButton = screen.getByRole('button', { name: /expand/i });
        await user.click(expandButton);

        // Now the children should be visible
        expect(screen.getByText(' CharacterOne')).toBeInTheDocument();
        expect(screen.getByText(' CharacterTwo')).toBeInTheDocument();
        expect(screen.getByText(' CharacterThree')).toBeInTheDocument();
    });

    test('copy and delete skill plan actions', async () => {
        render(<SkillPlanTable skillPlans={mockSkillPlans} characters={mockCharacters} conversions={mockConversions}
        onDeleteSkillPlan={mockOnDelete} onCopySkillPlan={mockOnCopy}/>);
        const user = userEvent.setup();

        // For Plan A
        const planACopyButton = screen.getAllByRole('button', { name: /copy skill plan/i })[0];
        const planADeleteButton = screen.getAllByRole('button', { name: /delete skill plan/i })[0];

        await user.click(planACopyButton);
        expect(mockOnCopy).toHaveBeenCalledWith('Plan A', ['ABC']);
        
        await user.click(planADeleteButton);
        expect(mockOnDelete).toHaveBeenCalledWith('Plan A');
    });
});

================
File: renderer/src/components/sync/SubDirectoryCard.jsx
================
import React from 'react';
import PropTypes from 'prop-types';
import { Card, Typography, Divider, FormControl, InputLabel, Select, MenuItem, Grid, Tooltip } from '@mui/material';
import LoadingButton from '@mui/lab/LoadingButton';
import SyncIcon from '@mui/icons-material/Sync';
import SyncAllIcon from '@mui/icons-material/SyncAlt';

const SubDirectoryCard = ({
                              subDir,
                              selections,
                              handleSelectionChange,
                              handleSync,
                              handleSyncAll,
                              isLoading
                          }) => {
    const sortedUserFiles = [...subDir.availableUserFiles].sort((a, b) => a.name.localeCompare(b.name));
    const sortedCharFiles = [...subDir.availableCharFiles].sort((a, b) => a.name.localeCompare(b.name));

    const displaySubDir = subDir.profile.replace('settings_', '');
    const selectedCharId = selections[subDir.profile]?.charId || '';
    const selectedUserId = selections[subDir.profile]?.userId || '';

    return (
        <Card className="bg-gray-800 text-teal-200 p-4 rounded-md shadow-md flex flex-col justify-between h-full transform transition-transform duration-200 ease-in-out hover:scale-105 hover:shadow-lg">
            <div>
                <Typography
                    variant="h6"
                    gutterBottom
                    sx={{ textAlign: 'center', fontWeight: 700 }}
                >
                    {displaySubDir}
                </Typography>
                <Divider sx={{ my: 2, borderColor: 'rgba(255,255,255,0.2)' }} />
                <div className="p-2 rounded-md border border-gray-600 bg-gray-700 mb-2">
                    <FormControl fullWidth margin="normal">
                        <InputLabel id={`char-select-label-${subDir.profile}`} sx={{ color: '#99f6e4' }}>
                            Select Character
                        </InputLabel>
                        <Select
                            labelId={`char-select-label-${subDir.profile}`}
                            id={`char-select-${subDir.profile}`}
                            value={selectedCharId}
                            label="Select Character"
                            onChange={(e) => handleSelectionChange(subDir.profile, 'charId', e.target.value)}
                            sx={{
                                borderRadius: 1,
                                color: '#fff',
                                '& .MuiOutlinedInput-notchedOutline': {
                                    borderColor: 'rgba(255,255,255,0.2)',
                                },
                                '&:hover .MuiOutlinedInput-notchedOutline': {
                                    borderColor: '#ffffff',
                                },
                                '&.Mui-focused .MuiOutlinedInput-notchedOutline': {
                                    borderColor: '#ffffff',
                                },
                            }}
                        >
                            <MenuItem value="">
                                <em>-- Select Character --</em>
                            </MenuItem>
                            {sortedCharFiles.map(char => (
                                <MenuItem key={char.charId} value={char.charId}>
                                    {char.name}
                                </MenuItem>
                            ))}
                        </Select>
                    </FormControl>
                    <FormControl fullWidth margin="normal">
                        <InputLabel id={`user-select-label-${subDir.profile}`} sx={{ color: '#99f6e4' }}>
                            Select User
                        </InputLabel>
                        <Select
                            labelId={`user-select-label-${subDir.profile}`}
                            id={`user-select-${subDir.profile}`}
                            value={selectedUserId}
                            label="Select User"
                            onChange={(e) => handleSelectionChange(subDir.profile, 'userId', e.target.value)}
                            sx={{
                                borderRadius: 1,
                                color: '#fff',
                                '& .MuiOutlinedInput-notchedOutline': {
                                    borderColor: 'rgba(255,255,255,0.2)',
                                },
                                '&:hover .MuiOutlinedInput-notchedOutline': {
                                    borderColor: '#ffffff',
                                },
                                '&.Mui-focused .MuiOutlinedInput-notchedOutline': {
                                    borderColor: '#ffffff',
                                },
                            }}
                        >
                            <MenuItem value="">
                                <em>-- Select User --</em>
                            </MenuItem>
                            {sortedUserFiles.map(user => (
                                <MenuItem key={user.userId} value={user.userId}>
                                    {user.userId}
                                </MenuItem>
                            ))}
                        </Select>
                    </FormControl>
                </div>
            </div>
            <div>
                <Grid container spacing={2}>
                    <Grid item xs={6}>
                        <Tooltip title="Sync this specific profile">
                            <span style={{ width: '100%', display: 'block' }}>
                                <LoadingButton
                                    aria-label="Sync this specific profile"
                                    variant="contained"
                                    color="primary"
                                    onClick={() => handleSync(subDir.profile)}
                                    loading={isLoading}
                                    fullWidth
                                    disabled={isLoading || !selectedCharId || !selectedUserId}
                                    className="p-0"
                                >
                                    <SyncIcon fontSize="small" />
                                </LoadingButton>
                            </span>
                        </Tooltip>
                    </Grid>
                    <Grid item xs={6}>
                        <Tooltip title="Sync all profiles based on this selection">
                            <span style={{ width: '100%', display: 'block' }}>
                                <LoadingButton
                                    aria-label="Sync all profiles based on this selection"
                                    variant="contained"
                                    color="secondary"
                                    onClick={() => handleSyncAll(subDir.profile)}
                                    loading={isLoading}
                                    fullWidth
                                    disabled={isLoading || !selectedCharId || !selectedUserId}
                                    className="p-0"
                                >
                                    <SyncAllIcon fontSize="small" />
                                </LoadingButton>
                            </span>
                        </Tooltip>
                    </Grid>
                </Grid>
            </div>
        </Card>
    );
};

SubDirectoryCard.propTypes = {
    subDir: PropTypes.shape({
        profile: PropTypes.string.isRequired,
        availableCharFiles: PropTypes.array.isRequired,
        availableUserFiles: PropTypes.array.isRequired,
    }).isRequired,
    selections: PropTypes.object.isRequired,
    handleSelectionChange: PropTypes.func.isRequired,
    handleSync: PropTypes.func.isRequired,
    handleSyncAll: PropTypes.func.isRequired,
    isLoading: PropTypes.bool.isRequired,
};

export default SubDirectoryCard;

================
File: renderer/src/components/sync/SubDirectoryCard.test.jsx
================
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { vi } from 'vitest';
import SubDirectoryCard from './SubDirectoryCard';
import '@testing-library/jest-dom';

describe('SubDirectoryCard', () => {
    const mockHandleSelectionChange = vi.fn();
    const mockHandleSync = vi.fn();
    const mockHandleSyncAll = vi.fn();

    const subDir = {
        profile: 'settings_testProfile',
        availableCharFiles: [
            { charId: 'char1', name: 'Character One' },
            { charId: 'char2', name: 'Character Two' },
        ],
        availableUserFiles: [
            { userId: 'userA', name: 'User A' },
            { userId: 'userB', name: 'User B' },
        ]
    };

    const selections = {
        'settings_testProfile': {
            charId: '',
            userId: ''
        }
    };

    beforeEach(() => {
        mockHandleSelectionChange.mockClear();
        mockHandleSync.mockClear();
        mockHandleSyncAll.mockClear();
    });

    it('renders subdirectory name and dropdowns', () => {
        render(
            <SubDirectoryCard
                subDir={subDir}
                selections={selections}
                handleSelectionChange={mockHandleSelectionChange}
                handleSync={mockHandleSync}
                handleSyncAll={mockHandleSyncAll}
                isLoading={false}
            />
        );

        // displaySubDir = 'testProfile' after removing 'settings_'
        expect(screen.getByText('testProfile')).toBeInTheDocument();

        // Check character dropdown
        expect(screen.getByLabelText('Select Character')).toBeInTheDocument();
        // Check user dropdown
        expect(screen.getByLabelText('Select User')).toBeInTheDocument();
    });

    it('calls handleSelectionChange when user selects a character', () => {
        render(
            <SubDirectoryCard
                subDir={subDir}
                selections={selections}
                handleSelectionChange={mockHandleSelectionChange}
                handleSync={mockHandleSync}
                handleSyncAll={mockHandleSyncAll}
                isLoading={false}
            />
        );

        const charSelect = screen.getByLabelText('Select Character');
        fireEvent.mouseDown(charSelect); // Open the menu
        const charOption = screen.getByText('Character One');
        fireEvent.click(charOption);

        expect(mockHandleSelectionChange).toHaveBeenCalledWith('settings_testProfile', 'charId', 'char1');
    });

    it('calls handleSelectionChange when user selects a user', () => {
        render(
            <SubDirectoryCard
                subDir={subDir}
                selections={selections}
                handleSelectionChange={mockHandleSelectionChange}
                handleSync={mockHandleSync}
                handleSyncAll={mockHandleSyncAll}
                isLoading={false}
            />
        );

        const userSelect = screen.getByLabelText('Select User');
        fireEvent.mouseDown(userSelect);
        const userOption = screen.getByText('userA');
        fireEvent.click(userOption);

        expect(mockHandleSelectionChange).toHaveBeenCalledWith('settings_testProfile', 'userId', 'userA');
    });

    it('enables sync buttons only when both char and user are selected', () => {
        const updatedSelections = {
            'settings_testProfile': {
                charId: 'char1',
                userId: 'userA'
            }
        };

        render(
            <SubDirectoryCard
                subDir={subDir}
                selections={updatedSelections}
                handleSelectionChange={mockHandleSelectionChange}
                handleSync={mockHandleSync}
                handleSyncAll={mockHandleSyncAll}
                isLoading={false}
            />
        );

        // Now both should be enabled
        const syncButton = screen.getByRole('button', { name: /sync this specific profile/i });
        const syncAllButton = screen.getByRole('button', { name: /sync all profiles/i });
        expect(syncButton).toBeEnabled();
        expect(syncAllButton).toBeEnabled();

        // Click sync button
        fireEvent.click(syncButton);
        expect(mockHandleSync).toHaveBeenCalledWith('settings_testProfile');

        // Click sync all button
        fireEvent.click(syncAllButton);
        expect(mockHandleSyncAll).toHaveBeenCalledWith('settings_testProfile');
    });

    it('disables sync buttons if either char or user is not selected', () => {
        const partialSelections = {
            'settings_testProfile': {
                charId: 'char1',
                userId: '' // user not selected
            }
        };

        render(
            <SubDirectoryCard
                subDir={subDir}
                selections={partialSelections}
                handleSelectionChange={mockHandleSelectionChange}
                handleSync={mockHandleSync}
                handleSyncAll={mockHandleSyncAll}
                isLoading={false}
            />
        );

        const syncButton = screen.getByRole('button', { name: /sync this specific profile/i });
        const syncAllButton = screen.getByRole('button', { name: /sync all profiles/i });

        expect(syncButton).toBeDisabled();
        expect(syncAllButton).toBeDisabled();
    });

    it('shows loading state on sync buttons when isLoading is true', () => {
        const updatedSelections = {
            'settings_testProfile': {
                charId: 'char1',
                userId: 'userA'
            }
        };

        render(
            <SubDirectoryCard
                subDir={subDir}
                selections={updatedSelections}
                handleSelectionChange={mockHandleSelectionChange}
                handleSync={mockHandleSync}
                handleSyncAll={mockHandleSyncAll}
                isLoading={true}
            />
        );

        const syncButton = screen.getByRole('button', { name: /sync this specific profile/i });
        expect(syncButton).toBeDisabled(); // loading state also disables
    });
});

================
File: renderer/src/components/sync/SyncActionsBar.jsx
================
import React from 'react';
import PropTypes from 'prop-types';
import { Button, Tooltip } from '@mui/material';
import BackupIcon from '@mui/icons-material/Backup';
import FolderOpenIcon from '@mui/icons-material/FolderOpen';
import UndoIcon from '@mui/icons-material/Undo';

const SyncActionsBar = ({
                            handleBackup,
                            handleChooseSettingsDir,
                            handleResetToDefault,
                            isDefaultDir,
                            isLoading
                        }) => {
    return (
        <div className="mb-4 flex justify-center space-x-2">
            <Tooltip title="Backup Settings">
                <span>
                    <Button
                        aria-label="Backup Settings"
                        variant="contained"
                        color="primary"
                        onClick={handleBackup}
                        disabled={isLoading}
                        className="w-10 h-10 p-0 flex items-center justify-center"
                    >
                        <BackupIcon fontSize="small" />
                    </Button>
                </span>
            </Tooltip>
            <Tooltip title="Choose Settings Directory">
                <span>
                    <Button
                        aria-label="Choose Settings Directory"
                        variant="contained"
                        color="info"
                        onClick={handleChooseSettingsDir}
                        disabled={isLoading}
                        className="w-10 h-10 p-0 flex items-center justify-center"
                    >
                        <FolderOpenIcon fontSize="small" />
                    </Button>
                </span>
            </Tooltip>
            {!isDefaultDir && (
                <Tooltip title="Reset to Default Directory">
                    <span>
                        <Button
                            aria-label="Reset to Default Directory"
                            variant="contained"
                            color="warning"
                            onClick={handleResetToDefault}
                            disabled={isLoading}
                            className="w-10 h-10 p-0 flex items-center justify-center"
                        >
                            <UndoIcon fontSize="small" />
                        </Button>
                    </span>
                </Tooltip>
            )}
        </div>
    );
};

SyncActionsBar.propTypes = {
    handleBackup: PropTypes.func.isRequired,
    handleChooseSettingsDir: PropTypes.func.isRequired,
    handleResetToDefault: PropTypes.func.isRequired,
    isDefaultDir: PropTypes.bool.isRequired,
    isLoading: PropTypes.bool.isRequired,
};

export default SyncActionsBar;

================
File: renderer/src/hooks/useAddCharacterCallback.jsx
================
// src/hooks/useAddCharacterCallback.js
import { useCallback } from 'react';
import { log } from '../utils/logger.jsx';
import { finalizelogin } from '../api/apiService.jsx';
import { useOAuthPoll } from './useOAuthPoll.jsx';

/**
 * Custom hook to finalize the "Add Character" flow via OAuth polling.
 *
 * @param {Function} loginRefresh - Function to fetch updated user data (including the newly added character).
 * @returns {Function} startAddCharacterPoll
 */
export function useAddCharacterCallback(loginRefresh) {
    // 1) Provide finalizeFn
    const finalizeFn = useCallback(async (state) => {
        log('Calling finalizelogin for add-character... state:', state);
        return finalizelogin(state); // should return { success: boolean }
    }, []);

    // 2) Provide afterFinalize
    const afterFinalize = useCallback(async () => {
        log('Finalization complete; now fetching updated data...');
        await loginRefresh();
    }, [loginRefresh]);

    // 3) Use the common hook
    const { startPoll, pollingActive, pollingState } = useOAuthPoll(
        finalizeFn,
        afterFinalize,
        5,      // maxAttempts
        5000    // intervalMs
    );

    // Return just the startPoll function that we name "startAddCharacterPoll"
    return startPoll;
}

================
File: renderer/src/hooks/useAppHandlers.jsx
================
import {useCallback} from 'react';
import { log } from '../utils/logger';
import {
    removeCharacterFromAppData,
    updateCharacterInAppData,
    toggleAccountStatusInAppData,
    updateAccountNameInAppData,
    removeAccountFromAppData, removePlanFromSkillPlans, toggleAccountVisibilityInAppData
} from '../utils/appDataTransforms';
import {isDev} from '../Config';


import {
    logout,
    toggleAccountStatus as toggleAccountStatusApi,
    updateCharacter as updateCharacterApi,
    removeCharacter as removeCharacterApi,
    updateAccountName as updateAccountNameApi,
    removeAccount as removeAccountApi,
    addCharacter as addCharacterApi,
    saveSkillPlan as saveSkillPlanApi,
    deleteSkillPlan as deleteSkillPlanApi, toggleAccountVisibility,
} from '../api/apiService.jsx';
import {toast} from "react-toastify";
import {useLoginCallback} from "./useLoginCallback.jsx";
import {useAddCharacterCallback} from "./useAddCharacterCallback.jsx";

/**
 * Custom hook that encapsulates all the handler functions used in App.
 * @param {Function} setAppData - Setter for the appData state.
 * @param {Function} fetchData - Function to re-fetch data after certain operations.
 * @param {Function} setIsAuthenticated - Setter for isAuthenticated state.
 * @param {Function} setLoggedOut - Setter for loggedOut state.
 * @param {Function} setIsSkillPlanModalOpen - Setter for isSkillPlanModalOpen state.
 * @param isAuthenticated
 * @param loggedOut
 * @param loginRefresh
 * @returns {Object} Handlers object.
 */
export function useAppHandlers({
                                   setAppData,
                                   fetchData,
                                   setIsAuthenticated,
                                   setLoggedOut,
                                   setIsSkillPlanModalOpen,
                                   isAuthenticated,
                                   loggedOut,
                                   loginRefresh,
                               }) {

    const logInCallBack = useLoginCallback(
        isAuthenticated,
        loggedOut,
        loginRefresh,
        setLoggedOut,
        setIsAuthenticated
    );

    const addCharacterCallback = useAddCharacterCallback(fetchData);

    const handleLogout = useCallback(async () => {
        log("handleLogout called");
        const result = await logout();
        if (result && result.success) {
            setIsAuthenticated(false);
            setAppData(null);
            setLoggedOut(true);
        }
    }, [setIsAuthenticated, setAppData, setLoggedOut]);

    const handleToggleAccountStatus = useCallback(async (accountID) => {
        log("handleToggleAccountStatus called:", accountID);
        const result = await toggleAccountStatusApi(accountID);
        if (result && result.success) {
            setAppData((prev) => toggleAccountStatusInAppData(prev, accountID));
        }
    }, [setAppData]);

    const handleToggleAccountVisibility = useCallback(async (accountID) => {
        log("handleToggleAccountVisibility called:", accountID);
        const result = await toggleAccountVisibility(accountID);
        if (result && result.success) {
            setAppData((prev) => toggleAccountVisibilityInAppData(prev, accountID));
        }
    }, [setAppData]);

    const handleUpdateCharacter = useCallback(async (characterID, updates) => {
        log("handleUpdateCharacter called with characterID:", characterID, "updates:", updates);
        const result = await updateCharacterApi(characterID, updates);
        if (result && result.success) {
            setAppData((prev) => updateCharacterInAppData(prev, characterID, updates));
        }
    }, [setAppData]);

    const handleRemoveCharacter = useCallback(async (characterID) => {
        log("handleRemoveCharacter called with characterID:", characterID);
        const result = await removeCharacterApi(characterID);
        if (result && result.success) {
            setAppData((prev) => removeCharacterFromAppData(prev, characterID));
        }
    }, [setAppData]);

    const handleUpdateAccountName = useCallback(async (accountID, newName) => {
        log("handleUpdateAccountName:", { accountID, newName });
        const result = await updateAccountNameApi(accountID, newName);
        if (result && result.success) {
            setAppData((prev) => updateAccountNameInAppData(prev, accountID, newName));
        }
    }, [setAppData]);

    const handleRemoveAccount = useCallback(async (accountName) => {
        log("handleRemoveAccount called with accountName:", accountName);
        const result = await removeAccountApi(accountName);
        if (result && result.success) {
            setAppData((prev) => removeAccountFromAppData(prev, accountName));
        }
    }, [setAppData]);

    // 2) The handleAddCharacter that calls the API, opens external link, and calls the new callback
    const handleAddCharacter = useCallback(async (account) => {
        log("handleAddCharacter called with account:", account);

        const data = await addCharacterApi(account);

        // Open the external URL if present
        if (data?.redirectURL) {
            if (isDev) {
                window.location.href = data.redirectURL;
            } else if (window.electronAPI?.openExternal) {
                window.electronAPI.openExternal(data.redirectURL);
            }
        }

        console.log(data)

        // Start polling to finalize
        if (data?.state) {
            log("Starting addCharacterCallback with state:", data.state);
            addCharacterCallback(data.state);
        }
        // No need to rely on isAuthenticated => user is already logged in
    }, [addCharacterCallback]);


    const handleSaveSkillPlan = useCallback(async (planName, planContents) => {
        log("handleSaveSkillPlan called with planName:", planName);
        const result = await saveSkillPlanApi(planName, planContents);
        if (result && result.success) {
            setIsSkillPlanModalOpen(false);
            fetchData();
        }
    }, [setIsSkillPlanModalOpen, fetchData]);

    const handleDeleteSkillPlan = useCallback(async (planName) => {
        log("handleDeleteSkillPlan called with planName:", planName);
        const result = await deleteSkillPlanApi(planName);
        console.log(result)
        if (result && result.success) {
            toast.success(`Deleted skill plan: ${planName}`, { autoClose: 1500 });
            setAppData((prev) => removePlanFromSkillPlans(prev, planName));
        }
    }, [fetchData]);

    const handleCopySkillPlan = useCallback(async (planName, skills) => {
        log("handleCopySkillPlan called with planName:", planName);
        if (!planName) {
            console.error(`Skill plan not found: ${planName}`);
            toast.warning(`Skill plan not found: ${planName}`, { autoClose: 1500 });
            return;
        }

        if (Object.keys(skills).length === 0) {
            console.warn(`No skills available to copy in the plan: ${planName}`);
            toast.warning(`No skills available to copy in the plan: ${planName}.`, {
                autoClose: 1500,
            });
            return;
        }

        const skillText = Object.entries(skills)
            .map(([skill, detail]) => `${skill} ${detail.Level}`)
            .join('\n');

        navigator.clipboard
            .writeText(skillText)
            .then(() => {
                toast.success(`Copied ${Object.keys(skills).length} skills from ${planName}.`, {
                    autoClose: 1500,
                });
            })
            .catch((err) => {
                console.error('Copy to clipboard failed:', err);
                toast.error('Failed to copy skill plan.', { autoClose: 1500 });
            });
    },[fetchData]);

    return {
        handleLogout,
        handleToggleAccountStatus,
        handleUpdateCharacter,
        handleRemoveCharacter,
        handleUpdateAccountName,
        handleRemoveAccount,
        handleAddCharacter,
        handleSaveSkillPlan,
        handleDeleteSkillPlan,
        handleCopySkillPlan,
        handleToggleAccountVisibility,
    };
}

================
File: renderer/src/hooks/useConfirmDialog.jsx
================
// useConfirmDialog.js
import { useState } from 'react';
import CustomConfirmDialog from '../components/common/CustomConfirmDialog.jsx';

export const useConfirmDialog = () => {
    const [confirmDialogOptions, setConfirmDialogOptions] = useState({
        open: false,
        title: '',
        message: '',
        resolve: null
    });

    const showConfirmDialog = ({ title, message }) => {
        return new Promise((resolve) => {
            setConfirmDialogOptions({
                open: true,
                title,
                message,
                resolve
            });
        });
    };

    const handleConfirm = () => {
        confirmDialogOptions.resolve({ isConfirmed: true });
        setConfirmDialogOptions((prev) => ({ ...prev, open: false }));
    };

    const handleCancel = () => {
        confirmDialogOptions.resolve({ isConfirmed: false });
        setConfirmDialogOptions((prev) => ({ ...prev, open: false }));
    };

    const confirmDialog = (
        <CustomConfirmDialog
            open={confirmDialogOptions.open}
            title={confirmDialogOptions.title}
            message={confirmDialogOptions.message}
            onConfirm={handleConfirm}
            onCancel={handleCancel}
        />
    );

    return [showConfirmDialog, confirmDialog];
};

================
File: renderer/src/hooks/useLoginCallback.jsx
================
// src/hooks/useLoginCallback.js
import { useCallback, useState } from 'react';
import { log } from "../utils/logger.jsx";
import { finalizelogin } from "../api/apiService.jsx";
import { useOAuthPoll } from "./useOAuthPoll";

/**
 * Custom hook to handle login callback logic via polling.
 *
 * @param {boolean} isAuthenticated    - Whether the user is currently authenticated.
 * @param {Function} loginRefresh      - Function to fetch user data after finalization.
 * @param {Function} setLoggedOut      - Setter for loggedOut state.
 * @param {Function} setIsAuthenticated - Setter for isAuthenticated state.
 * @returns {Function} startPoll
 */
export function useLoginCallback(
    isAuthenticated,
    loginRefresh,
    setLoggedOut,
    setIsAuthenticated
) {
    // We'll define the same pattern: a finalizeFn + afterFinalize

    const finalizeFn = useCallback(async (state) => {
        // If user is already authenticated, skip?
        if (isAuthenticated) {
            log("User already isAuthenticated; skip finalizing");
            return { success: true };
        }

        log("Calling finalize-login endpoint...", state);
        const resp = await finalizelogin(state);

        // Must return { success: true/false } format
        if (resp && resp.success) {
            return { success: true };
        }
        return { success: false };
    }, [isAuthenticated]);

    const afterFinalize = useCallback(async () => {
        // Once finalization is done, do loginRefresh
        log("Login finalization succeeded; calling loginRefresh...");
        await loginRefresh();
        // Then setIsAuthenticated
        setIsAuthenticated(true);
    }, [loginRefresh, setIsAuthenticated]);

    // Use the common hook
    const { startPoll, pollingActive } = useOAuthPoll(
        finalizeFn,
        afterFinalize,
        25,     // e.g. maxAttempts
        5000    // interval
    );

    // The original code also called setLoggedOut(false) when starting
     return useCallback((state) => {
        log("useLoginCallback -> startPoll called with state:", state);
        setLoggedOut(false);
        startPoll(state); // from the shared hook
    }, [setLoggedOut, startPoll]);
}

================
File: renderer/src/hooks/useOAuthPoll.jsx
================
// src/hooks/useOAuthPoll.js
import { useState, useEffect, useCallback, useRef } from 'react';
import { log } from '../utils/logger.jsx';

/**
 * Generic hook to handle OAuth polling logic.
 *
 * @param {Function} finalizeFn     - Function that tries to finalize OAuth. Should return { success: true } on success.
 * @param {Function} afterFinalize  - Function to call once finalize is successful (like loginRefresh).
 * @param {number}   maxAttempts    - Maximum polling attempts before giving up.
 * @param {number}   intervalMs     - Interval in milliseconds between polls.
 * @returns {Object} {
 *   startPoll: (stateString) => void,
 *   pollingActive: boolean,
 *   pollingState: string | null,
 * }
 */
export function useOAuthPoll(
    finalizeFn,
    afterFinalize,
    maxAttempts = 5,
    intervalMs = 5000
) {
    const [pollingActive, setPollingActive] = useState(false);
    const [pollingState, setPollingState] = useState(null);

    // Track if we've already finalized
    const finalizedRef = useRef(false);

    useEffect(() => {
        if (!pollingActive || !pollingState) return;

        log(`useOAuthPoll: starting for state=${pollingState}`);
        let attempts = 0;

        const intervalId = setInterval(async () => {
            attempts++;
            log(`OAuth polling attempt #${attempts}, finalized=${finalizedRef.current}`);

            // If we exceed max attempts, give up
            if (attempts > maxAttempts) {
                console.warn('Gave up after multiple attempts. Clearing interval.');
                clearInterval(intervalId);
                setPollingActive(false);
                // Optionally call one last afterFinalize
                await afterFinalize();
                return;
            }

            if (!finalizedRef.current) {
                // Try to finalize
                const resp = await finalizeFn(pollingState);
                if (resp && resp.success) {
                    finalizedRef.current = true;
                    log('Finalization success. Running afterFinalize, then stopping polling...');
                    await afterFinalize();
                    clearInterval(intervalId);
                    setPollingActive(false);
                } else {
                    log('Not ready yet, continuing to poll finalizeFn...');
                }
            } else {
                // Already finalized => do one last afterFinalize
                log('Already finalized, calling afterFinalize, then stopping...');
                await afterFinalize();
                clearInterval(intervalId);
                setPollingActive(false);
            }
        }, intervalMs);

        return () => {
            clearInterval(intervalId);
        };
    }, [pollingActive, pollingState, finalizeFn, afterFinalize, maxAttempts, intervalMs]);

    // Function to start the polling from scratch
    const startPoll = useCallback(
        (oauthState) => {
            log('useOAuthPoll -> startPoll called with oauthState:', oauthState);
            finalizedRef.current = false; // reset
            setPollingState(oauthState);
            setPollingActive(true);
        },
        []
    );

    return { startPoll, pollingActive, pollingState };
}

================
File: renderer/src/pages/CharacterOverview.jsx
================
// src/pages/CharacterOverview.jsx

import PropTypes from 'prop-types';
import React, { useState, useMemo } from 'react';
import AccountCard from '../components/dashboard/AccountCard.jsx';
import GroupCard from '../components/dashboard/GroupCard.jsx';
import {
    Typography,
    Box,
    Tooltip,
    ToggleButtonGroup,
    ToggleButton,
    IconButton,
} from '@mui/material';
import {
    ArrowUpward,
    ArrowDownward,
    AccountBalance,
    AccountCircle,
    Place,
    Visibility as VisibilityIcon,
    VisibilityOff as VisibilityOffIcon,
} from '@mui/icons-material';
import { overviewInstructions } from '../utils/instructions.jsx';
import PageHeader from '../components/common/SubPageHeader.jsx';

const CharacterOverview = ({
                               accounts,
                               onToggleAccountStatus,
                               onUpdateCharacter,
                               onUpdateAccountName,
                               onRemoveCharacter,
                               onRemoveAccount,
                               roles,
                               skillConversions,
                               onToggleAccountVisibility,
                           }) => {
    const [view, setView] = useState('account');
    const [sortOrder, setSortOrder] = useState('asc');
    const [showHiddenAccounts, setShowHiddenAccounts] = useState(false);

    const toggleSortOrder = () => {
        setSortOrder((prev) => (prev === 'asc' ? 'desc' : 'asc'));
    };

    // 1. Filter + sort the accounts for "account" view
    const filteredAndSortedAccounts = useMemo(() => {
        if (!accounts) return [];

        const accountsCopy = [...accounts];
        // Sort accounts by Name
        accountsCopy.sort((a, b) => {
            const nameA = a.Name || 'Unknown Account';
            const nameB = b.Name || 'Unknown Account';
            return sortOrder === 'asc'
                ? nameA.localeCompare(nameB)
                : nameB.localeCompare(nameA);
        });

        // Hide them if showHiddenAccounts is false
        if (!showHiddenAccounts) {
            return accountsCopy.filter((acct) => acct.Visible !== false);
        }

        return accountsCopy;
    }, [accounts, sortOrder, showHiddenAccounts]);

    // 2. Build "allCharacters" for role/location grouping
    //    Skip hidden accounts if showHiddenAccounts === false
    const allCharacters = useMemo(() => {
        let chars = [];
        (accounts || []).forEach((account) => {
            if (!showHiddenAccounts && account.Visible === false) {
                return;
            }
            const accountName = account.Name || 'Unknown Account';

            chars = chars.concat(
                (account.Characters || []).map((char) => ({
                    ...char,
                    accountName,
                    Role: char.Role || '',
                    MCT: typeof char.MCT === 'boolean' ? char.MCT : false,
                }))
            );
        });
        return chars;
    }, [accounts, showHiddenAccounts]);

    // 3. Build the role map
    const roleMap = useMemo(() => {
        const map = { Unassigned: [] };
        roles.forEach((r) => {
            map[r] = [];
        });
        allCharacters.forEach((character) => {
            const charRole = character.Role || 'Unassigned';
            if (!map[charRole]) {
                map[charRole] = [];
            }
            map[charRole].push(character);
        });
        return map;
    }, [allCharacters, roles]);

    // 4. Build the location map
    const locationMap = useMemo(() => {
        const map = {};
        allCharacters.forEach((character) => {
            // Be sure character.Character exists
            const location = character.Character?.LocationName || 'Unknown Location';
            if (!map[location]) {
                map[location] = [];
            }
            map[location].push(character);
        });
        return map;
    }, [allCharacters]);

    // Decide which map to display if user selects 'role' or 'location'
    const mapToDisplay = view === 'role' ? roleMap : locationMap;

    // 5. Sort the group keys (role/location) for the GroupCard display
    const sortedGroups = useMemo(() => {
        if (view === 'account') return [];

        let keys = Object.keys(mapToDisplay);

        // If grouping by role, omit roles that have no members:
        if (view === 'role') {
            keys = keys.filter((role) => (mapToDisplay[role] || []).length > 0);
        }
        // (If you wanted to hide empty locations too, do the same check here.)

        // Then do the alphabetical (asc/desc) sort
        keys.sort((a, b) =>
            sortOrder === 'asc' ? a.localeCompare(b) : b.localeCompare(a)
        );
        return keys;
    }, [view, mapToDisplay, sortOrder]);

    // Switch the "view" among account/role/location
    const handleViewChange = (event, newValue) => {
        if (newValue !== null) {
            setView(newValue);
        }
    };

    // Determine icon color and direction
    const sortIconColor = sortOrder === 'asc' ? '#14b8a6' : '#f59e0b';
    const sortIcon =
        sortOrder === 'asc' ? (
            <ArrowUpward fontSize="small" sx={{ color: sortIconColor }} />
        ) : (
            <ArrowDownward fontSize="small" sx={{ color: sortIconColor }} />
        );

    return (
        <div className="bg-gray-900 min-h-screen text-teal-200 px-4 pb-10 pt-16">
            <PageHeader
                title="Character Overview"
                instructions={overviewInstructions}
                storageKey="showDashboardInstructions"
            />

            <Box
                sx={{
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'space-between',
                    mb: 3,
                }}
            >
                {/* Group By: Account, Role, Location */}
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                    <Typography variant="body2" sx={{ color: '#99f6e4' }}>
                        Group by:
                    </Typography>
                    <ToggleButtonGroup
                        value={view}
                        exclusive
                        onChange={handleViewChange}
                        sx={{
                            backgroundColor: 'rgba(255,255,255,0.05)',
                            borderRadius: '9999px',
                            padding: '2px',
                            '.MuiToggleButton-root': {
                                textTransform: 'none',
                                color: '#99f6e4',
                                fontWeight: 'normal',
                                border: 'none',
                                borderRadius: '9999px',
                                '&.Mui-selected': {
                                    backgroundColor: '#14b8a6 !important',
                                    color: '#ffffff !important',
                                    fontWeight: 'bold',
                                },
                                '&:hover': {
                                    backgroundColor: 'rgba(255,255,255,0.1)',
                                },
                                minWidth: '40px',
                                minHeight: '40px',
                            },
                        }}
                    >
                        <ToggleButton value="account" aria-label="Account">
                            <Tooltip title="Account">
                                <AccountBalance fontSize="small" />
                            </Tooltip>
                        </ToggleButton>
                        <ToggleButton value="role" aria-label="Role">
                            <Tooltip title="Role">
                                <AccountCircle fontSize="small" />
                            </Tooltip>
                        </ToggleButton>
                        <ToggleButton value="location" aria-label="Location">
                            <Tooltip title="Location">
                                <Place fontSize="small" />
                            </Tooltip>
                        </ToggleButton>
                    </ToggleButtonGroup>
                </Box>

                {/* Sort Order Control */}
                <Box
                    sx={{
                        display: 'flex',
                        alignItems: 'center',
                        gap: 1,
                        backgroundColor: 'rgba(255,255,255,0.05)',
                        borderRadius: '9999px',
                        paddingX: 1,
                        paddingY: 0.5,
                    }}
                >
                    <Typography variant="body2" sx={{ color: '#99f6e4' }}>
                        Sort:
                    </Typography>
                    <IconButton
                        onClick={toggleSortOrder}
                        aria-label="Sort"
                        sx={{
                            '&:hover': {
                                backgroundColor: 'rgba(255,255,255,0.1)',
                            },
                            padding: '4px',
                        }}
                        size="small"
                    >
                        {sortIcon}
                    </IconButton>
                </Box>

                {/* Show/Hide hidden accounts toggle
                    (Removed the `view === 'account' &&` check, so its always visible) */}
                <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                    <Tooltip
                        title={
                            showHiddenAccounts
                                ? 'Hide hidden accounts'
                                : 'Show hidden accounts'
                        }
                    >
                        <IconButton
                            onClick={() => setShowHiddenAccounts(!showHiddenAccounts)}
                            sx={{
                                color: showHiddenAccounts ? '#10b981' : '#6b7280',
                            }}
                        >
                            {showHiddenAccounts ? <VisibilityIcon /> : <VisibilityOffIcon />}
                        </IconButton>
                    </Tooltip>
                </Box>
            </Box>

            {/* RENDER LOGIC */}
            {view === 'account' ? (
                /* ------------- ACCOUNT VIEW ------------- */
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    {filteredAndSortedAccounts.length === 0 ? (
                        <Box textAlign="center" mt={4}>
                            <Typography variant="body1" sx={{ color: '#99f6e4' }}>
                                No accounts found.
                            </Typography>
                        </Box>
                    ) : (
                        filteredAndSortedAccounts.map((account) => (
                            <AccountCard
                                key={account.ID}
                                account={account}
                                onToggleAccountStatus={onToggleAccountStatus}
                                onUpdateAccountName={onUpdateAccountName}
                                onUpdateCharacter={onUpdateCharacter}
                                onRemoveCharacter={onRemoveCharacter}
                                onRemoveAccount={onRemoveAccount}
                                roles={roles}
                                skillConversions={skillConversions}
                                onToggleAccountVisibility={onToggleAccountVisibility}
                            />
                        ))
                    )}
                </div>
            ) : (
                /* ------------- GROUP VIEW (ROLE or LOCATION) ------------- */
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    {sortedGroups.length === 0 ? (
                        <Box textAlign="center" mt={4}>
                            <Typography variant="body1" sx={{ color: '#99f6e4' }}>
                                No characters found.
                            </Typography>
                        </Box>
                    ) : (
                        sortedGroups.map((group) => (
                            <GroupCard
                                key={group}
                                groupName={group}
                                characters={mapToDisplay[group] || []}
                                onUpdateCharacter={onUpdateCharacter}
                                roles={roles}
                                skillConversions={skillConversions}
                            />
                        ))
                    )}
                </div>
            )}
        </div>
    );
};

CharacterOverview.propTypes = {
    accounts: PropTypes.array.isRequired,
    onToggleAccountStatus: PropTypes.func.isRequired,
    onToggleAccountVisibility: PropTypes.func.isRequired,
    onUpdateCharacter: PropTypes.func.isRequired,
    onUpdateAccountName: PropTypes.func.isRequired,
    onRemoveCharacter: PropTypes.func.isRequired,
    onRemoveAccount: PropTypes.func.isRequired,
    roles: PropTypes.array.isRequired,
    skillConversions: PropTypes.object.isRequired,
};

export default CharacterOverview;

================
File: renderer/src/pages/CharacterOverview.test.jsx
================
// src/pages/CharacterOverview.test.jsx
import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import userEvent from '@testing-library/user-event';
import { vi } from 'vitest';
import Overview from './CharacterOverview.jsx';

describe('Overview', () => {
    let user;
    beforeAll(() => {
        user = userEvent.setup();
    });

    const mockAccounts = [
        {
            ID: 1,
            Name: 'Account A',
            Characters: [
                {
                    Character: {
                        CharacterName: 'Alice',
                        CharacterID: 1111, // Provide a unique ID here
                        LocationName: 'Jita',
                        CharacterSkillsResponse: { total_sp: 1000000 }
                    },
                    Role: 'Pvp',
                    MCT: false,
                }
            ]
        },
        {
            ID: 2,
            Name: 'Account B',
            Characters: [
                {
                    Character: {
                        CharacterName: 'Bob',
                        CharacterID: 2222, // And a unique ID here as well
                        LocationName: 'Amarr',
                        CharacterSkillsResponse: { total_sp: 2000000 }
                    },
                    Role: 'Logistics',
                    MCT: true,
                }
            ]
        }
    ];

    const mockConversions = {}


    const roles = ['Pvp', 'Logistics'];

    const onToggleAccountStatus = vi.fn();
    const onUpdateCharacter = vi.fn();
    const onUpdateAccountName = vi.fn();
    const onRemoveCharacter = vi.fn();
    const onRemoveAccount = vi.fn();

    test('renders accounts by default', () => {
        render(
            <Overview
                accounts={mockAccounts}
                onToggleAccountStatus={onToggleAccountStatus}
                onUpdateCharacter={onUpdateCharacter}
                onUpdateAccountName={onUpdateAccountName}
                onRemoveCharacter={onRemoveCharacter}
                onRemoveAccount={onRemoveAccount}
                roles={roles}
                skillConversions={mockConversions}
            />
        );

        // By default, grouping is by account, so Account A and Account B should appear
        expect(screen.getByText('Account A')).toBeInTheDocument();
        expect(screen.getByText('Account B')).toBeInTheDocument();
        // Character names rendered by AccountCard would appear too (if AccountCard works as expected)
        expect(screen.getByText('Alice')).toBeInTheDocument();
        expect(screen.getByText('Bob')).toBeInTheDocument();
    });

    test('can toggle sorting', async () => {
        render(
            <Overview
                accounts={mockAccounts}
                onToggleAccountStatus={onToggleAccountStatus}
                onUpdateCharacter={onUpdateCharacter}
                onUpdateAccountName={onUpdateAccountName}
                onRemoveCharacter={onRemoveCharacter}
                onRemoveAccount={onRemoveAccount}
                roles={roles}
                skillConversions={mockConversions}
            />
        );

        // Initially sorted in ascending order, Account A should appear before Account B
        const accountCards = screen.getAllByText(/Account [A|B]/i);
        expect(accountCards[0]).toHaveTextContent('Account A');
        expect(accountCards[1]).toHaveTextContent('Account B');

        // Click the sort icon to switch to descending order
        const sortButton = screen.getByRole('button', { name: /sort/i });
        await user.click(sortButton);

        // After toggling, Account B should come first if it's sorted by name desc
        const reorderedAccounts = screen.getAllByText(/Account [A|B]/i);
        expect(reorderedAccounts[0]).toHaveTextContent('Account B');
        expect(reorderedAccounts[1]).toHaveTextContent('Account A');
    });

    test('displays no accounts message if empty', () => {
        render(
            <Overview
                accounts={[]}
                onToggleAccountStatus={onToggleAccountStatus}
                onUpdateCharacter={onUpdateCharacter}
                onUpdateAccountName={onUpdateAccountName}
                onRemoveCharacter={onRemoveCharacter}
                onRemoveAccount={onRemoveAccount}
                roles={roles}
                skillConversions={mockConversions}
            />
        );

        expect(screen.getByText('No accounts found.')).toBeInTheDocument();
    });
});

================
File: renderer/src/pages/Landing.jsx
================
import  { useState } from 'react';
import LoginButton from '../components/landing/LoginButton.jsx';
import { Container, Box } from '@mui/material';
import PropTypes from "prop-types";

const Landing = ({logInCallBack}) => {
    const [isLoginModalOpen, setIsLoginModalOpen] = useState(false);

    const handleModalOpenChange = (isOpen) => {
        setIsLoginModalOpen(isOpen);
    };

    return (
        <Container
            maxWidth="md"
            sx={{
                minHeight: '100vh',
                display: 'flex',
                justifyContent: 'center',
                alignItems: 'center'
            }}
        >
            {/* Only apply animate-pulse if modal is not open */}
            <Box textAlign="center" className={!isLoginModalOpen ? 'animate-pulse' : ''}>
                <LoginButton
                    onModalOpenChange={handleModalOpenChange}
                    logInCallBack={logInCallBack}
                />
            </Box>
        </Container>
    );
};

Landing.propTypes = {
    logInCallBack: PropTypes.func.isRequired,
};

export default Landing;

================
File: renderer/src/pages/Mapping.jsx
================
// src/components/mapping/Mapping.jsx
import React, { useState, useEffect } from 'react';
import PropTypes from 'prop-types';
import { toast } from 'react-toastify';
import { Grid, Box } from '@mui/material';
import AccountCard from '../components/mapping/MapAccountCard.jsx';
import CharacterCard from '../components/mapping/MapCharacterCard.jsx';
import { useConfirmDialog } from '../hooks/useConfirmDialog.jsx';
import { associateCharacter, unassociateCharacter } from '../api/apiService.jsx';
import { mappingInstructions } from './../utils/instructions';
import PageHeader from '../components/common/SubPageHeader.jsx';

function roundToMinute(mtime) {
    const date = new Date(mtime);
    date.setSeconds(0);
    return date.toISOString();
}

const Mapping = ({ associations: initialAssociations, subDirs, onRefreshData }) => {
    const [accounts, setAccounts] = useState([]);
    const [availableCharacters, setAvailableCharacters] = useState([]);
    const [associations, setAssociations] = useState(initialAssociations);
    const [mtimeToColor, setMtimeToColor] = useState({});
    const [showConfirmDialog, confirmDialog] = useConfirmDialog();

    useEffect(() => {
        if (subDirs.length === 0) return;

        const userMap = {};
        subDirs.forEach((mapping) => {
            mapping.availableUserFiles.forEach((userFile) => {
                const roundedMtime = roundToMinute(userFile.mtime);
                if (
                    !userMap[userFile.userId] ||
                    new Date(roundedMtime) > new Date(userMap[userFile.userId].mtime)
                ) {
                    userMap[userFile.userId] = { ...userFile, mtime: roundedMtime };
                }
            });
        });

        const uniqueAccounts = Object.values(userMap).sort(
            (a, b) => new Date(b.mtime) - new Date(a.mtime)
        );

        const charMap = {};
        subDirs.forEach((mapping) => {
            mapping.availableCharFiles.forEach((charFile) => {
                const roundedMtime = roundToMinute(charFile.mtime);
                const { charId } = charFile;
                if (!charMap[charId] || new Date(roundedMtime) > new Date(charMap[charId].mtime)) {
                    charMap[charId] = { ...charFile, mtime: roundedMtime, profile: mapping.profile };
                }
            });
        });

        const associatedCharIds = new Set(associations.map((a) => a.charId));
        const uniqueChars = Object.values(charMap)
            .filter((ch) => !associatedCharIds.has(ch.charId))
            .sort((a, b) => new Date(b.mtime) - new Date(a.mtime));

        setAccounts(uniqueAccounts);
        setAvailableCharacters(uniqueChars);
        assignColors(uniqueAccounts, uniqueChars);
    }, [subDirs, associations]);

    const assignColors = (uniqueAccounts, uniqueChars) => {
        const predefinedColors = ['#4caf50', '#f44336', '#ff9800', '#9c27b0', '#00bcd4', '#e91e63'];

        const accountMtimes = uniqueAccounts.map((a) => a.mtime);
        const charMtimes = uniqueChars.map((c) => c.mtime);
        const allMtimes = [...accountMtimes, ...charMtimes];

        const uniqueMtimes = Array.from(new Set(allMtimes)).sort(
            (a, b) => new Date(a) - new Date(b)
        );

        const colorMapping = uniqueMtimes.reduce((acc, mtime, index) => {
            acc[mtime] = predefinedColors[index % predefinedColors.length];
            return acc;
        }, {});

        setMtimeToColor(colorMapping);
    };

    console.log(mtimeToColor);

    const handleDragStart = (event, charId) => {
        event.dataTransfer.setData('text/plain', charId);
    };

    const handleDrop = async (event, userId, userName) => {
        event.preventDefault();
        const charId = event.dataTransfer.getData('text/plain');

        if (associations.some((assoc) => assoc.charId === charId)) {
            toast.error('That character is already associated!');
            return;
        }

        const char = availableCharacters.find((c) => c.charId === charId);
        const charName = char?.name;
        if (!char) {
            toast.error('Character not found.');
            return;
        }

        const confirmAssoc = await showConfirmDialog({
            title: 'Confirm Association',
            message: `Associate "${charName}" with account "${userName}"?`,
        });

        if (!confirmAssoc.isConfirmed) return;

        const result = await associateCharacter(userId, charId, userName, charName);
        if (result && result.success) {
            toast.success(result.message);

            setAvailableCharacters((prev) => prev.filter((ch) => ch.charId !== charId));

            const newAssoc = { userId, charId, charName, mtime: char.mtime };
            setAssociations((prev) => [...prev, newAssoc]);

            if (onRefreshData) {
                await onRefreshData();
            }
        }
    };

    const handleUnassociate = async (userId, charId, charName, userName) => {
        const confirmUnassoc = await showConfirmDialog({
            title: 'Confirm Unassociation',
            message: `Unassociate "${charName}" from account "${userName}"?`,
        });

        if (!confirmUnassoc.isConfirmed) return;

        const result = await unassociateCharacter(userId, charId, userName, charName);
        if (result && result.success) {
            toast.success(result.message);
            setAssociations((prev) => prev.filter((a) => a.charId !== charId || a.userId !== userId));
            if (onRefreshData) {
                await onRefreshData();
            }
        }
    };

    const noCharacters = availableCharacters.length === 0;

    return (
        <div className="bg-gray-900 min-h-screen text-teal-200 px-4 pb-10 pt-16">
            <PageHeader
                title="Map Character Files to User Files"
                instructions={mappingInstructions}
                storageKey="showMappingInstructions"
            />
            <Box className="max-w-7xl mx-auto">
                <Grid container spacing={4}>
                    <Grid item xs={12} md={noCharacters ? 12 : 6}>
                        {accounts.length === 0 ? (
                            <Box textAlign="center" className="text-gray-300">
                                No accounts found.
                            </Box>
                        ) : (
                            <Grid container spacing={2}>
                                {accounts.map((mapping) => (
                                    <Grid
                                        item
                                        xs={12}
                                        sm={noCharacters ? 6 : 12}
                                        key={`${mapping.userId}-${mapping.mtime}`}
                                    >
                                        <AccountCard
                                            mapping={mapping}
                                            associations={associations}
                                            handleUnassociate={handleUnassociate}
                                            handleDrop={handleDrop}
                                            mtimeToColor={mtimeToColor}
                                        />
                                    </Grid>
                                ))}
                            </Grid>
                        )}
                    </Grid>

                    {/* Only display the Characters column if there are actually unassociated characters */}
                    {!noCharacters && (
                        <Grid item xs={12} md={6}>
                            <Grid container spacing={2} data-testid="available-characters">
                                {availableCharacters.map((char) => (
                                    <Grid item xs={12} sm={6} key={`${char.charId}-${char.mtime}`}>
                                        <CharacterCard
                                            char={char}
                                            handleDragStart={handleDragStart}
                                            mtimeToColor={mtimeToColor}
                                        />
                                    </Grid>
                                ))}
                            </Grid>
                        </Grid>
                    )}
                </Grid>
            </Box>

            {confirmDialog}
        </div>
    );
};

Mapping.propTypes = {
    associations: PropTypes.arrayOf(
        PropTypes.shape({
            userId: PropTypes.string.isRequired,
            charId: PropTypes.string.isRequired,
            charName: PropTypes.string.isRequired,
            mtime: PropTypes.string,
        })
    ).isRequired,
    subDirs: PropTypes.arrayOf(
        PropTypes.shape({
            profile: PropTypes.string.isRequired,
            availableCharFiles: PropTypes.array.isRequired,
            availableUserFiles: PropTypes.array.isRequired,
        })
    ).isRequired,
    onRefreshData: PropTypes.func,
};

export default Mapping;

================
File: renderer/src/pages/Mapping.test.jsx
================
import React from 'react';
import { render, screen, fireEvent, act, within } from '@testing-library/react';
import { vi } from 'vitest';
import Mapping from './Mapping';
import '@testing-library/jest-dom';

// Mock the confirm dialog hook
vi.mock('../hooks/useConfirmDialog.jsx', () => ({
    useConfirmDialog: () => {
        let resolveFn;
        const showConfirmDialog = ({title, message}) => {
            // Immediately resolve with {isConfirmed: true} for testing
            return new Promise((resolve) => {
                resolveFn = resolve;
                // In a real test, we might simulate user action here.
                resolve({ isConfirmed: true });
            });
        };
        const confirmDialog = null; // Not rendering actual dialog in test
        return [showConfirmDialog, confirmDialog];
    }
}));

// Mock apiService calls
vi.mock('../api/apiService.jsx', () => ({
    associateCharacter: vi.fn().mockResolvedValue({ success: true, message: 'Character associated successfully!' }),
    unassociateCharacter: vi.fn().mockResolvedValue({ success: true, message: 'Character unassociated successfully!' })
}));

import { associateCharacter, unassociateCharacter } from '../api/apiService.jsx';

describe('Mapping', () => {
    const mockOnRefreshData = vi.fn();

    beforeEach(() => {
        vi.clearAllMocks();
    });

    it('renders "No accounts found." and "No available characters..." when subDirs is empty', () => {
        render(
            <Mapping
                associations={[]}
                subDirs={[]}
            />
        );

        expect(screen.getByText('No accounts found.')).toBeInTheDocument();
    });

    it('renders accounts and characters', () => {
        const subDirs = [{
            profile: 'profile1',
            availableCharFiles: [
                { file: 'charFile1', charId: 'char1', name: 'Char One', mtime: '2023-10-05T14:30:00Z' }
            ],
            availableUserFiles: [
                { file: 'userFile1', userId: 'user1', name: 'User One', mtime: '2023-10-05T14:31:00Z' }
            ]
        }];

        render(
            <Mapping
                associations={[]}
                subDirs={subDirs}
            />
        );

        // The account should appear
        expect(screen.getByText('User One')).toBeInTheDocument();

        // The character should appear
        expect(screen.getByText('Char One')).toBeInTheDocument();
    });

    it('associates a character with an account via drag-and-drop', async () => {
        const subDirs = [{
            profile: 'profile1',
            availableCharFiles: [
                { file: 'charFile1', charId: 'char1', name: 'Char One', mtime: '2023-10-05T14:30:00Z' }
            ],
            availableUserFiles: [
                { file: 'userFile1', userId: 'user1', name: 'User One', mtime: '2023-10-05T14:31:00Z' }
            ]
        }];

        render(
            <Mapping
                associations={[]}
                subDirs={subDirs}
                onRefreshData={mockOnRefreshData}
            />
        );

        const charCard = screen.getByText('Char One').closest('div[draggable="true"]');
        const accountCard = screen.getByText('User One').closest('div');

        // Simulate drag start
        await act(async () => {
            fireEvent.dragStart(charCard, { dataTransfer: { setData: vi.fn() } });
        });

        // Mock the dataTransfer set/get calls
        const dataTransfer = {
            setData: vi.fn(),
            getData: vi.fn(() => 'char1')
        };

        // Drag over the account card
        await act(async () => {
            fireEvent.dragOver(accountCard);
        });

        // Drop on the account card
        await act(async () => {
            fireEvent.drop(accountCard, { dataTransfer });
        });

        expect(screen.queryByTestId('available-characters')).not.toBeInTheDocument();
        
        // Optionally, you can check that 'Char One' now appears under the account if desired
        expect(screen.getByText('Char One')).toBeInTheDocument(); // Now under the associated account
    });

    it('unassociates a character from an account', async () => {
        // Now we start with an associated character
        const initialAssociations = [
            { userId: 'user1', charId: 'char1', charName: 'Char One', mtime: '2023-10-05T14:30:00Z' }
        ];

        const subDirs = [{
            profile: 'profile1',
            availableCharFiles: [],
            availableUserFiles: [
                { file: 'userFile1', userId: 'user1', name: 'User One', mtime: '2023-10-05T14:31:00Z' }
            ]
        }];

        render(
            <Mapping
                associations={initialAssociations}
                subDirs={subDirs}
                onRefreshData={mockOnRefreshData}
            />
        );

        // The association should be visible under the account
        expect(screen.getByText('Char One')).toBeInTheDocument();

        // Click unassociate
        const unassociateBtn = screen.getByRole('button', { name: 'Unassociate Char One' });
        await act(async () => {
            fireEvent.click(unassociateBtn);
        });

        expect(unassociateCharacter).toHaveBeenCalledWith('user1', 'char1', 'User One', 'Char One');
        expect(screen.queryByText('Char One')).not.toBeInTheDocument(); // character should be removed after unassociation
        expect(mockOnRefreshData).toHaveBeenCalled();
    });
});

================
File: renderer/src/pages/SkillPlans.jsx
================
// src/components/skillplan/SkillPlans.jsx

import React, { useEffect, useState } from 'react';
import PropTypes from 'prop-types';
import CharacterTable from '../components/skillplan/CharacterTable.jsx';
import SkillPlanTable from '../components/skillplan/SkillPlanTable.jsx';
import {Typography, ToggleButtonGroup, ToggleButton, Box} from '@mui/material';
import {
    People as PeopleIcon,
    ListAlt as SkillPlansIcon,
} from '@mui/icons-material';
import {skillPlanInstructions} from "../utils/instructions.jsx";
import PageHeader from "../components/common/SubPageHeader.jsx";

const SkillPlans = ({ characters, skillPlans, conversions, onCopySkillPlan, onDeleteSkillPlan }) => {
    const [view, setView] = useState('characters'); // 'characters' or 'plans'

    const handleViewChange = (event, newValue) => {
        if (newValue) {
            setView(newValue);
        }
    };

    return (
        <div className="bg-gray-900 min-h-screen text-teal-200 px-4 pt-16 pb-10">
            <div className="max-w-7xl mx-auto">
                <PageHeader
                    title="Skill Plans"
                    instructions={skillPlanInstructions}
                    storageKey="showSkillPlanInstructions"
                />
                <Box className="flex items-center justify-between mb-4">
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                        <Typography variant="body2" sx={{ color: '#99f6e4' }}>
                            View:
                        </Typography>
                        <ToggleButtonGroup
                            value={view}
                            exclusive
                            onChange={handleViewChange}
                            sx={{
                                backgroundColor: 'rgba(255,255,255,0.05)',
                                borderRadius: '9999px',
                                padding: '2px',
                                '.MuiToggleButton-root': {
                                    textTransform: 'none',
                                    color: '#99f6e4',
                                    fontWeight: 'normal',
                                    border: 'none',
                                    borderRadius: '9999px',
                                    '&.Mui-selected': {
                                        backgroundColor: '#14b8a6 !important',
                                        color: '#ffffff !important',
                                        fontWeight: 'bold',
                                    },
                                    '&:hover': {
                                        backgroundColor: 'rgba(255,255,255,0.1)',
                                    },
                                    minWidth: '40px',
                                    minHeight: '40px',
                                },
                            }}
                        >
                            <ToggleButton value="characters" title="View Characters">
                                <PeopleIcon fontSize="small" />
                            </ToggleButton>
                            <ToggleButton value="plans" title="View Skill Plans">
                                <SkillPlansIcon fontSize="small" />
                            </ToggleButton>
                        </ToggleButtonGroup>
                    </Box>
                </Box>

                <div className="space-y-8">
                    {view === 'characters' && (
                        <div className="bg-gray-800 rounded-md p-4 shadow-md">
                            <Typography
                                variant="h5"
                                gutterBottom
                                sx={{ color: '#14b8a6', fontWeight: 'bold', marginBottom: '1rem' }}
                            >
                                By Character
                            </Typography>
                            <CharacterTable characters={characters} skillPlans={skillPlans} conversions={conversions} />
                        </div>
                    )}

                    {view === 'plans' && (
                        <div className="bg-gray-800 rounded-md p-4 shadow-md">
                            <Typography
                                variant="h5"
                                gutterBottom
                                sx={{ color: '#14b8a6', fontWeight: 'bold', marginBottom: '1rem' }}
                            >
                                By Skill Plan
                            </Typography>
                            <SkillPlanTable skillPlans={skillPlans} characters={characters} conversions={conversions}
                                            onCopySkillPlan={onCopySkillPlan} onDeleteSkillPlan={onDeleteSkillPlan} />
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
};

SkillPlans.propTypes = {
    characters: PropTypes.array.isRequired,
    skillPlans: PropTypes.object.isRequired,
    onCopySkillPlan: PropTypes.func.isRequired,
    onDeleteSkillPlan: PropTypes.func.isRequired,
    conversions: PropTypes.object.isRequired,
};

export default SkillPlans;

================
File: renderer/src/pages/SkillPlans.text.jsx
================
// src/components/skillplan/SkillPlans.test.jsx
import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import userEvent from '@testing-library/user-event';
import { vi } from 'vitest';
import SkillPlans from './SkillPlans';

// Mock the API and toast if necessary
vi.mock('../api/apiService.jsx', () => ({
    deleteSkillPlan: vi.fn().mockResolvedValue({ success: true }),
}));

vi.mock('react-toastify', () => ({
    toast: {
        success: vi.fn(),
        warning: vi.fn(),
        error: vi.fn(),
    }
}));

describe('SkillPlans', () => {
    const user = userEvent.setup();

    const mockCharacters = [
        {
            Character: {
                CharacterName: 'TestCharacter',
                LocationName: 'Jita',
                CharacterSkillsResponse: { total_sp: 1000000 }
            }
        }
    ];

    const mockSkillPlans = {
        "Plan A": {
            Name: "Plan A",
            Skills: {
                "SkillX": { Level: 5 },
            },
            QualifiedCharacters: ["TestCharacter"],
            PendingCharacters: [],
            MissingCharacters: []
        }
    };

    const mockConversions = {}

    const mockSetAppData = vi.fn();

    const mockOnCopy = vi.fn();

    const mockOnDelete = vi.fn()

    beforeEach(() => {
        mockSetAppData.mockClear();
    });

    test('renders and defaults to characters view', () => {
        render(
            <SkillPlans
                characters={mockCharacters}
                skillPlans={mockSkillPlans}
                setAppData={mockSetAppData}
                onCopySkillPlan={mockOnCopy}
                onDeleteSkillPlan={mockOnDelete}
                conversions={mockConversions}
            />
        );

        // Check main heading
        expect(screen.getByText('Skill Plans')).toBeInTheDocument();

        // By default view is 'characters', so "By Character" should be visible
        expect(screen.getByText('By Character')).toBeInTheDocument();
        expect(screen.queryByText('By Skill Plan')).not.toBeInTheDocument();
    });

    test('can switch to skill plans view', async () => {
        render(
            <SkillPlans
                characters={mockCharacters}
                skillPlans={mockSkillPlans}
                setAppData={mockSetAppData}
                onCopySkillPlan={mockOnCopy}
                onDeleteSkillPlan={mockOnDelete}
                conversions={mockConversions}
            />
        );

        // The toggle buttons are controlled, so let's find the "View Skill Plans" button
        const plansToggle = screen.getByRole('button', { name: /View Skill Plans/i });
        await user.click(plansToggle);

        // Now we should see the "By Skill Plan" section
        expect(screen.getByText('By Skill Plan')).toBeInTheDocument();
    });

});

================
File: renderer/src/pages/Sync.jsx
================
// src/components/sync/Sync.jsx

import React, { useState, useEffect, useCallback } from 'react';
import PropTypes from 'prop-types';
import { toast } from 'react-toastify';
import { useConfirmDialog } from '../hooks/useConfirmDialog.jsx';
import {
    CircularProgress,
    Grid,
    Box,
    Typography,
} from '@mui/material';

import SyncActionsBar from '../components/sync/SyncActionsBar.jsx';
import SubDirectoryCard from '../components/sync/SubDirectoryCard.jsx';
import {syncInstructions} from '../utils/instructions.jsx';

import {
    saveUserSelections,
    syncSubdirectory,
    syncAllSubdirectories,
    chooseSettingsDir,
    backupDirectory,
    resetToDefaultDirectory
} from '../api/apiService.jsx';
import PageHeader from "../components/common/SubPageHeader.jsx";

const Sync = ({
                  settingsData,
                  associations,
                  currentSettingsDir,
                  userSelections,
                  lastBackupDir,
              }) => {
    const [isLoading, setIsLoading] = useState(false);
    const [selections, setSelections] = useState({});
    const [showConfirmDialog, confirmDialog] = useConfirmDialog();
    const [isDefaultDir, setIsDefaultDir] = useState(false);
    const [message, setMessage] = useState('');

    // Load instruction visibility from localStorage
    const [showInstructions, setShowInstructions] = useState(() => {
        const stored = localStorage.getItem('showSyncInstructions');
        return stored === null ? true : JSON.parse(stored);
    });

    useEffect(() => {
        if (settingsData && settingsData.length > 0) {
            const initialSelections = { ...userSelections };
            settingsData.forEach(subDir => {
                if (!initialSelections[subDir.profile]) {
                    initialSelections[subDir.profile] = { charId: '', userId: '' };
                }
            });
            setSelections(initialSelections);
        }
    }, [settingsData, userSelections]);

    const saveSelectionsCallback = useCallback(async (newSelections) => {
        const result = await saveUserSelections(newSelections);
        if (!result || !result.success) {
            // Errors handled by apiRequest/toast internally
        }
    }, []);

    const handleSelectionChange = (profile, field, value) => {
        setSelections(prev => {
            const updated = {
                ...prev,
                [profile]: {
                    ...prev[profile],
                    [field]: value,
                }
            };

            // Auto-select user if associated with charId
            if (field === 'charId' && value) {
                const assoc = associations.find(a => a.charId === value);
                if (assoc) {
                    updated[profile].userId = assoc.userId;
                }
            }

            saveSelectionsCallback(updated);
            return updated;
        });
    };

    const handleSync = async (profile) => {
        const { userId, charId } = selections[profile];
        if (!userId || !charId) {
            toast.error('Please select both a user and a character to sync.');
            return;
        }

        const confirmSync = await showConfirmDialog({
            title: 'Confirm Sync',
            message: 'Are you sure you want to sync this profile with the chosen character and user?',
        });

        if (!confirmSync.isConfirmed) return;

        try {
            setIsLoading(true);
            toast.info('Syncing...', { autoClose: 1500 });
            console.log("Sync", profile, userId, charId);
            const result = await syncSubdirectory(profile, userId, charId);
            if (result && result.success) {
                toast.success(result.message);
                setMessage('Synced successfully!');
            }
        } catch (error) {
            console.error('Error syncing:', error);
        } finally {
            setIsLoading(false);
        }
    };

    const handleSyncAll = async (profile) => {
        const { userId, charId } = selections[profile];
        if (!userId || !charId) {
            toast.error('Please select both a user and a character for Sync-All.');
            return;
        }

        const confirmSyncAll = await showConfirmDialog({
            title: 'Confirm Sync All',
            message: 'Are you sure you want to sync all profiles with these selections?',
        });

        if (!confirmSyncAll.isConfirmed) return;

        try {
            setIsLoading(true);
            console.log("Sync all", profile, userId, charId);
            const result = await syncAllSubdirectories(profile, userId, charId);
            if (result && result.success) {
                toast.success(`Sync-All complete: ${result.message}`);
                setMessage(`Sync-All complete: ${result.message}`);
            }
        } catch (error) {
            console.error('Error syncing-all:', error);
        } finally {
            setIsLoading(false);
        }
    };

    const handleChooseSettingsDir = async () => {
        try {
            setIsLoading(true);
            const chosenDir = await window.electronAPI.chooseDirectory();
            if (!chosenDir) {
                toast.info('No directory chosen.');
                setIsLoading(false);
                return;
            }

            const result = await chooseSettingsDir(chosenDir);
            if (result && result.success) {
                setIsDefaultDir(false);
                toast.success(`Settings directory chosen: ${chosenDir}`);
                setMessage('Settings directory chosen!');
            }
        } catch (error) {
            console.error('Error choosing settings directory:', error);
        } finally {
            setIsLoading(false);
        }
    };

    const handleBackup = async () => {
        try {
            setIsLoading(true);

            const chosenDir = await window.electronAPI.chooseDirectory(lastBackupDir || '');
            if (!chosenDir) {
                toast.info('No backup directory chosen. Backup canceled.');
                setIsLoading(false);
                return;
            }

            toast.info('Starting backup...');
            const result = await backupDirectory(currentSettingsDir, chosenDir);
            if (result && result.success) {
                toast.success(result.message);
                setMessage('Backup complete!');
            }
        } catch (error) {
            console.error('Error during backup:', error);
        } finally {
            setIsLoading(false);
        }
    };

    const handleResetToDefault = async () => {
        const confirmReset = await showConfirmDialog({
            title: 'Reset to Default',
            message: 'Reset the settings directory to default (Tranquility)?',
        });

        if (!confirmReset.isConfirmed) return;

        try {
            setIsLoading(true);
            const result = await resetToDefaultDirectory();
            if (result && result.success) {
                setIsDefaultDir(true);
                toast.success('Directory reset to default: Tranquility');
                setMessage('Directory reset to default: Tranquility');
            }
        } catch (error) {
            console.error('Error resetting directory:', error);
        } finally {
            setIsLoading(false);
        }
    };

    const toggleInstructions = () => {
        const newValue = !showInstructions;
        setShowInstructions(newValue);
        localStorage.setItem('showSyncInstructions', JSON.stringify(newValue));
    };

    return (
        <div className="bg-gray-900 min-h-screen text-teal-200 px-4 pb-10 pt-16">
            <PageHeader
                title="Sync Profile Settings"
                instructions={syncInstructions}
                storageKey="showSyncInstructions"
            />
            <SyncActionsBar
                handleBackup={handleBackup}
                handleChooseSettingsDir={handleChooseSettingsDir}
                handleResetToDefault={handleResetToDefault}
                isDefaultDir={isDefaultDir}
                isLoading={isLoading}
            />

            {isLoading && (
                <Box display="flex" justifyContent="center" alignItems="center" className="mb-4">
                    <CircularProgress color="primary" />
                </Box>
            )}

            {message && (
                <Box className="max-w-7xl mx-auto mt-4">
                    <Typography>{message}</Typography>
                </Box>
            )}

            <Grid container spacing={4} className="max-w-7xl mx-auto">
                {settingsData.map(subDir => (
                    <Grid item xs={12} sm={6} md={4} key={subDir.profile}>
                        <SubDirectoryCard
                            subDir={subDir}
                            selections={selections}
                            handleSelectionChange={handleSelectionChange}
                            handleSync={handleSync}
                            handleSyncAll={handleSyncAll}
                            isLoading={isLoading}
                        />
                    </Grid>
                ))}
            </Grid>
            {confirmDialog}
        </div>
    );
};

Sync.propTypes = {
    settingsData: PropTypes.array.isRequired,
    associations: PropTypes.array.isRequired,
    currentSettingsDir: PropTypes.string.isRequired,
    lastBackupDir: PropTypes.string.isRequired,
    userSelections: PropTypes.object.isRequired,
};

export default Sync;

================
File: renderer/src/pages/Sync.test.jsx
================
import React from 'react';
import { render, screen, fireEvent, act } from '@testing-library/react';
import { vi } from 'vitest';
import Sync from './Sync';
import '@testing-library/jest-dom';

// Mock useConfirmDialog
vi.mock('../hooks/useConfirmDialog.jsx', () => ({
    useConfirmDialog: () => {
        const showConfirmDialog = () => {
            // Always resolve with isConfirmed: true
            return Promise.resolve({ isConfirmed: true });
        };
        const confirmDialog = null;
        return [showConfirmDialog, confirmDialog];
    }
}));

// Mock apiService calls
vi.mock('../api/apiService.jsx', () => ({
    saveUserSelections: vi.fn().mockResolvedValue({ success: true }),
    syncSubdirectory: vi.fn().mockResolvedValue({ success: true, message: 'Synced successfully!' }),
    syncAllSubdirectories: vi.fn().mockResolvedValue({ success: true, message: 'Sync-All successful!' }),
    chooseSettingsDir: vi.fn().mockResolvedValue({ success: true }),
    backupDirectory: vi.fn().mockResolvedValue({ success: true, message: 'Backup complete!' }),
    resetToDefaultDirectory: vi.fn().mockResolvedValue({ success: true }),
}));

import {
    saveUserSelections,
    syncSubdirectory,
    syncAllSubdirectories,
    chooseSettingsDir,
    backupDirectory,
    resetToDefaultDirectory
} from '../api/apiService.jsx';

// Mock electronAPI
window.electronAPI = {
    chooseDirectory: vi.fn().mockResolvedValue('/chosen/dir')
};

describe('Sync component', () => {
    const defaultProps = {
        settingsData: [],
        associations: [],
        currentSettingsDir: '/current/dir',
        userSelections: {},
        lastBackupDir: '',
        backEndURL: 'http://localhost:8713',
    };

    beforeEach(() => {
        vi.clearAllMocks();
    });

    it('renders with no settingsData and shows no subdirectories', () => {
        render(<Sync {...defaultProps} />);
        expect(screen.getByText('Sync Profile Settings')).toBeInTheDocument();
        // No subDir => no SubDirectoryCard
        expect(screen.queryByText('-- Select Character --')).not.toBeInTheDocument();
    });

    it('renders SubDirectoryCards when settingsData is provided', () => {
        const props = {
            ...defaultProps,
            settingsData: [{
                profile: 'settings_profileA',
                availableCharFiles: [
                    { charId: 'char1', name: 'Char One' }
                ],
                availableUserFiles: [
                    { userId: 'userA', name: 'User A' }
                ]
            }],
            userSelections: {
                'settings_profileA': { charId: '', userId: '' }
            }
        };
        render(<Sync {...props} />);

        // The subdir name displayed without 'settings_'
        expect(screen.getByText('profileA')).toBeInTheDocument();
        // Character and user selects
        expect(screen.getByLabelText('Select Character')).toBeInTheDocument();
        expect(screen.getByLabelText('Select User')).toBeInTheDocument();
    });

    it('handles character selection and auto-user selection if associated', () => {
        const associations = [{ userId: 'userA', charId: 'char1', charName: 'Char One' }];
        const props = {
            ...defaultProps,
            associations,
            settingsData: [{
                profile: 'settings_profileA',
                availableCharFiles: [
                    { charId: 'char1', name: 'Char One' }
                ],
                availableUserFiles: [
                    { userId: 'userA', name: 'User A' }
                ]
            }],
            userSelections: {}
        };
        render(<Sync {...props} />);

        const charSelect = screen.getByLabelText('Select Character');
        fireEvent.mouseDown(charSelect);
        fireEvent.click(screen.getByText('Char One'));

        // After selection, user should be auto-selected if assoc found
        expect(saveUserSelections).toHaveBeenCalled();
    });

    it('syncs a single profile', async () => {
        const props = {
            ...defaultProps,
            settingsData: [{
                profile: 'settings_profileA',
                availableCharFiles: [
                    { charId: 'char1', name: 'Char One' }
                ],
                availableUserFiles: [
                    { userId: 'userA', name: 'User A' }
                ]
            }],
            userSelections: {
                'settings_profileA': { charId: 'char1', userId: 'userA' }
            }
        };
        render(<Sync {...props} />);

        const syncButton = screen.getByRole('button', { name: /sync this specific profile/i });
        await act(async () => {
            fireEvent.click(syncButton);
        });

        expect(syncSubdirectory).toHaveBeenCalledWith('settings_profileA', 'userA', 'char1');
        expect(screen.getByText('Synced successfully!')).toBeInTheDocument();
    });

    it('syncs all profiles', async () => {
        const props = {
            ...defaultProps,
            settingsData: [{
                profile: 'settings_profileB',
                availableCharFiles: [
                    { charId: 'char2', name: 'Char Two' }
                ],
                availableUserFiles: [
                    { userId: 'userB', name: 'User B' }
                ]
            }],
            userSelections: {
                'settings_profileB': { charId: 'char2', userId: 'userB' }
            }
        };
        render(<Sync {...props} />);

        const syncAllButton = screen.getByRole('button', { name: /sync all profiles based on this selection/i });
        await act(async () => {
            fireEvent.click(syncAllButton);
        });

        expect(syncAllSubdirectories).toHaveBeenCalledWith('settings_profileB', 'userB', 'char2');
        expect(screen.getByText('Sync-All complete: Sync-All successful!')).toBeInTheDocument();
    });

    it('chooses settings directory', async () => {
        render(<Sync {...defaultProps} />);
        const chooseDirBtn = screen.getByRole('button', { name: /choose settings directory/i });

        await act(async () => {
            fireEvent.click(chooseDirBtn);
        });

        expect(window.electronAPI.chooseDirectory).toHaveBeenCalled();
        expect(chooseSettingsDir).toHaveBeenCalledWith('/chosen/dir');
    });

    it('backup directory chosen', async () => {
        render(<Sync {...defaultProps} />);
        const backupBtn = screen.getByRole('button', { name: /backup settings/i });

        await act(async () => {
            fireEvent.click(backupBtn);
        });

        expect(window.electronAPI.chooseDirectory).toHaveBeenCalledWith('');
        expect(backupDirectory).toHaveBeenCalledWith('/current/dir', '/chosen/dir');
        expect(screen.getByText('Backup complete!')).toBeInTheDocument();
    });

    it('reset to default directory', async () => {
        render(<Sync {...defaultProps} />);
        const resetBtn = screen.getByRole('button', { name: /reset to default directory/i });

        await act(async () => {
            fireEvent.click(resetBtn);
        });

        expect(resetToDefaultDirectory).toHaveBeenCalledWith();
        expect(screen.getByText('Directory reset to default: Tranquility')).toBeInTheDocument();
    });
});

================
File: renderer/src/utils/addDataTransforms.test.jsx
================
import { describe, it, expect } from 'vitest';
import {
    updateAccountNameInAppData,
    removeCharacterFromAppData,
    updateCharacterInAppData,
    toggleAccountStatusInAppData,
    removeAccountFromAppData
} from './appDataTransforms';

describe('appDataTransforms', () => {
    const initialAppData = {
        LoggedIn: true,
        AccountData: {
            Accounts: [
                {
                    ID: 1,
                    Name: 'AccountOne',
                    Status: 'Alpha',
                    Characters: [
                        { Character: { CharacterID: 100, CharacterName: 'Char100' }, Role: 'Miner' },
                        { Character: { CharacterID: 101, CharacterName: 'Char101' }, Role: 'Pvp' }
                    ]
                },
                {
                    ID: 2,
                    Name: 'AccountTwo',
                    Status: 'Omega',
                    Characters: [
                        { Character: { CharacterID: 200, CharacterName: 'Char200' }, Role: 'Hauler' }
                    ]
                }
            ],
            Associations: []
        },
        ConfigData: {
            Roles: ['Miner', 'Pvp'],
            SettingsDir: '/some/dir',
            LastBackupDir: '',
            DropDownSelections: {}
        },
        EveData: {
            SkillPlans: {},
            EveProfiles: []
        }
    };

    describe('updateAccountNameInAppData', () => {
        it('updates the name of the matching account', () => {
            const result = updateAccountNameInAppData(initialAppData, 1, 'NewAccountName');
            const updated = result.AccountData.Accounts.find(a => a.ID === 1);
            expect(updated.Name).toBe('NewAccountName');
        });

        it('returns prev if no match', () => {
            const result = updateAccountNameInAppData(initialAppData, 999, 'NoChange');
            expect(result).toEqual(initialAppData); // no changes
        });

        it('returns prev if prev is null', () => {
            expect(updateAccountNameInAppData(null, 1, 'Name')).toBeNull();
        });
    });

    describe('removeCharacterFromAppData', () => {
        it('removes a character by ID', () => {
            const result = removeCharacterFromAppData(initialAppData, 101);
            const account1 = result.AccountData.Accounts.find(a => a.ID === 1);
            expect(account1.Characters.find(c => c.Character.CharacterID === 101)).toBeUndefined();
        });

        it('no changes if character ID not found', () => {
            const result = removeCharacterFromAppData(initialAppData, 999);
            expect(result).toEqual(initialAppData);
        });

        it('returns prev if prev is null', () => {
            expect(removeCharacterFromAppData(null, 100)).toBeNull();
        });
    });

    describe('updateCharacterInAppData', () => {
        it('updates character fields and adds new role if needed', () => {
            const result = updateCharacterInAppData(initialAppData, 100, { Role: 'Logistics', Extra: 'Data' });
            const account1 = result.AccountData.Accounts.find(a => a.ID === 1);
            const char = account1.Characters.find(c => c.Character.CharacterID === 100);
            expect(char.Role).toBe('Logistics');
            expect(char.Extra).toBe('Data');
            expect(result.ConfigData.Roles).toContain('Logistics');
        });

        it('does not duplicate roles if already exists', () => {
            const result = updateCharacterInAppData(initialAppData, 100, { Role: 'Pvp' });
            expect(result.ConfigData.Roles.filter(r => r === 'Pvp').length).toBe(1);
        });

        it('returns prev if no character found', () => {
            const result = updateCharacterInAppData(initialAppData, 999, { Role: 'Whatever' });
            expect(result).toEqual(initialAppData);
        });

        it('returns prev if prev is null', () => {
            expect(updateCharacterInAppData(null, 100, {})).toBeNull();
        });
    });

    describe('toggleAccountStatusInAppData', () => {
        it('toggles Alpha to Omega', () => {
            const result = toggleAccountStatusInAppData(initialAppData, 1);
            const account1 = result.AccountData.Accounts.find(a => a.ID === 1);
            expect(account1.Status).toBe('Omega');
        });

        it('toggles Omega to Alpha', () => {
            const result = toggleAccountStatusInAppData(initialAppData, 2);
            const account2 = result.AccountData.Accounts.find(a => a.ID === 2);
            expect(account2.Status).toBe('Alpha');
        });

        it('no change if account not found', () => {
            const result = toggleAccountStatusInAppData(initialAppData, 999);
            expect(result).toEqual(initialAppData);
        });

        it('returns prev if prev is null', () => {
            expect(toggleAccountStatusInAppData(null, 1)).toBeNull();
        });
    });

    describe('removeAccountFromAppData', () => {
        it('removes account by name', () => {
            const result = removeAccountFromAppData(initialAppData, 'AccountTwo');
            expect(result.AccountData.Accounts.find(a => a.Name === 'AccountTwo')).toBeUndefined();
        });

        it('no change if account name not found', () => {
            const result = removeAccountFromAppData(initialAppData, 'NonExistingAccount');
            expect(result).toEqual(initialAppData);
        });

        it('returns prev if prev is null', () => {
            expect(removeAccountFromAppData(null, 'AccountOne')).toBeNull();
        });
    });
});

================
File: renderer/src/utils/appDataTransforms.jsx
================
/**
 * Utility functions for transforming appData with the new model structure.
 *
 * Remember the new structure:
 * appData = {
 *   LoggedIn: boolean,
 *   AccountData: {
 *     Accounts: [],
 *     Associations: []
 *   },
 *   ConfigData: {
 *     Roles: [],
 *     SettingsDir: string,
 *     LastBackupDir: string,
 *     DropDownSelections: {}
 *   },
 *   EveData: {
 *     SkillPlans: {},
 *     EveProfiles: []
 *   }
 * }
 */

export function updateAccountNameInAppData(prev, accountID, newName) {
    if (!prev) return prev;

    const updatedAccounts = prev.AccountData.Accounts.map((account) =>
        account.ID === accountID ? { ...account, Name: newName } : account
    );

    return {
        ...prev,
        AccountData: {
            ...prev.AccountData,
            Accounts: updatedAccounts
        }
    };
}

export function removeCharacterFromAppData(prev, characterID) {
    if (!prev) return prev;
    const updatedAccounts = prev.AccountData.Accounts.map((account) => {
        const filteredCharacters = account.Characters.filter(
            (c) => c.Character.CharacterID !== characterID
        );
        return { ...account, Characters: filteredCharacters };
    });

    return {
        ...prev,
        AccountData: {
            ...prev.AccountData,
            Accounts: updatedAccounts
        }
    };
}

export function updateCharacterInAppData(prev, characterID, updates) {
    if (!prev) return prev;

    let characterFound = false;

    const updatedAccounts = prev.AccountData.Accounts.map((account) => {
        const updatedCharacters = account.Characters.map((character) => {
            if (character.Character.CharacterID === characterID) {
                characterFound = true;
                return { ...character, ...updates };
            }
            return character;
        });
        return { ...account, Characters: updatedCharacters };
    });

    // If character not found, return prev as is
    if (!characterFound) {
        return prev;
    }

    const updatedRoles = Array.isArray(prev.ConfigData.Roles) ? [...prev.ConfigData.Roles] : [];
    if (updates.Role && !updatedRoles.includes(updates.Role)) {
        updatedRoles.push(updates.Role);
    }

    return {
        ...prev,
        AccountData: {
            ...prev.AccountData,
            Accounts: updatedAccounts
        },
        ConfigData: {
            ...prev.ConfigData,
            Roles: updatedRoles
        }
    };
}


export function toggleAccountStatusInAppData(prev, accountID) {
    if (!prev) return prev;

    const updatedAccounts = prev.AccountData.Accounts.map((account) =>
        account.ID === accountID
            ? { ...account, Status: account.Status === 'Alpha' ? 'Omega' : 'Alpha' }
            : account
    );

    return {
        ...prev,
        AccountData: {
            ...prev.AccountData,
            Accounts: updatedAccounts
        }
    };
}


export function toggleAccountVisibilityInAppData(prev, accountID) {
    if (!prev) return prev;

    const updatedAccounts = prev.AccountData.Accounts.map((account) =>
        account.ID === accountID
            ? { ...account, Visible: !account.Visible }
            : account
    );

    return {
        ...prev,
        AccountData: {
            ...prev.AccountData,
            Accounts: updatedAccounts
        }
    };
}

export function removeAccountFromAppData(prev, accountName) {
    if (!prev) return prev;
    const updatedAccounts = prev.AccountData.Accounts.filter(
        (account) => account.Name !== accountName
    );

    return {
        ...prev,
        AccountData: {
            ...prev.AccountData,
            Accounts: updatedAccounts
        }
    };
}

export function removePlanFromSkillPlans(prev, planName) {
    if (!prev) return prev;

    console.log("planName: ", planName)
    console.log(prev.EveData.SkillPlans)
    const updatedSkillPlans = { ...prev.EveData.SkillPlans };
    delete updatedSkillPlans[planName];
    console.log(updatedSkillPlans)

    return {
        ...prev,
        EveData: {
            ...prev.EveData,
            SkillPlans: updatedSkillPlans
        }
    };
}

================
File: renderer/src/utils/dataNormalizer.jsx
================
/**
 * Normalize appData to ensure certain fields always exist in known formats under the new model.
 *
 * New structure:
 * appData = {
 *   LoggedIn: boolean,
 *   AccountData: {
 *     Accounts: [],
 *     Associations: []
 *   },
 *   ConfigData: {
 *     Roles: [],
 *     SettingsDir: string,
 *     LastBackupDir: string,
 *     DropDownSelections: {}
 *   },
 *   EveData: {
 *     SkillPlans: {},
 *     EveProfiles: []
 *     EveConversions: {},
 *   }
 * }
 *
 * This function ensures each nested array/object exists, without adding old top-level fields.
 */
import { warn }  from "./logger.jsx"
export function normalizeAppData(data) {
    if (!data) {
        warn("normalizeAppData: Received null or undefined appData from API. Returning null.");
        return null;
    }

    // Validate LoggedIn
    let LoggedIn = data.LoggedIn;
    if (typeof LoggedIn !== 'boolean') {
        warn("normalizeAppData: appData.LoggedIn is not a boolean. Defaulting to false.");
        LoggedIn = false;
    }

    // Validate AccountData
    let AccountData = data.AccountData;
    if (typeof AccountData !== 'object' || AccountData === null) {
        warn("normalizeAppData: appData.AccountData is not an object. Defaulting to empty object.");
        AccountData = {};
    }
    const Accounts = Array.isArray(AccountData.Accounts) ? AccountData.Accounts : (warn("normalizeAppData: appData.AccountData.Accounts is not an array. Defaulting to []."), []);
    const Associations = Array.isArray(AccountData.Associations) ? AccountData.Associations : (warn("normalizeAppData: appData.AccountData.Associations is not an array. Defaulting to []."), []);

    const UserAccount = (typeof AccountData.UserAccount === 'object' && AccountData.UserAccount !== null)
        ? AccountData.UserAccount
        : (() => {
            if (AccountData.UserAccount !== undefined) {
                warn("normalizeAppData: appData.AccountData.UserAccount is not an object. Defaulting to {}.");
            }
            return {};
        })();

    // Validate ConfigData
    let ConfigData = data.ConfigData;
    if (typeof ConfigData !== 'object' || ConfigData === null) {
        warn("normalizeAppData: appData.ConfigData is not an object. Defaulting to empty object.");
        ConfigData = {};
    }
    const Roles = Array.isArray(ConfigData.Roles) ? ConfigData.Roles : (warn("normalizeAppData: appData.ConfigData.Roles is not an array. Defaulting to []."), []);
    const DropDownSelections = (typeof ConfigData.DropDownSelections === 'object' && ConfigData.DropDownSelections !== null)
        ? ConfigData.DropDownSelections
        : (warn("normalizeAppData: appData.ConfigData.DropDownSelections is not an object. Defaulting to {}."), {});

    const SettingsDir = typeof ConfigData.SettingsDir === 'string' ? ConfigData.SettingsDir : (warn("normalizeAppData: appData.ConfigData.SettingsDir is not a string. Defaulting to ''."), '');
    const LastBackupDir = typeof ConfigData.LastBackupDir === 'string' ? ConfigData.LastBackupDir : (warn("normalizeAppData: appData.ConfigData.LastBackupDir is not a string. Defaulting to ''."), '');

    // Validate EveData
    let EveData = data.EveData;
    if (typeof EveData !== 'object' || EveData === null) {
        warn("normalizeAppData: appData.EveData is not an object. Defaulting to empty object.");
        EveData = {};
    }
    const SkillPlans = (typeof EveData.SkillPlans === 'object' && EveData.SkillPlans !== null) ? EveData.SkillPlans : (warn("normalizeAppData: appData.EveData.SkillPlans is not an object. Defaulting to {}."), {});
    const EveProfiles = Array.isArray(EveData.EveProfiles) ? EveData.EveProfiles : (warn("normalizeAppData: appData.EveData.EveProfiles is not an array. Defaulting to []."), []);
    const EveConversions = (typeof EveData.EveConversions === 'object' && EveData.EveConversions !== null) ? EveData.EveConversions : (warn("normalizeAppData: appData.EveData.EveConversions is not an object. Defaulting to {}."), {});

    return {
        LoggedIn,
        AccountData: {
            Accounts,
            Associations,
            UserAccount
        },
        ConfigData: {
            Roles,
            DropDownSelections,
            SettingsDir,
            LastBackupDir
        },
        EveData: {
            SkillPlans,
            EveProfiles,
            EveConversions,
        }
    };
}

================
File: renderer/src/utils/dataNormalizer.test.jsx
================
import { describe, it, expect, vi } from 'vitest';
import { normalizeAppData } from './dataNormalizer.jsx';
import { warn } from './logger.jsx';

// Mock the warn function
vi.mock('./logger.jsx', () => ({
    warn: vi.fn(),
}));

describe('normalizeAppData', () => {
    beforeEach(() => {
        vi.clearAllMocks();
    });

    it('returns null and warns if data is null or undefined', () => {
        expect(normalizeAppData(null)).toBeNull();
        expect(warn).toHaveBeenCalledWith("normalizeAppData: Received null or undefined appData from API. Returning null.");

        vi.clearAllMocks();

        expect(normalizeAppData(undefined)).toBeNull();
        expect(warn).toHaveBeenCalledWith("normalizeAppData: Received null or undefined appData from API. Returning null.");
    });

    it('defaults LoggedIn to false if not boolean', () => {
        const data = { LoggedIn: 'not boolean' };
        const result = normalizeAppData(data);
        expect(result.LoggedIn).toBe(false);
        expect(warn).toHaveBeenCalledWith("normalizeAppData: appData.LoggedIn is not a boolean. Defaulting to false.");
    });

    it('defaults AccountData to empty object if not object', () => {
        const data = { LoggedIn: true, AccountData: "notAnObject" };
        const result = normalizeAppData(data);
        expect(result.AccountData).toEqual({
            Accounts: [],
            Associations: [],
            UserAccount: {}
        });
        expect(warn).toHaveBeenCalledWith("normalizeAppData: appData.AccountData is not an object. Defaulting to empty object.");
        expect(warn).toHaveBeenCalledWith("normalizeAppData: appData.AccountData.Accounts is not an array. Defaulting to [].");
        expect(warn).toHaveBeenCalledWith("normalizeAppData: appData.AccountData.Associations is not an array. Defaulting to [].");
    });

    it('handles UserAccount defaults', () => {
        const data = {
            LoggedIn: true,
            AccountData: {
                Accounts: [],
                Associations: [],
                UserAccount: "notObject"
            }
        };
        const result = normalizeAppData(data);
        expect(result.AccountData.UserAccount).toEqual({});
        expect(warn).toHaveBeenCalledWith("normalizeAppData: appData.AccountData.UserAccount is not an object. Defaulting to {}.");
    });

    it('defaults ConfigData if not object', () => {
        const data = { LoggedIn: true, AccountData: {}, ConfigData: null };
        const result = normalizeAppData(data);
        expect(result.ConfigData).toEqual({
            Roles: [],
            DropDownSelections: {},
            SettingsDir: '',
            LastBackupDir: ''
        });
        expect(warn).toHaveBeenCalledWith("normalizeAppData: appData.ConfigData is not an object. Defaulting to empty object.");
        expect(warn).toHaveBeenCalledWith("normalizeAppData: appData.ConfigData.Roles is not an array. Defaulting to [].");
        expect(warn).toHaveBeenCalledWith("normalizeAppData: appData.ConfigData.SettingsDir is not a string. Defaulting to ''.");
        expect(warn).toHaveBeenCalledWith("normalizeAppData: appData.ConfigData.LastBackupDir is not a string. Defaulting to ''.");
    });

    it('defaults EveData if not object', () => {
        const data = { LoggedIn: true, AccountData: {}, ConfigData: {}, EveData: "notObject" };
        const result = normalizeAppData(data);
        expect(result.EveData).toEqual({
            SkillPlans: {},
            EveProfiles: [],
            EveConversions: {},
        });
        expect(warn).toHaveBeenCalledWith("normalizeAppData: appData.EveData is not an object. Defaulting to empty object.");
        expect(warn).toHaveBeenCalledWith("normalizeAppData: appData.EveData.SkillPlans is not an object. Defaulting to {}.");
        expect(warn).toHaveBeenCalledWith("normalizeAppData: appData.EveData.EveProfiles is not an array. Defaulting to [].");
        expect(warn).toHaveBeenCalledWith("normalizeAppData: appData.EveData.EveConversions is not an object. Defaulting to {}.");
    });

    it('returns a fully normalized object when given proper data', () => {
        const data = {
            LoggedIn: true,
            AccountData: {
                Accounts: [{ Name: 'TestAccount' }],
                Associations: [{ userId: 'user1', charId: 'char1' }],
                UserAccount: { userId: 'user123' }
            },
            ConfigData: {
                Roles: ['Admin', 'User'],
                DropDownSelections: { key: 'value' },
                SettingsDir: '/path/to/settings',
                LastBackupDir: '/path/to/backup'
            },
            EveData: {
                SkillPlans: { PlanA: { Skills: {} } },
                EveProfiles: [{ profile: 'default' }],
                EveConversions: { Something: 'else'}
            }
        };

        const result = normalizeAppData(data);

        expect(result).toEqual({
            LoggedIn: true,
            AccountData: {
                Accounts: [{ Name: 'TestAccount' }],
                Associations: [{ userId: 'user1', charId: 'char1' }],
                UserAccount: { userId: 'user123' }
            },
            ConfigData: {
                Roles: ['Admin', 'User'],
                DropDownSelections: { key: 'value' },
                SettingsDir: '/path/to/settings',
                LastBackupDir: '/path/to/backup'
            },
            EveData: {
                SkillPlans: { PlanA: { Skills: {} } },
                EveProfiles: [{ profile: 'default' }],
                EveConversions: { Something: 'else'}
            }
        });

        // No warnings should be called in this case
        expect(warn).not.toHaveBeenCalled();
    });
});

================
File: renderer/src/utils/formatter.jsx
================
// utils/dateFormatter.js

export const formatDate = (isoString) => {
    return new Date(isoString).toLocaleString(undefined, {
        year: undefined, // Remove the year
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        hour12: false, // Use 24-hour time
    });
};

export const calculateDaysFromToday = (date) => {
    if (!date) return "";
    const targetDate = new Date(date);
    const currentDate = new Date();
    const diffTime = targetDate - currentDate;
    if (diffTime <= 0) return "0 days";
    // Use floor instead of ceil to avoid rounding up partial days
    return `${Math.floor(diffTime / (1000 * 60 * 60 * 24))} days`;
};

export const formatNumberWithCommas = (num) => {
    return num.toLocaleString(); // Using toLocaleString to format numbers with commas
};

export const formatSP = (totalSp) => {
    if (!totalSp || totalSp < 1_000_000) {
        return '<1M SP';
    }

    const millions = Math.round(totalSp / 1_000_000);
    return `${millions}M SP`;
}

================
File: renderer/src/utils/formatter.test.jsx
================
import { describe, it, expect, vi } from 'vitest';
import { formatDate, calculateDaysFromToday, formatNumberWithCommas } from './formatter';

describe('dateFormatter', () => {
    describe('formatDate', () => {
        it('formats an ISO string without the year and with a 24-hour time', () => {
            // Set a known date/time in UTC so we get a predictable result
            // For example, 2023-10-05T14:30:00Z
            const isoString = '2023-10-05T14:30:00Z';
            // formatDate uses the local time zone, so the output depends on the environment's locale and time zone.
            // We'll just check if it returns a string containing expected month/day and hour:minute.

            const result = formatDate(isoString);
            // result might look like "Oct 5, 14:30" in a certain locale.
            // Check for partial matches
            expect(result).toMatch(/Oct/);    // Check for abbreviated month
            expect(result).toMatch(/5/);      // Day should appear
            // Check there's a time with 24-hour format (e.g., "14:30")
            expect(result).toMatch(/\d{2}:\d{2}/);
            // Since we removed the year, ensure no full year is present
            expect(result).not.toMatch(/\d{4}/);
        });
    });

    describe('calculateDaysFromToday', () => {
        beforeAll(() => {
            // Freeze time at a known date: 2023-10-01T00:00:00.000Z
            vi.setSystemTime(new Date('2023-10-01T00:00:00Z'));
        });

        afterAll(() => {
            vi.useRealTimers();
        });

        it('returns "0 days" if date is today or in the past', () => {
            const today = '2023-10-01T10:00:00Z'; // same day but later time
            const pastDate = '2023-09-30T00:00:00Z';
            expect(calculateDaysFromToday(today)).toBe('0 days');
            expect(calculateDaysFromToday(pastDate)).toBe('0 days');
        });

        it('returns number of days until a future date', () => {
            // Future date 3 days ahead
            const futureDate = '2023-10-04T12:00:00Z';
            expect(calculateDaysFromToday(futureDate)).toBe('3 days');
        });

        it('returns an empty string if no date is provided', () => {
            expect(calculateDaysFromToday()).toBe('');
            expect(calculateDaysFromToday(null)).toBe('');
        });
    });

    describe('formatNumberWithCommas', () => {
        it('formats numbers with commas', () => {
            expect(formatNumberWithCommas(1000)).toBe('1,000');
            expect(formatNumberWithCommas(1234567)).toBe('1,234,567');
            expect(formatNumberWithCommas(42)).toBe('42'); // no commas needed
            expect(formatNumberWithCommas(1000000000)).toBe('1,000,000,000');
        });

        it('works with negative and decimal numbers', () => {
            // Although the code uses toLocaleString(), decimals and negatives also get formatted
            expect(formatNumberWithCommas(-123456.789)).toBe('-123,456.789');
            // The exact formatting of decimals may vary by locale, but generally commas should appear in the integer part.
        });
    });
});

================
File: renderer/src/utils/instructions.jsx
================
export const mappingInstructions = `
Drag and drop characters onto the user files to associate them.  
The color coding is based on last modified time to assist in this.  
If the character is displayed on the dashboard page, the user file will be updated 
with the account name, and any other character on the account will be associated with the same user file`;

export const syncInstructions = `
Each eve profile on your computer is displayed below.   Choose a character and user file from the dropdowns to enable the sync and sync all buttons.
If you have mapped character files to user files on the mapping page, then the corresponding user file will be automatically selected after selecting a character.
The sync button will copy the settings from the selected user to all characters and users in a given profile. Sync all will do the same across all profiles.
You can also backup your settings using the backup button.`;

export const overviewInstructions = `
Add your characters by account name using the green plus icon in the header.   You can view a summary of their information, or click on the character name to see more details.
You have the option to sort characters by account, by location, or by your own custom defined roles.  If you also use the mapping page to associate character and user files, the characters on this page will automatically associate
to the appropriate user file as soon as one character from the account is associated.`;

export const skillPlanInstructions = `
Use the toggle button to swap between a character view and a skill plan view.   
The tables will show which characters meet the requirements for each skill plan.   If they don't meet the requirements, 
it will either show the skills they are missing, or the days remaining for them to train the needed skills.  
You can copy the skill plan or delete existing skill plans using the icons in the action column.  Additionally, 
to add new skill plans use the yellow skill plan icon in the header.`;

================
File: renderer/src/utils/logger.jsx
================
// src/utils/logger.jsx
import { isDev } from '../Config';

// export function log(...args) {
//     if (isDev) console.log(...args);
// }
//
// export function warn(...args) {
//     if (isDev) console.warn(...args);
// }
//
// export function error(...args) {
//     if (isDev) console.error(...args);
// }
//
// export function trace(...args) {
//     if (isDev) console.trace(...args);
// }


export function log(...args) {
    console.log(...args);
}

export function warn(...args) {
    console.warn(...args);
}

export function error(...args) {
    console.error(...args);
}

export function trace(...args) {
    console.trace(...args);
}

================
File: renderer/src/App.css
================
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

================
File: renderer/src/App.jsx
================
// src/App.jsx

import { useState, useEffect, useCallback } from 'react';
import { HashRouter as Router } from 'react-router-dom';
import { ThemeProvider } from '@mui/material/styles';
import { ToastContainer } from 'react-toastify';

import { useLoginCallback } from './hooks/useLoginCallback';
import { log, trace } from './utils/logger';
import { useAppHandlers } from './hooks/useAppHandlers';
import { getAppData, getAppDataNoCache } from './api/apiService';

import Header from './components/common/Header.jsx';
import Footer from './components/common/Footer.jsx';
import AddSkillPlanModal from './components/skillplan/AddSkillPlanModal.jsx';
import ErrorBoundary from './components/common/ErrorBoundary.jsx';
import AppRoutes from './Routes';
import theme from './Theme.jsx';
import helloImg from './assets/images/hello.png';
import 'react-toastify/dist/ReactToastify.css';

const App = () => {
    const [appData, setAppData] = useState(null);
    const [isAuthenticated, setIsAuthenticated] = useState(false);
    const [isLoading, setIsLoading] = useState(true);
    const [isSkillPlanModalOpen, setIsSkillPlanModalOpen] = useState(false);
    const [isRefreshing, setIsRefreshing] = useState(false);
    const [loggedOut, setLoggedOut] = useState(false);


    useEffect(() => {
        log("isAuthenticated changed:", isAuthenticated);
    }, [isAuthenticated]);

    const fetchData = useCallback(async () => {
        log("fetchData called");
        setIsLoading(true);
        const data = await getAppData();
        if (data) {
            setIsAuthenticated(data.LoggedIn);
            setAppData(data);
        }
        setIsLoading(false);
    }, []);

    const loginRefresh = useCallback(async () => {
        log("loginRefresh called");
        setIsLoading(true);
        const data = await getAppDataNoCache();
        setIsLoading(false);
        if (!data) {
            return false;
        }
        setIsAuthenticated(data.LoggedIn);
        setAppData(data);
        return true;
    }, []);

    const silentRefreshData = useCallback(async () => {
        log("silentRefreshData called");
        if (!isAuthenticated || loggedOut) return;
        setIsRefreshing(true);
        const data = await getAppDataNoCache();
        setIsRefreshing(false);
        if (data) {
            setIsAuthenticated(data.LoggedIn);
            setAppData(data);
        }
    }, [isAuthenticated, loggedOut]);

    useEffect(() => {
        log("loggedOut changed to:", loggedOut);
        trace();
    }, [loggedOut]);

    const loginCallbackFn = useLoginCallback(isAuthenticated, loginRefresh, setLoggedOut, setIsAuthenticated);

    const logInCallBack = (state) => {
        loginCallbackFn(state);
    };

    const {
        handleLogout,
        handleToggleAccountStatus,
        handleUpdateCharacter,
        handleRemoveCharacter,
        handleUpdateAccountName,
        handleRemoveAccount,
        handleAddCharacter,
        handleSaveSkillPlan,
        handleDeleteSkillPlan,
        handleCopySkillPlan,
        handleToggleAccountVisibility,
    } = useAppHandlers({
        setAppData,
        fetchData,
        setIsAuthenticated,
        setLoggedOut,
        setIsSkillPlanModalOpen,
        isAuthenticated,
        loggedOut,
        loginRefresh,
    });

    const openSkillPlanModal = () => setIsSkillPlanModalOpen(true);
    const closeSkillPlanModal = () => setIsSkillPlanModalOpen(false);

    useEffect(() => {
        log("App mounted, calling fetchData");
        fetchData();
    }, [fetchData]);

    useEffect(() => {
        log(`useEffect [isLoading, isAuthenticated]: isLoading=${isLoading}, isAuthenticated=${isAuthenticated}`);
        if (!isLoading && isAuthenticated) {
            silentRefreshData();
        }
    }, [isLoading, isAuthenticated, silentRefreshData]);

    if (isLoading) {
        return (
            <div className="flex flex-col items-center justify-center min-h-screen bg-gray-900 text-teal-200 space-y-4">
                <img
                    src={helloImg}
                    alt="Loading"
                    className="w-32 h-auto object-contain"
                />
                <p className="animate-pulse text-lg">Loading...</p>
            </div>
        );
    }

    const accounts = appData?.AccountData?.Accounts || [];

    const characters = (accounts || [])
        .filter((account) => account.Visible !== false)
        .flatMap((account) => account.Characters || []);

    const existingAccounts = accounts.map((account) => account.Name) || [];

    return (
        <ErrorBoundary>
            <ThemeProvider theme={theme}>
                <Router>
                    <div className="flex flex-col min-h-screen bg-gray-900 text-teal-200">
                        <Header
                            loggedIn={isAuthenticated}
                            handleLogout={handleLogout}
                            openSkillPlanModal={openSkillPlanModal}
                            existingAccounts={existingAccounts}
                            onSilentRefresh={silentRefreshData}
                            onAddCharacter={handleAddCharacter}
                            isRefreshing={isRefreshing}
                        />
                        <main className="flex-grow container mx-auto px-4 py-8 pb-16">
                            <AppRoutes
                                isAuthenticated={isAuthenticated}
                                loggedOut={loggedOut}
                                appData={appData}
                                handleToggleAccountStatus={handleToggleAccountStatus}
                                handleUpdateCharacter={handleUpdateCharacter}
                                handleUpdateAccountName={handleUpdateAccountName}
                                handleRemoveCharacter={handleRemoveCharacter}
                                handleRemoveAccount={handleRemoveAccount}
                                handleDeleteSkillPlan={handleDeleteSkillPlan}
                                handleCopySkillPlan={handleCopySkillPlan}
                                silentRefreshData={silentRefreshData}
                                setAppData={setAppData}
                                characters={characters}
                                logInCallBack={logInCallBack}
                                handleToggleAccountVisibility={handleToggleAccountVisibility}/>
                        </main>
                        <Footer />
                        {isSkillPlanModalOpen && (
                            <AddSkillPlanModal
                                onClose={closeSkillPlanModal}
                                onSave={handleSaveSkillPlan}
                            />
                        )}
                        <ToastContainer />
                    </div>
                </Router>
            </ThemeProvider>
        </ErrorBoundary>
    );
};

export default App;

================
File: renderer/src/Config.jsx
================
// src/config.js

// Determine if the app is running in development mode.
// This depends on your build tools. For Vite, `import.meta.env.DEV` is used.
// If using Create React App, you might use `process.env.NODE_ENV !== 'production'`.
const isDev = import.meta.env.DEV;

// Define the back-end URL based on the environment.
// In production, you might adjust this URL accordingly.
const backEndURL = isDev ? '' : 'http://localhost:8713';

export { isDev, backEndURL };

================
File: renderer/src/index.css
================
/* src/index.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

================
File: renderer/src/main.jsx
================
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.jsx'

createRoot(document.getElementById('root')).render(
  <StrictMode>
    <App />
  </StrictMode>,
)

================
File: renderer/src/Routes.jsx
================
// src/Routes.jsx

import { Routes, Route } from 'react-router-dom';
import PropTypes from 'prop-types';

import CharacterOverview from './pages/CharacterOverview.jsx';
import SkillPlans from './pages/SkillPlans.jsx';
import Landing from './pages/Landing.jsx';
import Sync from './pages/Sync.jsx';
import Mapping from './pages/Mapping.jsx';

function AppRoutes({
                       isAuthenticated,
                       loggedOut,
                       appData,
                       handleToggleAccountStatus,
                       handleUpdateCharacter,
                       handleUpdateAccountName,
                       handleRemoveCharacter,
                       handleRemoveAccount,
                       handleDeleteSkillPlan,
                       handleCopySkillPlan,
                       silentRefreshData,
                       setAppData,
                       characters,
                       logInCallBack,
                       handleToggleAccountVisibility,
                   }) {
    if (!isAuthenticated || loggedOut) {
        return <Landing logInCallBack={logInCallBack} />;
    } else if (!appData) {
        return (
            <div className="flex items-center justify-center min-h-screen bg-gray-900 text-teal-200">
                <p>Loading...</p>
            </div>
        );
    } else {
        // Using new model fields:
        const accounts = appData.AccountData?.Accounts || [];
        const roles = appData.ConfigData?.Roles || [];
        const skillPlans = appData.EveData?.SkillPlans || {};
        const eveProfiles = appData.EveData?.EveProfiles || [];
        const associations = appData.AccountData?.Associations || [];
        const userSelections = appData.ConfigData?.DropDownSelections || {};
        const currentSettingsDir = appData.ConfigData?.SettingsDir || '';
        const lastBackupDir = appData.ConfigData?.LastBackupDir || '';
        const eveConversions = appData.EveData?.EveConversions || {};

        return (
            <Routes>
                <Route
                    path="/"
                    element={
                        <CharacterOverview
                            accounts={accounts}
                            onToggleAccountStatus={handleToggleAccountStatus}
                            onUpdateCharacter={handleUpdateCharacter}
                            onUpdateAccountName={handleUpdateAccountName}
                            onRemoveCharacter={handleRemoveCharacter}
                            onRemoveAccount={handleRemoveAccount}
                            roles={roles}
                            skillConversions={eveConversions}
                            onToggleAccountVisibility={handleToggleAccountVisibility}
                        />
                    }
                />
                <Route
                    path="/skill-plans"
                    element={
                        <SkillPlans
                            characters={characters}
                            skillPlans={skillPlans} // Using EveData.SkillPlans
                            setAppData={setAppData}
                            conversions={eveConversions}
                            onDeleteSkillPlan={handleDeleteSkillPlan}
                            onCopySkillPlan={handleCopySkillPlan}
                        />
                    }
                />
                <Route
                    path="/sync"
                    element={
                        <Sync
                            settingsData={eveProfiles}
                            associations={associations}
                            currentSettingsDir={currentSettingsDir}
                            userSelections={userSelections}
                            lastBackupDir={lastBackupDir}
                        />
                    }
                />
                <Route
                    path="/mapping"
                    element={
                        <Mapping
                            associations={associations}
                            subDirs={eveProfiles}
                            onRefreshData={silentRefreshData}
                        />
                    }
                />
                <Route path="*" element={<div>Route Not Found</div>} />
            </Routes>
        );
    }
}

AppRoutes.propTypes = {
    isAuthenticated: PropTypes.bool.isRequired,
    loggedOut: PropTypes.bool.isRequired,
    appData: PropTypes.shape({
        AccountData: PropTypes.shape({
            Accounts: PropTypes.array,
            Associations: PropTypes.array
        }),
        ConfigData: PropTypes.shape({
            Roles: PropTypes.array,
            SettingsDir: PropTypes.string,
            LastBackupDir: PropTypes.string,
            DropDownSelections: PropTypes.object,
        }),
        EveData: PropTypes.shape({
            SkillPlans: PropTypes.object,
            EveProfiles: PropTypes.array,
            EveConversions: PropTypes.object,
        })
    }),
    handleToggleAccountStatus: PropTypes.func.isRequired,
    handleUpdateCharacter: PropTypes.func.isRequired,
    handleUpdateAccountName: PropTypes.func.isRequired,
    handleRemoveCharacter: PropTypes.func.isRequired,
    handleRemoveAccount: PropTypes.func.isRequired,
    silentRefreshData: PropTypes.func.isRequired,
    setAppData: PropTypes.func.isRequired,
    characters: PropTypes.array.isRequired,
    logInCallBack: PropTypes.func.isRequired,
    handleToggleAccountVisibility: PropTypes.func.isRequired,
};

export default AppRoutes;

================
File: renderer/src/setupTests.js
================
import '@testing-library/jest-dom';

================
File: renderer/src/Theme.jsx
================
// theme.js
import { createTheme } from '@mui/material/styles';

const theme = createTheme({
    palette: {
        primary: {
            main: '#14b8a6'
        },
        secondary: {
            main: '#ef4444'
        },
        info: {
            main: '#14b8a6', // Change this to teal as well
        },
        warning: { main:
                '#f59e0b'
        },
        background: {
            default: '#1f2937',
            paper: '#2d3748',
        },
        text: {
            primary: '#d1d5db', // Tailwind 'gray-300'
            secondary: '#9ca3af', // Tailwind 'gray-400'
        },
    },
    typography: {
        fontFamily: 'Roboto, sans-serif',
        h6: {
            fontWeight: 600,
        },
    },
    components: {
        MuiCard: {
            styleOverrides: {
                root: {
                    transition: 'box-shadow 0.3s ease-in-out, transform 0.3s ease-in-out',
                },
            },
        },
        MuiListItem: {
            styleOverrides: {
                root: {
                    borderRadius: 4,
                },
            },
        },
        MuiButton: {
            styleOverrides: {
                root: {
                    textTransform: 'none', // Prevent uppercase transformation
                },
            },
        },
        MuiSelect: {
            styleOverrides: {
                select: {
                    backgroundColor: 'background.paper',
                    borderRadius: 1,
                },
            },
        },
    },
});

export default theme;

================
File: renderer/.gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

================
File: renderer/eslint.config.js
================
import js from '@eslint/js'
import globals from 'globals'
import react from 'eslint-plugin-react'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'

export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    settings: { react: { version: '18.3' } },
    plugins: {
      react,
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...react.configs.recommended.rules,
      ...react.configs['jsx-runtime'].rules,
      ...reactHooks.configs.recommended.rules,
      'react/jsx-no-target-blank': 'off',
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]

================
File: renderer/index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

================
File: renderer/package.json
================
{
  "name": "renderer",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "test": "vitest run"
  },
  "dependencies": {
    "@emotion/react": "^11.13.5",
    "@emotion/styled": "^11.13.5",
    "@mui/icons-material": "^6.1.9",
    "@mui/lab": "^6.0.0-beta.18",
    "@mui/material": "^6.1.9",
    "@mui/styles": "^6.1.9",
    "electron-is-dev": "^3.0.1",
    "next-themes": "^0.4.3",
    "prop-types": "^15.8.1",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-icons": "^5.3.0",
    "react-router-dom": "^7.0.1",
    "react-toastify": "^10.0.6",
    "toastr": "^2.1.4"
  },
  "devDependencies": {
    "@eslint/js": "^9.15.0",
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^16.1.0",
    "@testing-library/user-event": "^14.5.2",
    "@types/react": "^18.3.12",
    "@types/react-dom": "^18.3.1",
    "@vitejs/plugin-react": "^4.3.4",
    "autoprefixer": "^10.4.20",
    "eslint": "^9.15.0",
    "eslint-plugin-react": "^7.37.2",
    "eslint-plugin-react-hooks": "^5.0.0",
    "eslint-plugin-react-refresh": "^0.4.14",
    "globals": "^15.12.0",
    "jsdom": "^25.0.1",
    "postcss": "^8.4.49",
    "tailwindcss": "^3.4.15",
    "vite": "^6.0.1",
    "vitest": "^2.1.8",
    "wait-on": "^8.0.1"
  }
}

================
File: renderer/postcss.config.cjs
================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};

================
File: renderer/README.md
================
# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

================
File: renderer/tailwind.config.cjs
================
// tailwind.config.js

module.exports = {
    darkMode: 'class', // Enables class-based dark mode
    content: [
        "./index.html",
        "./src/**/*.{js,jsx,ts,tsx}",
    ],
    theme: {
        extend: {},
    },
    plugins: [],
};

================
File: renderer/vite.config.js
================
// vite.config.js
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react({
    // Explicitly set the JSX runtime to automatic
    jsxRuntime: 'automatic',
  })],
  base: "./",
  server: {
    port: 5173,
    proxy: {
      '/api': {
        target: 'http://localhost:8713',
        changeOrigin: true,
        secure: false,
      },
      'v2': {
        target: 'https://login.eveonline.com',
        changeOrigin: true,
        secure: true,
      }
    },
  },
});

================
File: renderer/vitest.config.js
================
// vitest.config.js
import { defineConfig } from 'vitest/config'


export default defineConfig({
    test: {
        globals: true,
        environment: 'jsdom',
        setupFiles: './src/setupTests.js'
    }
})



================================================================
End of Codebase
================================================================
